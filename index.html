<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="FloorPlan Pro">
  <title>FloorPlan Pro v5.0</title>
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23080c10' width='100' height='100'/><text y='65' x='50' text-anchor='middle' font-size='50'>üè†</text></svg>">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; -webkit-user-select: none; user-select: none; }
    html, body, #root { width: 100%; height: 100%; overflow: hidden; }
    body { background: #080c10; touch-action: none; }
    input, select, button { font-family: inherit; }
    input[type="text"], input[type="number"] { 
      user-select: text; 
      -webkit-user-select: text;
      touch-action: manipulation;
    }
    @media print {
      body { background: #fff !important; }
      #print-sheet { box-shadow: none !important; }
      * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
    }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useRef, useEffect, useCallback, useMemo } = React;


// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================
const GRID_SIZE = 20; // Base grid size in pixels (6" at default scale)
const GRID_OPTIONS = {
  '6"': { size: 20, label: '6 inches', divisor: 2 },      // 1 grid = 6", 2 grids = 1'
  '3"': { size: 10, label: '3 inches', divisor: 4 },      // 1 grid = 3", 4 grids = 1'
  '1"': { size: 3.333, label: '1 inch', divisor: 12 },    // 1 grid = 1", 12 grids = 1'
  'off': { size: 1, label: 'No snapping', divisor: 24 },  // Essentially no snapping
};
const DEFAULT_WALL_HEIGHT = 96; // 8 feet in inches
const WALL_THICKNESS_OPTIONS = {
  interior: { thickness: 6, label: 'Int 2√ó4', fullLabel: 'Interior 2√ó4', defaultHeight: 96, stud: '2x4' },
  exterior: { thickness: 10, label: 'Ext 2√ó6', fullLabel: 'Exterior 2√ó6', defaultHeight: 96, stud: '2x6' },
  partition: { thickness: 4, label: 'Partition', fullLabel: 'Partition', defaultHeight: 84, stud: '2x4' },
  'half-wall': { thickness: 6, label: 'Half', fullLabel: 'Half Wall', defaultHeight: 42, stud: '2x4' },
  'interior-2x6': { thickness: 8, label: 'Int 2√ó6', fullLabel: 'Interior 2√ó6', defaultHeight: 96, stud: '2x6' },
  'exterior-2x4': { thickness: 8, label: 'Ext 2√ó4', fullLabel: 'Exterior 2√ó4', defaultHeight: 96, stud: '2x4' },
};

// Wall construction layers (in pixels at scale, from outside/left to inside/right)
// Layer thicknesses based on real measurements converted to our scale
const WALL_LAYERS = {
  // Exterior 2x6 wall: Total ~8" (siding 1" + sheathing 0.5" + stud 5.5" + drywall 0.5")
  'exterior': {
    layers: [
      { name: 'Siding', thickness: 1.2, color: '#8B7355', pattern: 'siding' },
      { name: 'House Wrap', thickness: 0.2, color: '#f0f0f0', pattern: 'solid' },
      { name: 'Sheathing', thickness: 0.8, color: '#C4A574', pattern: 'plywood' },
      { name: 'Insulation', thickness: 5.0, color: '#FFD1DC', pattern: 'insulation' },
      { name: 'Vapor Barrier', thickness: 0.2, color: '#87CEEB', pattern: 'solid' },
      { name: 'Drywall', thickness: 0.6, color: '#E8E4DF', pattern: 'solid' },
    ],
    studs: { spacing: 16, width: 1.5, depth: 5.5, color: '#DEB887' }
  },
  // Exterior 2x4 wall: Total ~6" (siding 1" + sheathing 0.5" + stud 3.5" + drywall 0.5")
  'exterior-2x4': {
    layers: [
      { name: 'Siding', thickness: 1.0, color: '#8B7355', pattern: 'siding' },
      { name: 'House Wrap', thickness: 0.2, color: '#f0f0f0', pattern: 'solid' },
      { name: 'Sheathing', thickness: 0.6, color: '#C4A574', pattern: 'plywood' },
      { name: 'Insulation', thickness: 3.2, color: '#FFD1DC', pattern: 'insulation' },
      { name: 'Vapor Barrier', thickness: 0.2, color: '#87CEEB', pattern: 'solid' },
      { name: 'Drywall', thickness: 0.6, color: '#E8E4DF', pattern: 'solid' },
    ],
    studs: { spacing: 16, width: 1.5, depth: 3.5, color: '#DEB887' }
  },
  // Interior 2x4 wall: Total ~4.5" (drywall 0.5" + stud 3.5" + drywall 0.5")
  'interior': {
    layers: [
      { name: 'Drywall', thickness: 0.6, color: '#E8E4DF', pattern: 'solid' },
      { name: 'Stud Cavity', thickness: 3.3, color: '#2a2a2a', pattern: 'cavity' },
      { name: 'Drywall', thickness: 0.6, color: '#E8E4DF', pattern: 'solid' },
    ],
    studs: { spacing: 16, width: 1.5, depth: 3.5, color: '#DEB887' }
  },
  // Interior 2x6 wall: Total ~6.5" (drywall 0.5" + stud 5.5" + drywall 0.5")
  'interior-2x6': {
    layers: [
      { name: 'Drywall', thickness: 0.6, color: '#E8E4DF', pattern: 'solid' },
      { name: 'Stud Cavity', thickness: 5.3, color: '#2a2a2a', pattern: 'cavity' },
      { name: 'Drywall', thickness: 0.6, color: '#E8E4DF', pattern: 'solid' },
    ],
    studs: { spacing: 16, width: 1.5, depth: 5.5, color: '#DEB887' }
  },
  // Partition wall: Total ~4" (drywall 0.5" + stud 3" + drywall 0.5")
  'partition': {
    layers: [
      { name: 'Drywall', thickness: 0.5, color: '#E8E4DF', pattern: 'solid' },
      { name: 'Stud Cavity', thickness: 2.5, color: '#2a2a2a', pattern: 'cavity' },
      { name: 'Drywall', thickness: 0.5, color: '#E8E4DF', pattern: 'solid' },
    ],
    studs: { spacing: 24, width: 1.5, depth: 2.5, color: '#DEB887' }
  },
  // Half wall (same as interior 2x4)
  'half-wall': {
    layers: [
      { name: 'Drywall', thickness: 0.6, color: '#E8E4DF', pattern: 'solid' },
      { name: 'Stud Cavity', thickness: 3.3, color: '#2a2a2a', pattern: 'cavity' },
      { name: 'Drywall', thickness: 0.6, color: '#E8E4DF', pattern: 'solid' },
    ],
    studs: { spacing: 16, width: 1.5, depth: 3.5, color: '#DEB887' }
  },
};

// Wall detail level options
const WALL_DETAIL_LEVELS = {
  simple: { label: 'Simple', description: 'Solid fill' },
  standard: { label: 'Standard', description: 'Layer outlines' },
  detailed: { label: 'Detailed', description: 'Full construction' },
};

// Roof types
const ROOF_TYPES = {
  gable: { label: 'Gable', description: 'Two sloping sides meeting at ridge', icon: '‚åÇ' },
  hip: { label: 'Hip', description: 'Slopes on all four sides', icon: '‚åÇ' },
  shed: { label: 'Shed', description: 'Single sloping surface', icon: '/' },
  flat: { label: 'Flat', description: 'Level roof surface', icon: '‚ñ≠' },
  gambrel: { label: 'Gambrel', description: 'Barn-style with two slopes per side', icon: '‚åÇ' },
};

const ROOF_PITCHES = {
  '3:12': { rise: 3, run: 12, label: '3:12 (14¬∞)' },
  '4:12': { rise: 4, run: 12, label: '4:12 (18¬∞)' },
  '5:12': { rise: 5, run: 12, label: '5:12 (22¬∞)' },
  '6:12': { rise: 6, run: 12, label: '6:12 (27¬∞)' },
  '8:12': { rise: 8, run: 12, label: '8:12 (34¬∞)' },
  '10:12': { rise: 10, run: 12, label: '10:12 (40¬∞)' },
  '12:12': { rise: 12, run: 12, label: '12:12 (45¬∞)' },
};

const FURNITURE_LIBRARY = [
  { id: 'bed-king', name: 'King Bed', category: 'bedroom', width: 80, height: 76, icon: 'üõèÔ∏è', shape: 'bed' },
  { id: 'bed-queen', name: 'Queen Bed', category: 'bedroom', width: 60, height: 80, icon: 'üõèÔ∏è', shape: 'bed' },
  { id: 'bed-twin', name: 'Twin Bed', category: 'bedroom', width: 38, height: 75, icon: 'üõèÔ∏è', shape: 'bed' },
  { id: 'dresser', name: 'Dresser', category: 'bedroom', width: 60, height: 20, icon: 'üóÑÔ∏è', shape: 'cabinet' },
  { id: 'nightstand', name: 'Nightstand', category: 'bedroom', width: 24, height: 24, icon: 'ü™ë', shape: 'cabinet' },
  { id: 'sofa-3', name: '3-Seat Sofa', category: 'living', width: 84, height: 36, icon: 'üõãÔ∏è', shape: 'sofa' },
  { id: 'sofa-2', name: 'Loveseat', category: 'living', width: 60, height: 36, icon: 'üõãÔ∏è', shape: 'sofa' },
  { id: 'armchair', name: 'Armchair', category: 'living', width: 36, height: 34, icon: 'ü™ë', shape: 'chair' },
  { id: 'coffee-table', name: 'Coffee Table', category: 'living', width: 48, height: 24, icon: 'ü™µ', shape: 'table' },
  { id: 'tv-stand', name: 'TV Stand', category: 'living', width: 60, height: 18, icon: 'üì∫', shape: 'cabinet' },
  { id: 'dining-table-6', name: 'Dining Table (6)', category: 'dining', width: 72, height: 42, icon: 'ü™ë', shape: 'table' },
  { id: 'dining-table-4', name: 'Dining Table (4)', category: 'dining', width: 48, height: 36, icon: 'ü™ë', shape: 'table' },
  { id: 'dining-chair', name: 'Dining Chair', category: 'dining', width: 18, height: 18, icon: 'ü™ë', shape: 'chair' },
  { id: 'fridge', name: 'Refrigerator', category: 'kitchen', width: 36, height: 30, icon: 'üßä', shape: 'appliance' },
  { id: 'stove', name: 'Stove/Oven', category: 'kitchen', width: 30, height: 26, icon: 'üç≥', shape: 'stove' },
  { id: 'sink-kitchen', name: 'Kitchen Sink', category: 'kitchen', width: 33, height: 22, icon: 'üö∞', shape: 'sink' },
  { id: 'dishwasher', name: 'Dishwasher', category: 'kitchen', width: 24, height: 24, icon: 'ü´ß', shape: 'appliance' },
  { id: 'counter-24', name: 'Counter 24"', category: 'kitchen', width: 24, height: 25, icon: 'üî≤', shape: 'counter' },
  { id: 'counter-36', name: 'Counter 36"', category: 'kitchen', width: 36, height: 25, icon: 'üî≤', shape: 'counter' },
  { id: 'counter-48', name: 'Counter 48"', category: 'kitchen', width: 48, height: 25, icon: 'üî≤', shape: 'counter' },
  { id: 'counter-60', name: 'Counter 60"', category: 'kitchen', width: 60, height: 25, icon: 'üî≤', shape: 'counter' },
  { id: 'counter-72', name: 'Counter 72"', category: 'kitchen', width: 72, height: 25, icon: 'üî≤', shape: 'counter' },
  { id: 'counter-corner', name: 'Corner Counter', category: 'kitchen', width: 36, height: 36, icon: 'üî≤', shape: 'counter-corner' },
  { id: 'island-small', name: 'Island (Small)', category: 'kitchen', width: 48, height: 30, icon: 'üî≤', shape: 'island' },
  { id: 'island-large', name: 'Island (Large)', category: 'kitchen', width: 72, height: 42, icon: 'üî≤', shape: 'island' },
  { id: 'toilet', name: 'Toilet', category: 'bathroom', width: 18, height: 28, icon: 'üöΩ', shape: 'toilet' },
  { id: 'bathtub', name: 'Bathtub', category: 'bathroom', width: 60, height: 32, icon: 'üõÅ', shape: 'tub' },
  { id: 'shower', name: 'Shower', category: 'bathroom', width: 36, height: 36, icon: 'üöø', shape: 'shower' },
  { id: 'sink-bath', name: 'Bathroom Sink', category: 'bathroom', width: 24, height: 20, icon: 'üö∞', shape: 'sink' },
  { id: 'desk', name: 'Desk', category: 'office', width: 60, height: 30, icon: 'üñ•Ô∏è', shape: 'table' },
  { id: 'office-chair', name: 'Office Chair', category: 'office', width: 24, height: 24, icon: 'ü™ë', shape: 'chair' },
  { id: 'bookshelf', name: 'Bookshelf', category: 'office', width: 36, height: 12, icon: 'üìö', shape: 'cabinet' },
  { id: 'washer', name: 'Washer', category: 'utility', width: 27, height: 27, icon: 'ü´ß', shape: 'appliance' },
  { id: 'dryer', name: 'Dryer', category: 'utility', width: 27, height: 27, icon: 'üí®', shape: 'appliance' },
];

const STAIRS_LIBRARY = [
  { id: 'stairs-straight', name: 'Straight Stairs', width: 36, height: 120, steps: 12, icon: 'ü™ú', type: 'straight' },
  { id: 'stairs-l', name: 'L-Shaped Stairs', width: 80, height: 80, steps: 12, icon: 'ü™ú', type: 'l-shape' },
  { id: 'stairs-u', name: 'U-Shaped Stairs', width: 80, height: 120, steps: 16, icon: 'ü™ú', type: 'u-shape' },
  { id: 'stairs-spiral', name: 'Spiral Stairs', width: 60, height: 60, steps: 12, icon: 'üåÄ', type: 'spiral' },
  { id: 'ramp-straight', name: 'Straight Ramp', width: 48, height: 144, icon: 'üìê', type: 'ramp' },
  { id: 'ramp-switchback', name: 'Switchback Ramp', width: 96, height: 144, icon: 'üìê', type: 'ramp-switchback' },
];

const ELECTRICAL_LIBRARY = [
  { id: 'outlet-standard', name: 'Standard Outlet', icon: 'üîå', symbol: '‚ä°', category: 'outlet' },
  { id: 'outlet-gfci', name: 'GFCI Outlet', icon: 'üîå', symbol: '‚ä°G', category: 'outlet' },
  { id: 'outlet-220v', name: '220V Outlet', icon: '‚ö°', symbol: '‚ä°‚ä°', category: 'outlet' },
  { id: 'switch-single', name: 'Single Switch', icon: 'üîò', symbol: 'S', category: 'switch' },
  { id: 'switch-3way', name: '3-Way Switch', icon: 'üîò', symbol: 'S3', category: 'switch' },
  { id: 'switch-dimmer', name: 'Dimmer Switch', icon: 'üîÜ', symbol: 'SD', category: 'switch' },
  { id: 'light-ceiling', name: 'Ceiling Light', icon: 'üí°', symbol: '‚óØ', category: 'light' },
  { id: 'light-recessed', name: 'Recessed Light', icon: 'üîÖ', symbol: '‚äô', category: 'light' },
  { id: 'light-pendant', name: 'Pendant Light', icon: 'üí°', symbol: '‚óé', category: 'light' },
  { id: 'light-fan', name: 'Ceiling Fan', icon: 'üåÄ', symbol: '‚äï', category: 'light' },
  { id: 'smoke-detector', name: 'Smoke Detector', icon: 'üö®', symbol: 'SD', category: 'safety' },
  { id: 'co-detector', name: 'CO Detector', icon: '‚ö†Ô∏è', symbol: 'CO', category: 'safety' },
  { id: 'panel-main', name: 'Main Panel', icon: '‚ö°', symbol: '‚ñ£', category: 'panel' },
  { id: 'panel-sub', name: 'Sub Panel', icon: '‚ö°', symbol: '‚ñ¢', category: 'panel' },
];

const PLUMBING_LIBRARY = [
  { id: 'water-heater', name: 'Water Heater', icon: 'üî•', symbol: 'WH', size: 24 },
  { id: 'supply-hot', name: 'Hot Water Line', icon: 'üî¥', symbol: '‚îÄ', lineType: 'hot' },
  { id: 'supply-cold', name: 'Cold Water Line', icon: 'üîµ', symbol: '‚îÄ', lineType: 'cold' },
  { id: 'drain', name: 'Drain Line', icon: '‚ö´', symbol: '‚ïê', lineType: 'drain' },
  { id: 'vent', name: 'Vent Stack', icon: 'üü§', symbol: '‚îÉ', lineType: 'vent' },
  { id: 'cleanout', name: 'Cleanout', icon: 'üîß', symbol: 'CO', size: 12 },
  { id: 'shutoff', name: 'Shutoff Valve', icon: 'üî¥', symbol: '‚óÜ', size: 10 },
  { id: 'hose-bib', name: 'Hose Bib', icon: 'üöø', symbol: 'HB', size: 12 },
  { id: 'floor-drain', name: 'Floor Drain', icon: '‚¨áÔ∏è', symbol: '‚äó', size: 14 },
  { id: 'sump-pump', name: 'Sump Pump', icon: 'üíß', symbol: 'SP', size: 20 },
];

const DOOR_TYPES = [
  { id: 'single', name: 'Single Door', defaultWidth: 36, icon: 'üö™', description: 'Standard hinged door' },
  { id: 'double', name: 'Double Door', defaultWidth: 60, icon: 'üö™üö™', description: 'Two-panel hinged' },
  { id: 'sliding', name: 'Sliding Door', defaultWidth: 72, icon: '‚ÜîÔ∏è', description: 'Slides on track' },
  { id: 'pocket', name: 'Pocket Door', defaultWidth: 32, icon: 'üì•', description: 'Slides into wall' },
  { id: 'bifold', name: 'Bifold Door', defaultWidth: 48, icon: 'üìÇ', description: 'Folds in sections' },
  { id: 'french', name: 'French Door', defaultWidth: 60, icon: 'ü™ü', description: 'Glass panel double' },
  { id: 'garage', name: 'Garage Door', defaultWidth: 192, icon: 'üöó', description: 'Roll-up garage' },
  { id: 'barn', name: 'Barn Door', defaultWidth: 42, icon: 'üö™', description: 'Exterior sliding' },
];

const WINDOW_TYPES = [
  { id: 'single-hung', name: 'Single Hung', defaultWidth: 36, defaultHeight: 48, icon: '‚¨ÜÔ∏è', description: 'Bottom sash moves' },
  { id: 'double-hung', name: 'Double Hung', defaultWidth: 36, defaultHeight: 54, icon: '‚ÜïÔ∏è', description: 'Both sashes move' },
  { id: 'casement', name: 'Casement', defaultWidth: 24, defaultHeight: 48, icon: '‚Ü™Ô∏è', description: 'Hinged, cranks out' },
  { id: 'sliding', name: 'Sliding', defaultWidth: 48, defaultHeight: 36, icon: '‚ÜîÔ∏è', description: 'Horizontal slide' },
  { id: 'fixed', name: 'Fixed/Picture', defaultWidth: 60, defaultHeight: 48, icon: 'üñºÔ∏è', description: 'Does not open' },
  { id: 'awning', name: 'Awning', defaultWidth: 36, defaultHeight: 24, icon: '‚§¥Ô∏è', description: 'Hinged at top' },
  { id: 'bay', name: 'Bay Window', defaultWidth: 72, defaultHeight: 54, icon: 'ü™ü', description: '3-panel angled' },
  { id: 'bow', name: 'Bow Window', defaultWidth: 84, defaultHeight: 54, icon: 'ü™ü', description: 'Curved multi-panel' },
  { id: 'skylight', name: 'Skylight', defaultWidth: 24, defaultHeight: 48, icon: '‚òÄÔ∏è', description: 'Roof window' },
];

const TEXT_STYLES = {
  label: { name: 'Label', fontSize: 14, fontWeight: 'bold', color: '#ffffff', background: 'rgba(0,0,0,0.6)' },
  note: { name: 'Note', fontSize: 11, fontWeight: 'normal', color: '#ffaa00', background: 'rgba(0,0,0,0.4)' },
  title: { name: 'Title', fontSize: 18, fontWeight: 'bold', color: '#00c8ff', background: 'none' },
  callout: { name: 'Callout', fontSize: 12, fontWeight: 'normal', color: '#ff6666', background: 'rgba(255,100,100,0.15)' },
  dimension: { name: 'Dimension', fontSize: 10, fontWeight: 'normal', color: '#00ffaa', background: 'none' },
};

const DIMENSION_STYLES = {
  standard: { color: '#00c8ff', tickSize: 8, fontSize: 11, offset: 25 },
  compact: { color: '#ffaa00', tickSize: 6, fontSize: 9, offset: 18 },
  bold: { color: '#00ffaa', tickSize: 10, fontSize: 13, offset: 30 },
};

const ROOM_PRESETS = [
  { name: 'Living Room', color: 'rgba(100, 200, 255, 0.15)' },
  { name: 'Bedroom', color: 'rgba(200, 150, 255, 0.15)' },
  { name: 'Kitchen', color: 'rgba(255, 200, 100, 0.15)' },
  { name: 'Bathroom', color: 'rgba(100, 255, 200, 0.15)' },
  { name: 'Dining Room', color: 'rgba(255, 150, 150, 0.15)' },
  { name: 'Office', color: 'rgba(150, 200, 150, 0.15)' },
  { name: 'Closet', color: 'rgba(200, 200, 200, 0.15)' },
  { name: 'Hallway', color: 'rgba(180, 180, 220, 0.15)' },
  { name: 'Garage', color: 'rgba(150, 150, 150, 0.15)' },
  { name: 'Laundry', color: 'rgba(150, 220, 255, 0.15)' },
];

// Line types
const LINE_TYPES = {
  solid: { name: 'Solid', dash: [] },
  dashed: { name: 'Dashed', dash: [10, 5] },
  dotted: { name: 'Dotted', dash: [2, 4] },
  centerline: { name: 'Center', dash: [20, 5, 5, 5] },
  hidden: { name: 'Hidden', dash: [8, 4] },
  property: { name: 'Property', dash: [15, 5, 3, 5] },
};

// Hatch patterns
const HATCH_PATTERNS = {
  concrete: { name: 'Concrete', color: '#888888', type: 'dots' },
  gravel: { name: 'Gravel', color: '#999966', type: 'gravel' },
  grass: { name: 'Grass', color: '#66aa66', type: 'grass' },
  pavement: { name: 'Pavement', color: '#666666', type: 'diagonal' },
  water: { name: 'Water', color: '#4488cc', type: 'waves' },
  earth: { name: 'Earth', color: '#886644', type: 'earth' },
  brick: { name: 'Brick', color: '#aa6644', type: 'brick' },
  tile: { name: 'Tile', color: '#aaaaaa', type: 'tile' },
  wood: { name: 'Wood', color: '#aa8855', type: 'wood' },
  insulation: { name: 'Insulation', color: '#ffaacc', type: 'insulation' },
  sand: { name: 'Sand', color: '#ddcc88', type: 'stipple' },
  stone: { name: 'Stone', color: '#778899', type: 'stone' },
};

// Porch types
const PORCH_TYPES = {
  open: { name: 'Open Porch', color: 'rgba(139, 119, 101, 0.3)', hasRoof: true, hasScreens: false },
  screened: { name: 'Screened Porch', color: 'rgba(139, 119, 101, 0.4)', hasRoof: true, hasScreens: true },
  covered: { name: 'Covered Patio', color: 'rgba(120, 100, 80, 0.3)', hasRoof: true, hasScreens: false },
  deck: { name: 'Deck', color: 'rgba(160, 130, 90, 0.4)', hasRoof: false, hasScreens: false },
  patio: { name: 'Patio', color: 'rgba(140, 140, 140, 0.3)', hasRoof: false, hasScreens: false },
  sunroom: { name: 'Sunroom', color: 'rgba(200, 220, 255, 0.3)', hasRoof: true, hasScreens: false, hasGlass: true },
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================
const snapToGridSize = (value, gridSize) => Math.round(value / gridSize) * gridSize;
const snapToGrid = (value) => Math.round(value / GRID_SIZE) * GRID_SIZE; // Default 6" grid
const distance = (p1, p2) => Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);

// Adjust color brightness (positive = lighter, negative = darker)
const adjustColor = (color, amount) => {
  // Handle hex colors
  if (color.startsWith('#')) {
    let hex = color.slice(1);
    if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
    const r = Math.min(255, Math.max(0, parseInt(hex.slice(0, 2), 16) + amount));
    const g = Math.min(255, Math.max(0, parseInt(hex.slice(2, 4), 16) + amount));
    const b = Math.min(255, Math.max(0, parseInt(hex.slice(4, 6), 16) + amount));
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  }
  // Handle rgb/rgba
  const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (match) {
    const r = Math.min(255, Math.max(0, parseInt(match[1]) + amount));
    const g = Math.min(255, Math.max(0, parseInt(match[2]) + amount));
    const b = Math.min(255, Math.max(0, parseInt(match[3]) + amount));
    return color.includes('rgba') ? color.replace(/rgba?\([^)]+/, `rgba(${r}, ${g}, ${b}`) : `rgb(${r}, ${g}, ${b})`;
  }
  return color;
};

// Higher precision conversions (don't round to 1 decimal)
const pixelsToFeet = (pixels) => pixels / GRID_SIZE / 2;
const feetToPixels = (feet) => parseFloat(feet) * GRID_SIZE * 2;
const inchesToFeet = (inches) => inches / 12;
const feetToInches = (feet) => parseFloat(feet) * 12;

const generateId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

// Draw hatch pattern in a polygon
const drawHatchPattern = (ctx, points, pattern, patternScale = 1, fillOpacity = 0.5) => {
  if (points.length < 3) return;
  
  const patternDef = HATCH_PATTERNS[pattern] || HATCH_PATTERNS.concrete;
  const spacing = 12 * patternScale;
  
  // Get bounding box
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  points.forEach(p => {
    minX = Math.min(minX, p.x);
    minY = Math.min(minY, p.y);
    maxX = Math.max(maxX, p.x);
    maxY = Math.max(maxY, p.y);
  });
  
  ctx.save();
  
  // Clip to polygon
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.closePath();
  ctx.clip();
  
  // Convert color to rgba
  let r, g, b;
  if (patternDef.color.startsWith('#')) {
    // Hex color
    const hex = patternDef.color;
    r = parseInt(hex.slice(1, 3), 16);
    g = parseInt(hex.slice(3, 5), 16);
    b = parseInt(hex.slice(5, 7), 16);
  } else if (patternDef.color.startsWith('rgb')) {
    // RGB color - extract numbers
    const matches = patternDef.color.match(/\d+/g);
    if (matches && matches.length >= 3) {
      r = parseInt(matches[0]);
      g = parseInt(matches[1]);
      b = parseInt(matches[2]);
    } else {
      r = g = b = 128; // Fallback to gray
    }
  } else {
    r = g = b = 128; // Fallback to gray
  }

  // Fill background
  ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${fillOpacity * 0.3})`;
  ctx.fill();

  // Draw pattern
  ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${fillOpacity})`;
  ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${fillOpacity})`;
  ctx.lineWidth = 1;
  
  switch (patternDef.type) {
    case 'diagonal':
      // Diagonal lines
      for (let x = minX - (maxY - minY); x < maxX + spacing; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x, minY);
        ctx.lineTo(x + (maxY - minY), maxY);
        ctx.stroke();
      }
      break;
      
    case 'dots':
    case 'stipple':
      // Random dots for concrete/stipple
      const dotSpacing = spacing * 0.8;
      for (let x = minX; x < maxX; x += dotSpacing) {
        for (let y = minY; y < maxY; y += dotSpacing) {
          const ox = (Math.random() - 0.5) * dotSpacing * 0.5;
          const oy = (Math.random() - 0.5) * dotSpacing * 0.5;
          ctx.beginPath();
          ctx.arc(x + ox, y + oy, patternDef.type === 'stipple' ? 1.5 : 1, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      break;
      
    case 'gravel':
      // Irregular small circles
      const gravelSpacing = spacing * 1.2;
      for (let x = minX; x < maxX; x += gravelSpacing) {
        for (let y = minY; y < maxY; y += gravelSpacing) {
          const ox = (Math.random() - 0.5) * gravelSpacing * 0.6;
          const oy = (Math.random() - 0.5) * gravelSpacing * 0.6;
          const size = 2 + Math.random() * 3;
          ctx.beginPath();
          ctx.arc(x + ox, y + oy, size, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      break;
      
    case 'grass':
      // Short lines pointing up
      const grassSpacing = spacing * 0.6;
      for (let x = minX; x < maxX; x += grassSpacing) {
        for (let y = minY; y < maxY; y += grassSpacing * 1.5) {
          const ox = (Math.random() - 0.5) * grassSpacing * 0.5;
          const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
          const len = 4 + Math.random() * 4;
          ctx.beginPath();
          ctx.moveTo(x + ox, y);
          ctx.lineTo(x + ox + Math.cos(angle) * len, y + Math.sin(angle) * len);
          ctx.stroke();
        }
      }
      break;
      
    case 'waves':
      // Wavy horizontal lines
      for (let y = minY; y < maxY; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(minX, y);
        for (let x = minX; x < maxX; x += 10) {
          ctx.lineTo(x, y + Math.sin((x - minX) / 15) * 3);
        }
        ctx.stroke();
      }
      break;
      
    case 'earth':
      // Diagonal with dots
      for (let x = minX - (maxY - minY); x < maxX + spacing; x += spacing * 2) {
        ctx.beginPath();
        ctx.moveTo(x, minY);
        ctx.lineTo(x + (maxY - minY), maxY);
        ctx.stroke();
      }
      for (let x = minX; x < maxX; x += spacing) {
        for (let y = minY; y < maxY; y += spacing) {
          if (Math.random() > 0.5) {
            ctx.beginPath();
            ctx.arc(x + Math.random() * 5, y + Math.random() * 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      break;
      
    case 'brick':
      // Brick pattern
      const brickW = spacing * 2;
      const brickH = spacing * 0.8;
      let row = 0;
      for (let y = minY; y < maxY; y += brickH) {
        const offset = (row % 2) * brickW / 2;
        for (let x = minX - brickW + offset; x < maxX; x += brickW) {
          ctx.strokeRect(x, y, brickW, brickH);
        }
        row++;
      }
      break;
      
    case 'tile':
      // Square tiles
      for (let x = minX; x < maxX; x += spacing) {
        for (let y = minY; y < maxY; y += spacing) {
          ctx.strokeRect(x, y, spacing - 2, spacing - 2);
        }
      }
      break;
      
    case 'wood':
      // Wood grain lines
      for (let y = minY; y < maxY; y += spacing * 0.4) {
        ctx.beginPath();
        ctx.moveTo(minX, y);
        for (let x = minX; x < maxX; x += 20) {
          ctx.lineTo(x, y + (Math.random() - 0.5) * 2);
        }
        ctx.stroke();
      }
      break;
      
    case 'insulation':
      // Wavy zigzag
      for (let y = minY; y < maxY; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(minX, y);
        for (let x = minX; x < maxX; x += 8) {
          ctx.lineTo(x, y + ((Math.floor(x / 8) % 2) * 2 - 1) * 4);
        }
        ctx.stroke();
      }
      break;
      
    case 'stone':
      // Irregular polygons
      const stoneSpacing = spacing * 2;
      for (let x = minX; x < maxX; x += stoneSpacing) {
        for (let y = minY; y < maxY; y += stoneSpacing) {
          ctx.beginPath();
          const cx = x + stoneSpacing / 2 + (Math.random() - 0.5) * stoneSpacing * 0.3;
          const cy = y + stoneSpacing / 2 + (Math.random() - 0.5) * stoneSpacing * 0.3;
          const sides = 5 + Math.floor(Math.random() * 3);
          for (let i = 0; i < sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const r = stoneSpacing * 0.3 + Math.random() * stoneSpacing * 0.2;
            const px = cx + Math.cos(angle) * r;
            const py = cy + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.stroke();
        }
      }
      break;
  }
  
  ctx.restore();
  
  // Draw outline
  ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.closePath();
  ctx.stroke();
};

// Parse feet-inches input with fraction support
// Accepts: "14'-6 1/2"", "14-6.5", "14' 6 3/4", "6 1/2"", "1/2"", "14.5", etc.
const parseFeetInches = (input) => {
  if (typeof input === 'number') return input;
  let str = String(input).trim();
  
  // Normalize quote characters (smart quotes to regular)
  str = str.replace(/['']/g, "'").replace(/[""]/g, '"');
  
  // Helper to parse fraction string like "1/2" or "3/4"
  const parseFraction = (fracStr) => {
    if (!fracStr) return 0;
    const fracMatch = fracStr.match(/(\d+)\/(\d+)/);
    if (fracMatch) {
      return parseInt(fracMatch[1], 10) / parseInt(fracMatch[2], 10);
    }
    return 0;
  };
  
  // Pattern: feet-inches fraction (e.g., "14'-6 1/2"", "14-6 1/2", "14' 6 3/4")
  // Requires separator: ' or - or space between feet and inches
  const feetInchesFracMatch = str.match(/^(\d+)[''\s\-]+(\d+)\s+(\d+\/\d+)[""]?$/);
  if (feetInchesFracMatch) {
    const feet = parseInt(feetInchesFracMatch[1], 10);
    const inches = parseInt(feetInchesFracMatch[2], 10);
    const frac = parseFraction(feetInchesFracMatch[3]);
    return feet + (inches + frac) / 12;
  }
  
  // Pattern: feet-inches with decimal (e.g., "14'-6.5"", "14-6.5", "14 6.5")
  // Requires separator: ' or - or space between feet and inches
  const feetInchesDecMatch = str.match(/^(\d+)[''\s\-]+(\d+(?:\.\d+)?)[""]?$/);
  if (feetInchesDecMatch) {
    const feet = parseInt(feetInchesDecMatch[1], 10);
    const inches = parseFloat(feetInchesDecMatch[2]);
    return feet + inches / 12;
  }
  
  // Pattern: just inches with fraction (e.g., "6 1/2"", "6 1/2", "6-1/2")
  const inchesWithFracMatch = str.match(/^(\d+)[\s\-]+(\d+\/\d+)[""]?$/);
  if (inchesWithFracMatch) {
    const inches = parseInt(inchesWithFracMatch[1], 10);
    const frac = parseFraction(inchesWithFracMatch[2]);
    return (inches + frac) / 12;
  }
  
  // Pattern: 0 feet X inches format (e.g., "0'-6"", "0-6", "0 6") - common for small measurements
  const zeroFeetInchesMatch = str.match(/^0[''\s\-]+(\d+(?:\.\d+)?)[""]?$/);
  if (zeroFeetInchesMatch) {
    return parseFloat(zeroFeetInchesMatch[1]) / 12;
  }
  
  // Pattern: just a fraction WITH inch mark (e.g., "1/2"") - interpret as inches
  const justFracInchMatch = str.match(/^(\d+\/\d+)[""]$/);
  if (justFracInchMatch) {
    const frac = parseFraction(justFracInchMatch[1]);
    return frac / 12;
  }
  
  // Pattern: just a fraction WITHOUT inch mark (e.g., "1/2") - interpret as feet
  const justFracFeetMatch = str.match(/^(\d+\/\d+)$/);
  if (justFracFeetMatch) {
    return parseFraction(justFracFeetMatch[1]);
  }
  
  // Pattern: decimal inches only with inch mark (e.g., "6.5"", "6"")
  const decInchesMatch = str.match(/^(\d+(?:\.\d+)?)[""]$/);
  if (decInchesMatch) {
    return parseFloat(decInchesMatch[1]) / 12;
  }
  
  // Pattern: feet with foot mark (e.g., "14'")
  const feetWithMarkMatch = str.match(/^(\d+(?:\.\d+)?)['']$/);
  if (feetWithMarkMatch) {
    return parseFloat(feetWithMarkMatch[1]);
  }
  
  // Pattern: plain number - interpret as feet (e.g., "14", "14.5")
  const plainNumberMatch = str.match(/^(\d+(?:\.\d+)?)$/);
  if (plainNumberMatch) {
    return parseFloat(plainNumberMatch[1]);
  }
  
  // Fallback to parseFloat
  const num = parseFloat(str);
  return isNaN(num) ? 0 : num;
};

// Convert decimal inches to fraction string (to nearest 1/16)
const inchesToFraction = (decimalInches) => {
  const whole = Math.floor(decimalInches);
  const remainder = decimalInches - whole;
  
  if (remainder < 0.03125) return whole === 0 ? '0' : String(whole);
  
  // Common fractions and their decimal equivalents
  const fractions = [
    { dec: 0.0625, str: '1/16' },
    { dec: 0.125, str: '1/8' },
    { dec: 0.1875, str: '3/16' },
    { dec: 0.25, str: '1/4' },
    { dec: 0.3125, str: '5/16' },
    { dec: 0.375, str: '3/8' },
    { dec: 0.4375, str: '7/16' },
    { dec: 0.5, str: '1/2' },
    { dec: 0.5625, str: '9/16' },
    { dec: 0.625, str: '5/8' },
    { dec: 0.6875, str: '11/16' },
    { dec: 0.75, str: '3/4' },
    { dec: 0.8125, str: '13/16' },
    { dec: 0.875, str: '7/8' },
    { dec: 0.9375, str: '15/16' },
  ];
  
  // Find closest fraction
  let closest = fractions[0];
  let minDiff = Math.abs(remainder - fractions[0].dec);
  
  for (const frac of fractions) {
    const diff = Math.abs(remainder - frac.dec);
    if (diff < minDiff) {
      minDiff = diff;
      closest = frac;
    }
  }
  
  // If very close to 1, round up
  if (remainder > 0.96875) {
    return String(whole + 1);
  }
  
  if (whole === 0) {
    return closest.str;
  }
  return `${whole} ${closest.str}`;
};

// Format decimal feet to feet-inches string with fractions
const formatToFeetInches = (value) => {
  const feet = Math.floor(value);
  const totalInches = (value - feet) * 12;
  const inchStr = inchesToFraction(totalInches);
  
  if (inchStr === '0') {
    return `${feet}'`;
  }
  return `${feet}'-${inchStr}"`;
};

// Measurement input component (defined outside to avoid hook issues)
const MeasurementInput = React.memo(({ label, value, onChange, units, formatMeasurement }) => {
  const [inputValue, setInputValue] = React.useState('');
  const [isFocused, setIsFocused] = React.useState(false);
  const inputRef = React.useRef(null);
  
  // Update display value when value or units change (only when not focused)
  React.useEffect(() => {
    if (!isFocused) {
      if (units === 'feetInches') {
        setInputValue(formatToFeetInches(value));
      } else {
        setInputValue(String(value));
      }
    }
  }, [value, units, isFocused]);
  
  const handleChange = (e) => {
    setInputValue(e.target.value);
  };
  
  const handleBlur = () => {
    setIsFocused(false);
    const parsed = parseFeetInches(inputValue);
    onChange(parsed);
  };
  
  const handleFocus = (e) => {
    e.stopPropagation();
    setIsFocused(true);
  };
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.target.blur();
    }
  };
  
  const handleContainerTouch = (e) => {
    e.stopPropagation();
  };
  
  return (
    <div 
      style={{ marginBottom: '10px' }}
      onTouchStart={handleContainerTouch}
      onTouchMove={handleContainerTouch}
      onTouchEnd={handleContainerTouch}
      onMouseDown={(e) => e.stopPropagation()}
      onPointerDown={(e) => e.stopPropagation()}
      onClick={(e) => e.stopPropagation()}
    >
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '4px' }}>
        <label style={{ color: '#6080a0', fontSize: '10px' }}>{label}</label>
        <span style={{ color: '#00c8ff', fontSize: '11px', fontWeight: '500' }}>
          {formatMeasurement(value)}
        </span>
      </div>
      <input
        ref={inputRef}
        type="text"
        inputMode={units === 'feetInches' ? 'text' : 'decimal'}
        value={inputValue}
        onChange={handleChange}
        onBlur={handleBlur}
        onFocus={handleFocus}
        onKeyDown={handleKeyDown}
        onTouchStart={(e) => e.stopPropagation()}
        onTouchMove={(e) => e.stopPropagation()}
        onTouchEnd={(e) => e.stopPropagation()}
        onMouseDown={(e) => e.stopPropagation()}
        onPointerDown={(e) => e.stopPropagation()}
        onClick={(e) => { e.stopPropagation(); e.target.focus(); }}
        placeholder={units === 'feetInches' ? "e.g., 14'-6 1/2\"" : "feet"}
        autoComplete="off"
        autoCorrect="off"
        autoCapitalize="off"
        spellCheck="false"
        style={{
          width: '100%',
          padding: '10px 12px',
          background: 'rgba(255,255,255,0.1)',
          border: '2px solid rgba(0,200,255,0.3)',
          borderRadius: '6px',
          color: '#fff',
          fontSize: '16px', // Prevents zoom on iOS
          boxSizing: 'border-box',
          touchAction: 'manipulation',
          WebkitAppearance: 'none',
        }}
      />
      {units === 'feetInches' && (
        <div style={{ color: '#6080a0', fontSize: '8px', marginTop: '2px' }}>
          Formats: 14'-6 1/2" or 14-6.5 or 14.54
        </div>
      )}
    </div>
  );
});

// ============================================================================
// MAIN COMPONENT
// ============================================================================
function FloorPlanPro() {
  // Refs
  const canvasRef = useRef(null);
  const canvas3DRef = useRef(null);
  const containerRef = useRef(null);
  const paperCanvasRef = useRef(null);
  const elevationCanvasRef = useRef(null);
  
  // Paper space zoom
  const [paperZoom, setPaperZoom] = useState(0.4);
  const [paperPan, setPaperPan] = useState({ x: 0, y: 0 });
  const [isPaperPanning, setIsPaperPanning] = useState(false);
  const [paperPanStart, setPaperPanStart] = useState(null);

  // Elevation view zoom and pan
  const [elevationZoom, setElevationZoom] = useState(0.5);
  const [elevationPan, setElevationPan] = useState({ x: 0, y: 0 });
  const [isElevationPanning, setIsElevationPanning] = useState(false);
  const [elevationPanStart, setElevationPanStart] = useState(null);
  
  // Core state
  const [tool, setTool] = useState('wall');
  const [toolTab, setToolTab] = useState('draw'); // 'draw', 'modify', 'annotate', 'view'
  const [wallType, setWallType] = useState('exterior');
  const [floors, setFloors] = useState([{
    id: 'floor-1',
    name: 'Floor 1',
    walls: [],
    doors: [],
    windows: [],
    furniture: [],
    rooms: [],
    stairs: [],
    electrical: [],
    plumbing: [],
    plumbingLines: [],
    dimensions: [],
    texts: [],
    lines: [],
    polylines: [],
    hatches: [],
    porches: [],
    roofs: [],
  }]);
  const [activeFloorId, setActiveFloorId] = useState('floor-1');
  const [selectedItems, setSelectedItems] = useState([]);
  const [clipboard, setClipboard] = useState(null); // For copy/paste
  const [wallDragStart, setWallDragStart] = useState(null); // For moving walls
  const [wallDragSnap, setWallDragSnap] = useState(null); // For angle lock visual feedback
  const [wallDrawSnap, setWallDrawSnap] = useState(null); // For wall drawing endpoint snap feedback
  
  // Line/polyline drawing state
  const [lineType, setLineType] = useState('solid'); // solid, dashed, dotted, centerline
  const [lineWeight, setLineWeight] = useState(1);
  const [polylinePoints, setPolylinePoints] = useState([]);
  const [isDrawingPolyline, setIsDrawingPolyline] = useState(false);
  const [lineStart, setLineStart] = useState(null);
  const lineStartRef = useRef(null);
  
  // Keep ref in sync with state
  useEffect(() => {
    lineStartRef.current = lineStart;
  }, [lineStart]);
  
  // Hatch state
  const [hatchPattern, setHatchPattern] = useState('concrete');
  const [hatchScale, setHatchScale] = useState(1);
  
  // Porch state
  const [porchType, setPorchType] = useState('open'); // open, screened, covered
  
  // Layers system
  const [layers, setLayers] = useState({
    walls: { visible: true, locked: false, name: 'Walls', color: '#ffffff' },
    doors: { visible: true, locked: false, name: 'Doors', color: '#00c8ff' },
    windows: { visible: true, locked: false, name: 'Windows', color: '#00ffaa' },
    furniture: { visible: true, locked: false, name: 'Furniture', color: '#ffaa00' },
    electrical: { visible: true, locked: false, name: 'Electrical', color: '#ffff00' },
    plumbing: { visible: true, locked: false, name: 'Plumbing', color: '#00aaff' },
    dimensions: { visible: true, locked: false, name: 'Dimensions', color: '#888888' },
    rooms: { visible: true, locked: false, name: 'Rooms', color: '#446688' },
    text: { visible: true, locked: false, name: 'Text', color: '#ffffff' },
    lines: { visible: true, locked: false, name: 'Lines', color: '#aaaaaa' },
    hatches: { visible: true, locked: false, name: 'Hatches', color: '#668844' },
    porches: { visible: true, locked: false, name: 'Porches', color: '#886644' },
    roofs: { visible: true, locked: false, name: 'Roofs', color: '#8b5a2b' },
  });
  const [showLayersPanel, setShowLayersPanel] = useState(false);
  
  // Grips for wall editing
  const [activeGrip, setActiveGrip] = useState(null); // { wallId, endpoint: 'start' | 'end' }
  const [showGrips, setShowGrips] = useState(true);
  const [gripSnapTarget, setGripSnapTarget] = useState(null); // Current snap target for visualization
  const [allSnapPoints, setAllSnapPoints] = useState([]); // All potential snap points while dragging grip
  
  // Angle snapping
  const [angleSnap, setAngleSnap] = useState('45'); // '90', '45', '15', 'off'
  
  // Sheet views for printing
  const [sheets, setSheets] = useState([]);
  const [activeSheetId, setActiveSheetId] = useState(null);
  const [showSheetsPanel, setShowSheetsPanel] = useState(false);
  const [viewMode, setViewMode] = useState('model'); // 'model', 'paper', or 'elevations'
  const [activeElevation, setActiveElevation] = useState('north'); // 'north', 'south', 'east', 'west'
  
  // Title block templates
  const TITLE_BLOCK_TEMPLATES = {
    standard: {
      name: 'Standard',
      fields: ['projectName', 'clientName', 'address', 'drawnBy', 'date', 'scale', 'sheetNumber', 'sheetTitle'],
    },
    minimal: {
      name: 'Minimal', 
      fields: ['projectName', 'date', 'scale', 'sheetNumber'],
    },
    detailed: {
      name: 'Detailed',
      fields: ['projectName', 'clientName', 'address', 'drawnBy', 'checkedBy', 'date', 'revisionDate', 'scale', 'sheetNumber', 'sheetTitle', 'notes'],
    },
  };
  
  // Project info for title blocks
  const [projectInfo, setProjectInfo] = useState({
    projectName: 'New Project',
    clientName: '',
    address: '',
    drawnBy: '',
    checkedBy: '',
    date: new Date().toLocaleDateString(),
    revisionDate: '',
    notes: '',
  });
  
  // UI state
  const [activePanel, setActivePanel] = useState(null); // 'furniture', 'stairs', 'electrical', 'plumbing'
  const [showRoomPanel, setShowRoomPanel] = useState(false);
  const [showRoofPanel, setShowRoofPanel] = useState(false);
  const [show3D, setShow3D] = useState(false);

  // Roof tool state
  const [roofType, setRoofType] = useState('gable');
  const [roofPitch, setRoofPitch] = useState('6:12');
  const [roofStart, setRoofStart] = useState(null);
  const [roofOverhang, setRoofOverhang] = useState(12); // inches
  const [furnitureCategory, setFurnitureCategory] = useState('all');
  const [showWallEditor, setShowWallEditor] = useState(false);
  const [showDoorWindowEditor, setShowDoorWindowEditor] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showNewFileConfirm, setShowNewFileConfirm] = useState(false);
  const [editorsMinimized, setEditorsMinimized] = useState(false); // When true, editors stay hidden during selection/drag
  
  // Mobile detection
  const [isMobile, setIsMobile] = useState(false);
  const [isTablet, setIsTablet] = useState(false);
  const [showMobileMenu, setShowMobileMenu] = useState(false);
  
  useEffect(() => {
    const checkDevice = () => {
      const width = window.innerWidth;
      setIsMobile(width < 768);
      setIsTablet(width >= 768 && width < 1024);
    };
    checkDevice();
    window.addEventListener('resize', checkDevice);
    return () => window.removeEventListener('resize', checkDevice);
  }, []);
  
  // Reset minimized state when selection is cleared
  useEffect(() => {
    if (selectedItems.length === 0) {
      setEditorsMinimized(false);
    }
  }, [selectedItems]);
  
  // Units setting: 'decimal' (3.5') or 'feetInches' (3'-6")
  const [units, setUnits] = useState('decimal');
  
  // Grid size setting: '6"', '3"', '1"', 'off'
  const [gridSize, setGridSize] = useState('6"');
  
  // Wall detail level: 'simple', 'standard', 'detailed'
  const [wallDetailLevel, setWallDetailLevel] = useState('simple');

  // Render mode: 'linework' (clean CAD style), 'realistic' (with textures/colors)
  const [renderMode, setRenderMode] = useState('linework');
  
  // Get current grid size in pixels
  const currentGridSize = GRID_OPTIONS[gridSize]?.size || GRID_SIZE;
  
  // Snap function using current grid setting
  const snap = useCallback((value) => {
    if (gridSize === 'off') return value;
    return snapToGridSize(value, currentGridSize);
  }, [gridSize, currentGridSize]);
  
  // Angle snap function for wall drawing
  const snapAngle = useCallback((start, end) => {
    if (angleSnap === 'off') return end;
    
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    if (length < 5) return end;
    
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    const snapDegrees = parseInt(angleSnap) || 45;
    const snappedAngle = Math.round(angle / snapDegrees) * snapDegrees;
    const snappedRad = snappedAngle * Math.PI / 180;
    
    return {
      x: start.x + Math.cos(snappedRad) * length,
      y: start.y + Math.sin(snappedRad) * length,
    };
  }, [angleSnap]);
  
  // Toggle layer visibility
  const toggleLayerVisibility = (layerName) => {
    setLayers(prev => ({
      ...prev,
      [layerName]: { ...prev[layerName], visible: !prev[layerName].visible }
    }));
  };
  
  // Toggle layer lock
  const toggleLayerLock = (layerName) => {
    setLayers(prev => ({
      ...prev,
      [layerName]: { ...prev[layerName], locked: !prev[layerName].locked }
    }));
  };
  
  // Sheet management
  const createSheet = () => {
    const sheetNum = sheets.length + 1;
    const newSheet = {
      id: generateId(),
      name: `Sheet ${sheetNum}`,
      sheetNumber: `A${sheetNum.toString().padStart(2, '0')}`,
      sheetTitle: 'Floor Plan',
      size: 'arch-d', // letter, legal, tabloid, arch-d
      orientation: 'landscape',
      scale: '1/4" = 1\'',
      viewport: { x: 0, y: 0, zoom: 0.5 },
      titleBlockTemplate: 'standard',
      showTitleBlock: true,
      floorId: activeFloorId, // Which floor this sheet shows
    };
    setSheets([...sheets, newSheet]);
    setActiveSheetId(newSheet.id);
  };
  
  // Paper sizes in pixels (at 96 DPI)
  const PAPER_SIZES = {
    'letter': { width: 1056, height: 816, name: '8.5" √ó 11"' },
    'legal': { width: 1344, height: 816, name: '8.5" √ó 14"' },
    'tabloid': { width: 1632, height: 1056, name: '11" √ó 17"' },
    'arch-d': { width: 3456, height: 2304, name: '24" √ó 36"' },
  };
  
  // Get active sheet
  const activeSheet = useMemo(() => {
    return sheets.find(s => s.id === activeSheetId) || null;
  }, [sheets, activeSheetId]);
  
  // 3D view controls
  const [view3DRotation, setView3DRotation] = useState({ x: 30, y: 45 });
  const [view3DZoom, setView3DZoom] = useState(1);
  const [view3DPan, setView3DPan] = useState({ x: 0, y: 0 });
  const [is3DDragging, setIs3DDragging] = useState(false);
  const [dragStart3D, setDragStart3D] = useState({ x: 0, y: 0 });
  
  // Format measurement based on units setting
  const formatMeasurement = useCallback((feet) => {
    const ftNum = parseFloat(feet);
    if (isNaN(ftNum)) return '0\'';
    
    if (units === 'feetInches') {
      const wholeFeet = Math.floor(ftNum);
      const totalInches = (ftNum - wholeFeet) * 12;
      const inchStr = inchesToFraction(totalInches);
      
      if (inchStr === '0') {
        return `${wholeFeet}'-0"`;
      }
      return `${wholeFeet}'-${inchStr}"`;
    }
    return `${ftNum}'`;
  }, [units]);
  
  // Door/Window types
  const [selectedDoorType, setSelectedDoorType] = useState('single');
  const [selectedWindowType, setSelectedWindowType] = useState('double-hung');
  
  // Text annotation state
  const [selectedTextStyle, setSelectedTextStyle] = useState('label');
  const [showTextEditor, setShowTextEditor] = useState(false);
  const [editingTextId, setEditingTextId] = useState(null);
  
  // Text tool
  const [textInput, setTextInput] = useState('');
  const [showTextInput, setShowTextInput] = useState(false);
  const [pendingTextPos, setPendingTextPos] = useState(null);
  
  // Drawing state
  const [isDrawing, setIsDrawing] = useState(false);
  const [drawStart, setDrawStart] = useState(null);
  const [drawEnd, setDrawEnd] = useState(null);
  const [measureStart, setMeasureStart] = useState(null);
  const [measureEnd, setMeasureEnd] = useState(null);
  
  // Plumbing line drawing
  const [plumbingLineType, setPlumbingLineType] = useState(null);
  const [plumbingLineStart, setPlumbingLineStart] = useState(null);
  
  // Dimension drawing - use ref to avoid stale closure issues
  const [dimensionStart, setDimensionStart] = useState(null);
  const dimensionStartRef = useRef(null);
  const [dimensionStyle, setDimensionStyle] = useState('standard');
  const [showDimensions, setShowDimensions] = useState(true);
  const [autoDimensions, setAutoDimensions] = useState(true);
  
  // Keep ref in sync with state
  useEffect(() => {
    dimensionStartRef.current = dimensionStart;
  }, [dimensionStart]);
  
  // Drag state
  const [dragItem, setDragItem] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  
  // Move command state (base point -> destination point)
  const [moveBasePoint, setMoveBasePoint] = useState(null);
  const [movePreviewPoint, setMovePreviewPoint] = useState(null);
  
  // Rotate command state (center point -> reference angle -> new angle)
  const [rotateCenter, setRotateCenter] = useState(null);
  const [rotateStartAngle, setRotateStartAngle] = useState(null);
  const [rotatePreviewAngle, setRotatePreviewAngle] = useState(null);
  
  // History for undo/redo
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  
  // Pan & Zoom
  const [offset, setOffset] = useState({ x: 200, y: 200 });
  const [scale, setScale] = useState(1);
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState(null);
  const [pinchStart, setPinchStart] = useState(null); // For pinch-to-zoom
  
  // Dimensions
  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });
  
  // Get active floor
  const activeFloor = useMemo(() => {
    if (floors.length === 0) {
      return {
        id: 'default',
        name: 'Floor 1',
        walls: [],
        doors: [],
        windows: [],
        furniture: [],
        stairs: [],
        electrical: [],
        plumbing: [],
        dimensions: [],
        text: [],
        rooms: [],
        porches: [],
        lines: []
      };
    }
    return floors.find(f => f.id === activeFloorId) || floors[0];
  }, [floors, activeFloorId]);
  
  // ============================================================================
  // HISTORY MANAGEMENT
  // ============================================================================
  const saveToHistory = useCallback((newFloors) => {
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(JSON.stringify(newFloors));
    if (newHistory.length > 50) newHistory.shift();
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  }, [history, historyIndex]);
  
  const undo = useCallback(() => {
    if (historyIndex > 0) {
      setHistoryIndex(historyIndex - 1);
      setFloors(JSON.parse(history[historyIndex - 1]));
    }
  }, [history, historyIndex]);
  
  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      setHistoryIndex(historyIndex + 1);
      setFloors(JSON.parse(history[historyIndex + 1]));
    }
  }, [history, historyIndex]);
  
  // ============================================================================
  // FLOOR MANAGEMENT
  // ============================================================================
  const updateActiveFloor = useCallback((updater) => {
    const newFloors = floors.map(f => 
      f.id === activeFloorId ? updater(f) : f
    );
    setFloors(newFloors);
    saveToHistory(newFloors);
  }, [floors, activeFloorId, saveToHistory]);
  
  const addFloor = () => {
    const newFloor = {
      id: generateId(),
      name: `Floor ${floors.length + 1}`,
      walls: [],
      doors: [],
      windows: [],
      furniture: [],
      rooms: [],
      stairs: [],
      electrical: [],
      plumbing: [],
      plumbingLines: [],
    };
    const newFloors = [...floors, newFloor];
    setFloors(newFloors);
    setActiveFloorId(newFloor.id);
    saveToHistory(newFloors);
  };
  
  const duplicateFloor = () => {
    const newFloor = {
      ...JSON.parse(JSON.stringify(activeFloor)),
      id: generateId(),
      name: `${activeFloor.name} (Copy)`,
    };
    newFloor.walls = newFloor.walls.map(w => ({ ...w, id: generateId() }));
    newFloor.doors = newFloor.doors.map(d => ({ ...d, id: generateId() }));
    newFloor.windows = newFloor.windows.map(w => ({ ...w, id: generateId() }));
    newFloor.furniture = newFloor.furniture.map(f => ({ ...f, id: generateId() }));
    newFloor.rooms = newFloor.rooms.map(r => ({ ...r, id: generateId() }));
    newFloor.stairs = (newFloor.stairs || []).map(s => ({ ...s, id: generateId() }));
    newFloor.electrical = (newFloor.electrical || []).map(e => ({ ...e, id: generateId() }));
    newFloor.plumbing = (newFloor.plumbing || []).map(p => ({ ...p, id: generateId() }));
    newFloor.plumbingLines = (newFloor.plumbingLines || []).map(l => ({ ...l, id: generateId() }));
    newFloor.dimensions = (newFloor.dimensions || []).map(d => ({ ...d, id: generateId() }));
    
    const newFloors = [...floors, newFloor];
    setFloors(newFloors);
    setActiveFloorId(newFloor.id);
    saveToHistory(newFloors);
  };
  
  const deleteFloor = () => {
    if (floors.length <= 1) return;
    const newFloors = floors.filter(f => f.id !== activeFloorId);
    setFloors(newFloors);
    setActiveFloorId(newFloors[0].id);
    saveToHistory(newFloors);
  };
  
  // ============================================================================
  // RESIZE HANDLER
  // ============================================================================
  useEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setDimensions({ width: rect.width, height: rect.height });
      }
    };
    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);
  
  // ============================================================================
  // KEYBOARD SHORTCUTS
  // ============================================================================
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.target.tagName === 'INPUT') return;
      
      if (e.metaKey || e.ctrlKey) {
        if (e.key === 'z') {
          e.preventDefault();
          if (e.shiftKey) redo();
          else undo();
        } else if (e.key === 's') {
          e.preventDefault();
          saveProject();
        } else if (e.key === 'c') {
          e.preventDefault();
          copySelected();
        } else if (e.key === 'v') {
          e.preventDefault();
          pasteClipboard();
        }
      } else if (e.key === 'Delete' || e.key === 'Backspace') {
        deleteSelected();
      } else if (e.key === 'Escape') {
        setSelectedItems([]);
        setIsDrawing(false);
        setMeasureStart(null);
        setMeasureEnd(null);
        setPlumbingLineStart(null);
        setPlumbingLineType(null);
        setDimensionStart(null);
        setLineStart(null);
        lineStartRef.current = null;
        setPolylinePoints([]);
        setIsDrawingPolyline(false);
        setShowWallEditor(false);
        // Reset move/rotate
        setMoveBasePoint(null);
        setMovePreviewPoint(null);
        setRotateCenter(null);
        setRotateStartAngle(null);
        setRotatePreviewAngle(null);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo, copySelected, pasteClipboard, deleteSelected]);
  
  // ============================================================================
  // POINTER HELPERS
  // ============================================================================
  const getPointerPos = useCallback((e) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };

    const rect = canvas.getBoundingClientRect();
    const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    
    return {
      x: (clientX - rect.left - offset.x) / scale,
      y: (clientY - rect.top - offset.y) / scale
    };
  }, [offset, scale]);
  
  // ============================================================================
  // FIND FUNCTIONS
  // ============================================================================
  const findNearestWall = useCallback((point, maxDist = 30) => {
    let nearest = null;
    let minDist = Infinity;
    
    activeFloor.walls.forEach(wall => {
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      if (length < 0.001) return;
      
      let t = ((point.x - wall.start.x) * dx + (point.y - wall.start.y) * dy) / (length * length);
      t = Math.max(0.1, Math.min(0.9, t));
      
      const closest = { x: wall.start.x + t * dx, y: wall.start.y + t * dy };
      const dist = distance(point, closest);
      
      if (dist < minDist && dist < maxDist) {
        minDist = dist;
        nearest = { wall, position: t };
      }
    });
    
    return nearest;
  }, [activeFloor.walls]);
  
  // Find doors, windows, or wall endpoints near a point for dimension linking
  const findNearestLinkTarget = useCallback((point, maxDist = 20) => {
    // Check doors
    for (const door of activeFloor.doors) {
      const wall = activeFloor.walls.find(w => w.id === door.wallId);
      if (!wall) continue;
      
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const doorCenter = {
        x: wall.start.x + dx * door.position,
        y: wall.start.y + dy * door.position
      };
      
      // Check door center and edges
      const doorWidth = door.width || 36;
      const length = Math.sqrt(dx * dx + dy * dy);
      const unitX = dx / length;
      const unitY = dy / length;
      
      const doorLeft = { x: doorCenter.x - unitX * doorWidth / 2, y: doorCenter.y - unitY * doorWidth / 2 };
      const doorRight = { x: doorCenter.x + unitX * doorWidth / 2, y: doorCenter.y + unitY * doorWidth / 2 };
      
      if (distance(point, doorCenter) < maxDist) {
        return { type: 'door', id: door.id, edge: 'center' };
      }
      if (distance(point, doorLeft) < maxDist) {
        return { type: 'door', id: door.id, edge: 'left' };
      }
      if (distance(point, doorRight) < maxDist) {
        return { type: 'door', id: door.id, edge: 'right' };
      }
    }
    
    // Check windows
    for (const win of activeFloor.windows) {
      const wall = activeFloor.walls.find(w => w.id === win.wallId);
      if (!wall) continue;
      
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const winCenter = {
        x: wall.start.x + dx * win.position,
        y: wall.start.y + dy * win.position
      };
      
      const winWidth = win.width || 48;
      const length = Math.sqrt(dx * dx + dy * dy);
      const unitX = dx / length;
      const unitY = dy / length;
      
      const winLeft = { x: winCenter.x - unitX * winWidth / 2, y: winCenter.y - unitY * winWidth / 2 };
      const winRight = { x: winCenter.x + unitX * winWidth / 2, y: winCenter.y + unitY * winWidth / 2 };
      
      if (distance(point, winCenter) < maxDist) {
        return { type: 'window', id: win.id, edge: 'center' };
      }
      if (distance(point, winLeft) < maxDist) {
        return { type: 'window', id: win.id, edge: 'left' };
      }
      if (distance(point, winRight) < maxDist) {
        return { type: 'window', id: win.id, edge: 'right' };
      }
    }
    
    // Check wall endpoints
    for (const wall of activeFloor.walls) {
      if (distance(point, wall.start) < maxDist) {
        return { type: 'wall', id: wall.id, edge: 'start' };
      }
      if (distance(point, wall.end) < maxDist) {
        return { type: 'wall', id: wall.id, edge: 'end' };
      }
    }
    
    return null;
  }, [activeFloor.doors, activeFloor.windows, activeFloor.walls]);
  
  // Find nearest snap point for move/rotate commands
  const findNearestSnapPoint = useCallback((point, maxDist = 20) => {
    let nearest = null;
    let minDist = maxDist;
    
    // Check wall endpoints and midpoints
    for (const wall of activeFloor.walls) {
      // Start point
      const dStart = distance(point, wall.start);
      if (dStart < minDist) {
        minDist = dStart;
        nearest = { ...wall.start, type: 'endpoint', wallId: wall.id };
      }
      
      // End point
      const dEnd = distance(point, wall.end);
      if (dEnd < minDist) {
        minDist = dEnd;
        nearest = { ...wall.end, type: 'endpoint', wallId: wall.id };
      }
      
      // Midpoint
      const mid = {
        x: (wall.start.x + wall.end.x) / 2,
        y: (wall.start.y + wall.end.y) / 2
      };
      const dMid = distance(point, mid);
      if (dMid < minDist) {
        minDist = dMid;
        nearest = { ...mid, type: 'midpoint', wallId: wall.id };
      }
    }
    
    // Check furniture centers
    for (const furn of activeFloor.furniture) {
      const center = { x: furn.x + (furn.width || 40) / 2, y: furn.y + (furn.height || 40) / 2 };
      const d = distance(point, center);
      if (d < minDist) {
        minDist = d;
        nearest = { ...center, type: 'center', itemId: furn.id };
      }
    }
    
    // Check room corners
    for (const room of activeFloor.rooms) {
      const corners = [
        { x: room.x, y: room.y },
        { x: room.x + room.width, y: room.y },
        { x: room.x, y: room.y + room.height },
        { x: room.x + room.width, y: room.y + room.height },
      ];
      for (const corner of corners) {
        const d = distance(point, corner);
        if (d < minDist) {
          minDist = d;
          nearest = { ...corner, type: 'corner', roomId: room.id };
        }
      }
    }
    
    return nearest;
  }, [activeFloor.walls, activeFloor.furniture, activeFloor.rooms]);
  
  // Resolve a linked dimension point to actual coordinates
  const resolveLinkPoint = useCallback((link, fallback) => {
    if (!link) return fallback;
    
    if (link.type === 'door') {
      const door = activeFloor.doors.find(d => d.id === link.id);
      if (!door) return fallback;
      
      const wall = activeFloor.walls.find(w => w.id === door.wallId);
      if (!wall) return fallback;
      
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const doorCenter = {
        x: wall.start.x + dx * door.position,
        y: wall.start.y + dy * door.position
      };
      
      if (link.edge === 'center') return doorCenter;
      
      const doorWidth = door.width || 36;
      const unitX = dx / length;
      const unitY = dy / length;
      
      if (link.edge === 'left') {
        return { x: doorCenter.x - unitX * doorWidth / 2, y: doorCenter.y - unitY * doorWidth / 2 };
      }
      if (link.edge === 'right') {
        return { x: doorCenter.x + unitX * doorWidth / 2, y: doorCenter.y + unitY * doorWidth / 2 };
      }
    }
    
    if (link.type === 'window') {
      const win = activeFloor.windows.find(w => w.id === link.id);
      if (!win) return fallback;
      
      const wall = activeFloor.walls.find(w => w.id === win.wallId);
      if (!wall) return fallback;
      
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const winCenter = {
        x: wall.start.x + dx * win.position,
        y: wall.start.y + dy * win.position
      };
      
      if (link.edge === 'center') return winCenter;
      
      const winWidth = win.width || 48;
      const unitX = dx / length;
      const unitY = dy / length;
      
      if (link.edge === 'left') {
        return { x: winCenter.x - unitX * winWidth / 2, y: winCenter.y - unitY * winWidth / 2 };
      }
      if (link.edge === 'right') {
        return { x: winCenter.x + unitX * winWidth / 2, y: winCenter.y + unitY * winWidth / 2 };
      }
    }
    
    if (link.type === 'wall') {
      const wall = activeFloor.walls.find(w => w.id === link.id);
      if (!wall) return fallback;
      
      return link.edge === 'start' ? wall.start : wall.end;
    }
    
    return fallback;
  }, [activeFloor.doors, activeFloor.windows, activeFloor.walls]);
  
  const findItemAt = useCallback((point) => {
    // Check texts first (on top)
    for (const text of (activeFloor.texts || [])) {
      // Approximate text bounding box
      const textWidth = (text.content?.length || 5) * (text.fontSize || 14) * 0.6;
      const textHeight = (text.fontSize || 14) * 1.2;
      if (point.x >= text.x - 5 && point.x <= text.x + textWidth + 5 &&
          point.y >= text.y - textHeight && point.y <= text.y + 5) {
        return { type: 'text', item: text };
      }
    }
    
    // Check dimensions - check along entire line with larger hit area
    for (const dim of (activeFloor.dimensions || [])) {
      const offset = dim.offset || 0;
      const dx = dim.end.x - dim.start.x;
      const dy = dim.end.y - dim.start.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      if (length < 0.001) continue;
      
      // Calculate perpendicular offset
      const perpX = -dy / length * offset;
      const perpY = dx / length * offset;
      const startOffset = { x: dim.start.x + perpX, y: dim.start.y + perpY };
      const endOffset = { x: dim.end.x + perpX, y: dim.end.y + perpY };
      
      // Check if point is near the dimension line
      const t = ((point.x - startOffset.x) * dx + (point.y - startOffset.y) * dy) / (length * length);
      if (t >= -0.1 && t <= 1.1) {
        const closest = { 
          x: startOffset.x + Math.max(0, Math.min(1, t)) * dx, 
          y: startOffset.y + Math.max(0, Math.min(1, t)) * dy 
        };
        if (distance(point, closest) < 15) {
          return { type: 'dimension', item: dim };
        }
      }
      
      // Also check endpoints and midpoint with larger radius
      const midX = (startOffset.x + endOffset.x) / 2;
      const midY = (startOffset.y + endOffset.y) / 2;
      if (distance(point, { x: midX, y: midY }) < 25 ||
          distance(point, startOffset) < 15 ||
          distance(point, endOffset) < 15) {
        return { type: 'dimension', item: dim };
      }
    }
    
    // Check doors
    for (const door of activeFloor.doors) {
      const wall = activeFloor.walls.find(w => w.id === door.wallId);
      if (!wall) continue;
      
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const doorPos = {
        x: wall.start.x + dx * door.position,
        y: wall.start.y + dy * door.position
      };
      
      if (distance(point, doorPos) < (door.width || 36) / 2 + 10) {
        return { type: 'door', item: door, wall };
      }
    }
    
    // Check windows
    for (const win of activeFloor.windows) {
      const wall = activeFloor.walls.find(w => w.id === win.wallId);
      if (!wall) continue;
      
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const winPos = {
        x: wall.start.x + dx * win.position,
        y: wall.start.y + dy * win.position
      };
      
      if (distance(point, winPos) < (win.width || 48) / 2 + 10) {
        return { type: 'window', item: win, wall };
      }
    }
    
    // Check electrical
    for (const elec of (activeFloor.electrical || [])) {
      if (distance(point, { x: elec.x, y: elec.y }) < 15) {
        return { type: 'electrical', item: elec };
      }
    }
    
    // Check plumbing
    for (const plumb of (activeFloor.plumbing || [])) {
      if (distance(point, { x: plumb.x, y: plumb.y }) < 15) {
        return { type: 'plumbing', item: plumb };
      }
    }
    
    // Check stairs
    for (const stair of (activeFloor.stairs || [])) {
      const hw = stair.width / 2;
      const hh = stair.height / 2;
      if (point.x >= stair.x - hw && point.x <= stair.x + hw &&
          point.y >= stair.y - hh && point.y <= stair.y + hh) {
        return { type: 'stairs', item: stair };
      }
    }
    
    // Check furniture
    for (const furn of activeFloor.furniture) {
      const hw = furn.width / 2;
      const hh = furn.height / 2;
      if (point.x >= furn.x - hw && point.x <= furn.x + hw &&
          point.y >= furn.y - hh && point.y <= furn.y + hh) {
        return { type: 'furniture', item: furn };
      }
    }
    
    // Check rooms
    for (const room of activeFloor.rooms) {
      if (point.x >= room.x && point.x <= room.x + room.width &&
          point.y >= room.y && point.y <= room.y + room.height) {
        return { type: 'room', item: room };
      }
    }
    
    // Check porches
    for (const porch of (activeFloor.porches || [])) {
      if (point.x >= porch.x && point.x <= porch.x + porch.width &&
          point.y >= porch.y && point.y <= porch.y + porch.height) {
        return { type: 'porch', item: porch };
      }
    }

    // Check roofs
    for (const roof of (activeFloor.roofs || [])) {
      const overhang = (roof.overhang || 12) * (GRID_SIZE / 6) / 12;
      if (point.x >= roof.x - overhang && point.x <= roof.x + roof.width + overhang &&
          point.y >= roof.y - overhang && point.y <= roof.y + roof.height + overhang) {
        return { type: 'roof', item: roof };
      }
    }

    // Check lines
    for (const line of (activeFloor.lines || [])) {
      const dx = line.end.x - line.start.x;
      const dy = line.end.y - line.start.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      if (length < 0.001) continue;
      
      const t = ((point.x - line.start.x) * dx + (point.y - line.start.y) * dy) / (length * length);
      if (t >= -0.1 && t <= 1.1) {
        const closest = { 
          x: line.start.x + Math.max(0, Math.min(1, t)) * dx, 
          y: line.start.y + Math.max(0, Math.min(1, t)) * dy 
        };
        if (distance(point, closest) < 10) {
          return { type: 'line', item: line };
        }
      }
    }
    
    // Check polylines
    for (const poly of (activeFloor.polylines || [])) {
      if (poly.points.length < 2) continue;
      for (let i = 0; i < poly.points.length - 1; i++) {
        const p1 = poly.points[i];
        const p2 = poly.points[i + 1];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        if (length < 0.001) continue;
        
        const t = ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / (length * length);
        if (t >= 0 && t <= 1) {
          const closest = { x: p1.x + t * dx, y: p1.y + t * dy };
          if (distance(point, closest) < 10) {
            return { type: 'polyline', item: poly };
          }
        }
      }
    }
    
    // Check hatches (point in polygon)
    for (const hatch of (activeFloor.hatches || [])) {
      if (hatch.points.length < 3) continue;
      // Simple bounding box check first
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      hatch.points.forEach(p => {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      });
      if (point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY) {
        // Ray casting algorithm for point in polygon
        let inside = false;
        for (let i = 0, j = hatch.points.length - 1; i < hatch.points.length; j = i++) {
          const xi = hatch.points[i].x, yi = hatch.points[i].y;
          const xj = hatch.points[j].x, yj = hatch.points[j].y;
          if (((yi > point.y) !== (yj > point.y)) &&
              (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
            inside = !inside;
          }
        }
        if (inside) {
          return { type: 'hatch', item: hatch };
        }
      }
    }
    
    // Check walls
    for (const wall of activeFloor.walls) {
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      if (length < 0.001) continue;

      const t = ((point.x - wall.start.x) * dx + (point.y - wall.start.y) * dy) / (length * length);
      if (t < 0 || t > 1) continue;
      
      const closest = { x: wall.start.x + t * dx, y: wall.start.y + t * dy };
      const thickness = WALL_THICKNESS_OPTIONS[wall.type]?.thickness || 8;
      
      if (distance(point, closest) < thickness + 5) {
        return { type: 'wall', item: wall };
      }
    }
    
    return null;
  }, [activeFloor]);
  
  // ============================================================================
  // POINTER HANDLERS
  // ============================================================================
  const handlePointerDown = useCallback((e) => {
    e.preventDefault();
    
    // Handle multi-touch for pinch-to-zoom and two-finger pan
    if (e.touches && e.touches.length === 2) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const dist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
      const centerX = (touch1.clientX + touch2.clientX) / 2;
      const centerY = (touch1.clientY + touch2.clientY) / 2;
      
      setPinchStart({
        dist,
        scale,
        centerX,
        centerY,
        offsetX: offset.x,
        offsetY: offset.y,
      });
      setIsPanning(true);
      setPanStart({ x: centerX, y: centerY });
      return;
    }
    
    const pos = getPointerPos(e);
    const snappedPos = { x: snap(pos.x), y: snap(pos.y) };
    
    if (tool === 'pan') {
      setIsPanning(true);
      setPanStart({ x: e.clientX || e.touches[0].clientX, y: e.clientY || e.touches[0].clientY });
    } else if (tool === 'wall') {
      setIsDrawing(true);
      setDrawStart(snappedPos);
      setDrawEnd(snappedPos);
    } else if (tool === 'door' || tool === 'window') {
      // First check if we're clicking on an existing door or window - if so, select it
      const existingItem = findItemAt(pos);
      if (existingItem && (existingItem.type === 'door' || existingItem.type === 'window')) {
        setSelectedItems([existingItem]);
        if (!editorsMinimized) setShowDoorWindowEditor(true);
        setShowWallEditor(false);
        setDragItem(existingItem.item);
        setDragOffset({ x: pos.x, y: pos.y });
        setTool('select'); // Switch to select mode
        return;
      }
      
      const nearest = findNearestWall(pos);
      if (nearest) {
        // Convert inches to pixels (1 inch = GRID_SIZE/6 pixels)
        const inchesToPixels = (inches) => inches * (GRID_SIZE / 6);
        
        if (tool === 'door') {
          const doorType = DOOR_TYPES.find(d => d.id === selectedDoorType) || DOOR_TYPES[0];
          const item = {
            id: generateId(),
            wallId: nearest.wall.id,
            position: nearest.position,
            width: inchesToPixels(doorType.defaultWidth),
            type: selectedDoorType,
            swing: 'left', // left, right, both, none
            openDirection: 'inward', // inward, outward
          };
          updateActiveFloor(f => ({ ...f, doors: [...f.doors, item] }));
          // Select the new door and switch to select mode
          setSelectedItems([{ type: 'door', item }]);
          if (!editorsMinimized) setShowDoorWindowEditor(true);
          setTool('select');
        } else {
          const winType = WINDOW_TYPES.find(w => w.id === selectedWindowType) || WINDOW_TYPES[0];
          const item = {
            id: generateId(),
            wallId: nearest.wall.id,
            position: nearest.position,
            width: inchesToPixels(winType.defaultWidth),
            height: inchesToPixels(winType.defaultHeight),
            type: selectedWindowType,
            sillHeight: 36, // inches from floor
          };
          updateActiveFloor(f => ({ ...f, windows: [...f.windows, item] }));
          // Select the new window and switch to select mode
          setSelectedItems([{ type: 'window', item }]);
          if (!editorsMinimized) setShowDoorWindowEditor(true);
          setTool('select');
        }
      }
    } else if (tool === 'measure') {
      if (!measureStart) {
        setMeasureStart(snappedPos);
      } else {
        setMeasureEnd(snappedPos);
      }
    } else if (tool === 'dimension') {
      // Find snap points: wall ends, corners, door centers, window centers
      let snapPoint = snappedPos;
      let minDist = 15; // Snap distance threshold
      
      // Snap to wall endpoints
      activeFloor.walls.forEach(wall => {
        const dStart = distance(pos, wall.start);
        const dEnd = distance(pos, wall.end);
        if (dStart < minDist) {
          minDist = dStart;
          snapPoint = { ...wall.start };
        }
        if (dEnd < minDist) {
          minDist = dEnd;
          snapPoint = { ...wall.end };
        }
      });
      
      // Snap to door centers
      activeFloor.doors.forEach(door => {
        const wall = activeFloor.walls.find(w => w.id === door.wallId);
        if (wall) {
          const dx = wall.end.x - wall.start.x;
          const dy = wall.end.y - wall.start.y;
          const doorCenter = {
            x: wall.start.x + dx * door.position,
            y: wall.start.y + dy * door.position
          };
          const d = distance(pos, doorCenter);
          if (d < minDist) {
            minDist = d;
            snapPoint = doorCenter;
          }
        }
      });
      
      // Snap to window centers
      activeFloor.windows.forEach(win => {
        const wall = activeFloor.walls.find(w => w.id === win.wallId);
        if (wall) {
          const dx = wall.end.x - wall.start.x;
          const dy = wall.end.y - wall.start.y;
          const winCenter = {
            x: wall.start.x + dx * win.position,
            y: wall.start.y + dy * win.position
          };
          const d = distance(pos, winCenter);
          if (d < minDist) {
            minDist = d;
            snapPoint = winCenter;
          }
        }
      });
      
      const currentDimStart = dimensionStartRef.current;
      if (!currentDimStart) {
        // Store snap point along with any link info
        setDimensionStart({
          ...snapPoint,
          linkedTo: findNearestLinkTarget(snapPoint)
        });
        setMeasureEnd(null);
      } else {
        // Find link target for end point
        const endLinkTarget = findNearestLinkTarget(snapPoint);
        
        // Create permanent dimension
        const newDimension = {
          id: generateId(),
          start: { x: currentDimStart.x, y: currentDimStart.y },
          end: { x: snapPoint.x, y: snapPoint.y },
          style: dimensionStyle,
          offset: DIMENSION_STYLES[dimensionStyle].offset,
          label: '',
          // Store links to doors/windows for auto-updating
          startLink: currentDimStart.linkedTo || null,
          endLink: endLinkTarget || null,
        };
        
        // Add dimension to active floor
        const newFloors = floors.map(f => {
          if (f.id === activeFloorId) {
            return {
              ...f,
              dimensions: [...(f.dimensions || []), newDimension]
            };
          }
          return f;
        });
        
        setFloors(newFloors);
        saveToHistory(newFloors);
        
        // Reset for next dimension
        setDimensionStart(null);
        setMeasureEnd(null);
      }
    } else if (tool === 'room') {
      setIsDrawing(true);
      setDrawStart(snappedPos);
      setDrawEnd(snappedPos);
    } else if (tool === 'text') {
      // Show text input dialog at this position
      setPendingTextPos(snappedPos);
      setTextInput('');
      setShowTextInput(true);
    } else if (tool === 'plumbing-line' && plumbingLineType) {
      if (!plumbingLineStart) {
        setPlumbingLineStart(snappedPos);
      } else {
        // Complete the line
        const newLine = {
          id: generateId(),
          type: plumbingLineType,
          start: { ...plumbingLineStart },
          end: { ...snappedPos },
        };
        updateActiveFloor(f => ({ 
          ...f, 
          plumbingLines: [...(f.plumbingLines || []), newLine] 
        }));
        setPlumbingLineStart(snappedPos); // Continue from end point
      }
    } else if (tool === 'line') {
      // Draw simple lines - use ref to avoid stale closure
      if (!lineStartRef.current) {
        setLineStart(snappedPos);
        lineStartRef.current = snappedPos;
      } else {
        // Complete the line
        const newLine = {
          id: generateId(),
          start: { ...lineStartRef.current },
          end: { ...snappedPos },
          lineType: lineType,
          lineWeight: lineWeight,
          color: '#aaaaaa',
        };
        updateActiveFloor(f => ({ 
          ...f, 
          lines: [...(f.lines || []), newLine] 
        }));
        // Continue from end point
        setLineStart(snappedPos);
        lineStartRef.current = snappedPos;
      }
    } else if (tool === 'polyline' || tool === 'freehand') {
      // Add point to polyline
      if (!isDrawingPolyline) {
        setPolylinePoints([snappedPos]);
        setIsDrawingPolyline(true);
      } else {
        setPolylinePoints(prev => [...prev, snappedPos]);
      }
    } else if (tool === 'hatch') {
      // Add point to hatch boundary
      if (!isDrawingPolyline) {
        setPolylinePoints([snappedPos]);
        setIsDrawingPolyline(true);
      } else {
        // Check if clicking near first point to close
        if (polylinePoints.length >= 3 && distance(snappedPos, polylinePoints[0]) < 20) {
          // Close and create hatch
          const newHatch = {
            id: generateId(),
            points: [...polylinePoints],
            pattern: hatchPattern,
            scale: hatchScale,
          };
          updateActiveFloor(f => ({
            ...f,
            hatches: [...(f.hatches || []), newHatch]
          }));
          setPolylinePoints([]);
          setIsDrawingPolyline(false);
        } else {
          setPolylinePoints(prev => [...prev, snappedPos]);
        }
      }
    } else if (tool === 'porch') {
      // Draw porch (rectangle-based)
      setIsDrawing(true);
      setDrawStart(snappedPos);
      setDrawEnd(snappedPos);
    } else if (tool === 'roof') {
      // Draw roof (rectangle-based footprint)
      setIsDrawing(true);
      setDrawStart(snappedPos);
      setDrawEnd(snappedPos);
    } else if (tool === 'select') {
      // Check for grip click first - prioritize selected wall's grips
      if (showGrips && !layers.walls.locked) {
        const selectedGripRadius = 16 / scale; // Larger radius for selected walls
        const otherGripRadius = 10 / scale; // Smaller radius for non-selected walls
        
        // First check grips on selected walls (priority) with larger hit area
        const selectedWallIds = selectedItems
          .filter(s => s.type === 'wall')
          .map(s => s.item.id);
        
        for (const wallId of selectedWallIds) {
          const wall = activeFloor.walls.find(w => w.id === wallId);
          if (wall) {
            // Check start grip
            if (distance(pos, wall.start) < selectedGripRadius) {
              setActiveGrip({ wallId: wall.id, endpoint: 'start' });
              return;
            }
            // Check end grip
            if (distance(pos, wall.end) < selectedGripRadius) {
              setActiveGrip({ wallId: wall.id, endpoint: 'end' });
              return;
            }
          }
        }
        
        // Then check grips on non-selected walls with smaller hit area
        for (const wall of activeFloor.walls) {
          if (selectedWallIds.includes(wall.id)) continue; // Skip already checked
          // Check start grip
          if (distance(pos, wall.start) < otherGripRadius) {
            setActiveGrip({ wallId: wall.id, endpoint: 'start' });
            return;
          }
          // Check end grip
          if (distance(pos, wall.end) < otherGripRadius) {
            setActiveGrip({ wallId: wall.id, endpoint: 'end' });
            return;
          }
        }
      }
      
      const item = findItemAt(pos);
      if (item) {
        // Shift-click to add to selection
        if (e.shiftKey) {
          const alreadySelected = selectedItems.some(s => s.type === item.type && s.item.id === item.item.id);
          if (alreadySelected) {
            setSelectedItems(selectedItems.filter(s => !(s.type === item.type && s.item.id === item.item.id)));
          } else {
            setSelectedItems([...selectedItems, item]);
          }
          return;
        }
        
        setSelectedItems([item]);
        if (item.type === 'wall') {
          if (!editorsMinimized) setShowWallEditor(true);
          setShowDoorWindowEditor(false);
          // Enable wall dragging - store original center for angle locking
          const wallCenter = {
            x: (item.item.start.x + item.item.end.x) / 2,
            y: (item.item.start.y + item.item.end.y) / 2,
          };
          setDragItem(item.item);
          setDragOffset({ x: pos.x - wallCenter.x, y: pos.y - wallCenter.y });
          setWallDragStart({ x: wallCenter.x, y: wallCenter.y }); // Store original center for angle locking
        } else if (item.type === 'door' || item.type === 'window') {
          if (!editorsMinimized) setShowDoorWindowEditor(true);
          setShowWallEditor(false);
          // Enable dragging along wall
          setDragItem(item.item);
          setDragOffset({ x: pos.x, y: pos.y });
        } else if (item.type === 'dimension') {
          // Enable dragging dimensions
          setDragItem(item.item);
          setDragOffset({ x: pos.x, y: pos.y });
          setShowWallEditor(false);
          setShowDoorWindowEditor(false);
        } else if (item.type === 'room') {
          setShowWallEditor(false);
          setShowDoorWindowEditor(false);
          setDragItem(item.item);
          setDragOffset({ x: pos.x - item.item.x, y: pos.y - item.item.y });
        } else if (item.type === 'porch') {
          setShowWallEditor(false);
          setShowDoorWindowEditor(false);
          setDragItem(item.item);
          setDragOffset({ x: pos.x - item.item.x, y: pos.y - item.item.y });
        } else {
          setShowWallEditor(false);
          setShowDoorWindowEditor(false);
        }
        if (item.type === 'furniture' || item.type === 'stairs' || item.type === 'electrical' || item.type === 'plumbing' || item.type === 'text') {
          setDragItem(item.item);
          setDragOffset({ x: pos.x - item.item.x, y: pos.y - item.item.y });
        }
      } else {
        setSelectedItems([]);
        setShowWallEditor(false);
        setShowDoorWindowEditor(false);
      }
    } else if (tool === 'move') {
      // Move command - click base point, then click destination
      if (selectedItems.length === 0) {
        // Nothing selected - try to select something first
        const item = findItemAt(pos);
        if (item) {
          setSelectedItems([item]);
        }
        return;
      }
      
      const snapPoint = findNearestSnapPoint(pos, 25 / scale);
      const targetPoint = snapPoint || snappedPos;
      
      if (!moveBasePoint) {
        // First click - set base point
        setMoveBasePoint(targetPoint);
        setMovePreviewPoint(targetPoint);
      } else {
        // Second click - execute move
        const deltaX = targetPoint.x - moveBasePoint.x;
        const deltaY = targetPoint.y - moveBasePoint.y;
        moveSelectedItems(deltaX, deltaY);
        setMoveBasePoint(null);
        setMovePreviewPoint(null);
        setTool('select');
      }
    } else if (tool === 'rotate') {
      // Rotate command - click center, then click/drag to set angle
      if (selectedItems.length === 0) {
        // Nothing selected - try to select something first
        const item = findItemAt(pos);
        if (item) {
          setSelectedItems([item]);
        }
        return;
      }

      const snapPoint = findNearestSnapPoint(pos, 25 / scale);
      const targetPoint = snapPoint || snappedPos;

      if (!rotateCenter) {
        // First click - set rotation center
        setRotateCenter(targetPoint);
        setRotateStartAngle(null);
        setRotatePreviewAngle(0);
      } else if (rotateStartAngle === null) {
        // Second click - set reference angle
        const angle = Math.atan2(targetPoint.y - rotateCenter.y, targetPoint.x - rotateCenter.x);
        setRotateStartAngle(angle);
        setRotatePreviewAngle(angle);
      } else {
        // Third click - execute rotation
        const newAngle = Math.atan2(targetPoint.y - rotateCenter.y, targetPoint.x - rotateCenter.x);
        const angleDelta = newAngle - rotateStartAngle;
        rotateSelectedItems(rotateCenter.x, rotateCenter.y, angleDelta);
        setRotateCenter(null);
        setRotateStartAngle(null);
        setRotatePreviewAngle(null);
        setTool('select');
      }
    } else if (tool === 'extend') {
      // Extend tool - click on wall to extend it to meet another wall
      // Find the wall closest to the click point
      const walls = activeFloor.walls || [];
      let clickedWall = null;
      let clickedEndpoint = null; // 'start' or 'end'
      let minDist = 30 / scale;

      for (const wall of walls) {
        const dStart = distance(pos, wall.start);
        const dEnd = distance(pos, wall.end);
        if (dStart < minDist) {
          minDist = dStart;
          clickedWall = wall;
          clickedEndpoint = 'start';
        }
        if (dEnd < minDist) {
          minDist = dEnd;
          clickedWall = wall;
          clickedEndpoint = 'end';
        }
      }

      if (clickedWall && clickedEndpoint) {
        // Find the nearest wall to extend to
        const extendPoint = clickedEndpoint === 'start' ? clickedWall.start : clickedWall.end;
        const wallDir = {
          x: clickedWall.end.x - clickedWall.start.x,
          y: clickedWall.end.y - clickedWall.start.y,
        };
        // Normalize direction
        const wallLen = Math.sqrt(wallDir.x * wallDir.x + wallDir.y * wallDir.y);
        if (wallLen < 0.001) return;
        wallDir.x /= wallLen;
        wallDir.y /= wallLen;

        // If extending from start, reverse direction
        if (clickedEndpoint === 'start') {
          wallDir.x = -wallDir.x;
          wallDir.y = -wallDir.y;
        }

        // Find intersection with other walls
        let bestIntersection = null;
        let bestDist = Infinity;

        for (const targetWall of walls) {
          if (targetWall.id === clickedWall.id) continue;

          // Line-line intersection
          const x1 = extendPoint.x, y1 = extendPoint.y;
          const x2 = extendPoint.x + wallDir.x * 10000, y2 = extendPoint.y + wallDir.y * 10000;
          const x3 = targetWall.start.x, y3 = targetWall.start.y;
          const x4 = targetWall.end.x, y4 = targetWall.end.y;

          const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
          if (Math.abs(denom) < 0.001) continue;

          const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
          const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

          // Check if intersection is in valid range (t > 0 for extension, 0 <= u <= 1 for on target wall)
          if (t > 0.001 && u >= -0.01 && u <= 1.01) {
            const ix = x1 + t * (x2 - x1);
            const iy = y1 + t * (y2 - y1);
            const dist = t * Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));

            if (dist < bestDist) {
              bestDist = dist;
              bestIntersection = { x: ix, y: iy };
            }
          }
        }

        if (bestIntersection) {
          // Update the wall endpoint to the intersection point
          const updatedWalls = walls.map(w => {
            if (w.id === clickedWall.id) {
              if (clickedEndpoint === 'start') {
                return { ...w, start: { x: snap(bestIntersection.x), y: snap(bestIntersection.y) } };
              } else {
                return { ...w, end: { x: snap(bestIntersection.x), y: snap(bestIntersection.y) } };
              }
            }
            return w;
          });

          const newFloors = floors.map(f => {
            if (f.id === activeFloorId) {
              return { ...f, walls: updatedWalls };
            }
            return f;
          });
          setFloors(newFloors);
          saveToHistory(newFloors);
        }
      }
    } else if (tool === 'trim') {
      // Trim tool - click on a wall segment to trim it at intersections
      const walls = activeFloor.walls || [];

      // Find wall under cursor
      let clickedWall = null;
      let clickedT = 0; // Position along wall (0-1)
      let minDist = 15 / scale;

      for (const wall of walls) {
        const dx = wall.end.x - wall.start.x;
        const dy = wall.end.y - wall.start.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len < 0.001) continue;

        // Project point onto wall line
        let t = ((pos.x - wall.start.x) * dx + (pos.y - wall.start.y) * dy) / (len * len);
        t = Math.max(0, Math.min(1, t));

        const closest = {
          x: wall.start.x + t * dx,
          y: wall.start.y + t * dy
        };

        const d = distance(pos, closest);
        if (d < minDist) {
          minDist = d;
          clickedWall = wall;
          clickedT = t;
        }
      }

      if (clickedWall) {
        // Find all intersections with other walls
        const intersections = [];

        for (const targetWall of walls) {
          if (targetWall.id === clickedWall.id) continue;

          const x1 = clickedWall.start.x, y1 = clickedWall.start.y;
          const x2 = clickedWall.end.x, y2 = clickedWall.end.y;
          const x3 = targetWall.start.x, y3 = targetWall.start.y;
          const x4 = targetWall.end.x, y4 = targetWall.end.y;

          const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
          if (Math.abs(denom) < 0.001) continue;

          const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
          const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

          // Check if intersection is on both wall segments
          if (t >= 0.01 && t <= 0.99 && u >= 0.01 && u <= 0.99) {
            intersections.push({
              t,
              x: x1 + t * (x2 - x1),
              y: y1 + t * (y2 - y1),
            });
          }
        }

        if (intersections.length > 0) {
          // Sort intersections by t value
          intersections.sort((a, b) => a.t - b.t);

          // Find which segment the click was in
          let segmentStart = 0;
          let segmentEnd = 1;

          for (let i = 0; i < intersections.length; i++) {
            if (intersections[i].t > clickedT) {
              segmentEnd = intersections[i].t;
              break;
            }
            segmentStart = intersections[i].t;
          }

          // Delete the clicked segment by modifying the wall
          // If clicked segment is at start or end, shorten the wall
          // If in middle, we'd need to split (not implemented - just shorten to nearest intersection)

          const dx = clickedWall.end.x - clickedWall.start.x;
          const dy = clickedWall.end.y - clickedWall.start.y;

          let updatedWalls;

          if (segmentStart === 0) {
            // Trim from start - move start point to first intersection
            const newStart = {
              x: snap(clickedWall.start.x + segmentEnd * dx),
              y: snap(clickedWall.start.y + segmentEnd * dy),
            };
            updatedWalls = walls.map(w => {
              if (w.id === clickedWall.id) {
                return { ...w, start: newStart };
              }
              return w;
            });
          } else if (segmentEnd === 1) {
            // Trim from end - move end point to last intersection
            const newEnd = {
              x: snap(clickedWall.start.x + segmentStart * dx),
              y: snap(clickedWall.start.y + segmentStart * dy),
            };
            updatedWalls = walls.map(w => {
              if (w.id === clickedWall.id) {
                return { ...w, end: newEnd };
              }
              return w;
            });
          } else {
            // Middle segment - remove the wall and create two new walls
            const newWall1 = {
              ...clickedWall,
              id: generateId(),
              end: {
                x: snap(clickedWall.start.x + segmentStart * dx),
                y: snap(clickedWall.start.y + segmentStart * dy),
              },
            };
            const newWall2 = {
              ...clickedWall,
              id: generateId(),
              start: {
                x: snap(clickedWall.start.x + segmentEnd * dx),
                y: snap(clickedWall.start.y + segmentEnd * dy),
              },
            };
            updatedWalls = walls.filter(w => w.id !== clickedWall.id).concat([newWall1, newWall2]);
          }

          const newFloors = floors.map(f => {
            if (f.id === activeFloorId) {
              return { ...f, walls: updatedWalls };
            }
            return f;
          });
          setFloors(newFloors);
          saveToHistory(newFloors);
        }
      }
    } else if (tool === 'corner') {
      // Corner tool - tap anywhere near a corner to clean it up
      // Much more forgiving - finds closest walls and figures out which endpoints to join
      const walls = activeFloor.walls || [];
      if (walls.length < 2) return;

      // Large search radius - especially on mobile
      const searchRadius = isMobile ? 150 / scale : 100 / scale;

      // Find all walls within search radius (by checking distance to wall line, not just endpoints)
      const nearbyWalls = [];
      for (const wall of walls) {
        // Calculate distance from tap point to wall line segment
        const dx = wall.end.x - wall.start.x;
        const dy = wall.end.y - wall.start.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len < 0.001) continue;

        // Project point onto wall line
        let t = ((pos.x - wall.start.x) * dx + (pos.y - wall.start.y) * dy) / (len * len);
        t = Math.max(0, Math.min(1, t));

        const closest = {
          x: wall.start.x + t * dx,
          y: wall.start.y + t * dy
        };

        const distToWall = distance(pos, closest);
        if (distToWall < searchRadius) {
          nearbyWalls.push({ wall, distToWall });
        }
      }

      // Sort by distance to wall
      nearbyWalls.sort((a, b) => a.distToWall - b.distToWall);

      // Take the two closest walls
      if (nearbyWalls.length >= 2) {
        const wall1 = nearbyWalls[0].wall;
        const wall2 = nearbyWalls[1].wall;

        // Find which endpoints of these walls are closest to each other
        const endpointPairs = [
          { ep1: 'start', ep2: 'start', dist: distance(wall1.start, wall2.start) },
          { ep1: 'start', ep2: 'end', dist: distance(wall1.start, wall2.end) },
          { ep1: 'end', ep2: 'start', dist: distance(wall1.end, wall2.start) },
          { ep1: 'end', ep2: 'end', dist: distance(wall1.end, wall2.end) },
        ];
        endpointPairs.sort((a, b) => a.dist - b.dist);
        const closestPair = endpointPairs[0];

        // Calculate the intersection point of the two wall lines (extended infinitely)
        const x1 = wall1.start.x, y1 = wall1.start.y;
        const x2 = wall1.end.x, y2 = wall1.end.y;
        const x3 = wall2.start.x, y3 = wall2.start.y;
        const x4 = wall2.end.x, y4 = wall2.end.y;

        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (Math.abs(denom) > 0.001) { // Not parallel
          const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;

          // Calculate intersection point
          const ix = x1 + t * (x2 - x1);
          const iy = y1 + t * (y2 - y1);
          const intersection = { x: snap(ix), y: snap(iy) };

          // Update both walls to meet at the intersection
          const updatedWalls = walls.map(w => {
            if (w.id === wall1.id) {
              if (closestPair.ep1 === 'start') {
                return { ...w, start: intersection };
              } else {
                return { ...w, end: intersection };
              }
            }
            if (w.id === wall2.id) {
              if (closestPair.ep2 === 'start') {
                return { ...w, start: intersection };
              } else {
                return { ...w, end: intersection };
              }
            }
            return w;
          });

          const newFloors = floors.map(f => {
            if (f.id === activeFloorId) {
              return { ...f, walls: updatedWalls };
            }
            return f;
          });
          setFloors(newFloors);
          saveToHistory(newFloors);
        }
      }
    }
  }, [tool, getPointerPos, findNearestWall, findItemAt, measureStart, updateActiveFloor, plumbingLineType, plumbingLineStart, dimensionStyle, activeFloorId, floors, saveToHistory, showGrips, layers, scale, activeFloor, snap, lineStart, lineType, lineWeight, isDrawingPolyline, polylinePoints, hatchPattern, hatchScale, selectedItems, offset, moveBasePoint, rotateCenter, rotateStartAngle, findNearestSnapPoint, moveSelectedItems, rotateSelectedItems, editorsMinimized, generateId, isMobile]);

  const handlePointerMove = useCallback((e) => {
    e.preventDefault();
    
    // Handle pinch-to-zoom
    if (e.touches && e.touches.length === 2 && pinchStart) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const dist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
      const centerX = (touch1.clientX + touch2.clientX) / 2;
      const centerY = (touch1.clientY + touch2.clientY) / 2;
      
      // Calculate new scale based on pinch distance change
      const scaleChange = dist / pinchStart.dist;
      const newScale = Math.max(0.1, Math.min(5, pinchStart.scale * scaleChange));
      
      // Calculate offset to zoom towards pinch center
      const canvas = canvasRef.current;
      if (canvas) {
        const rect = canvas.getBoundingClientRect();
        const pinchCenterX = centerX - rect.left;
        const pinchCenterY = centerY - rect.top;
        
        // Adjust offset to keep pinch center stationary
        const scaleRatio = newScale / pinchStart.scale;
        const newOffsetX = pinchCenterX - (pinchCenterX - pinchStart.offsetX) * scaleRatio;
        const newOffsetY = pinchCenterY - (pinchCenterY - pinchStart.offsetY) * scaleRatio;
        
        // Also handle two-finger pan
        const panDeltaX = centerX - panStart.x;
        const panDeltaY = centerY - panStart.y;
        
        setScale(newScale);
        setOffset({ x: newOffsetX + panDeltaX, y: newOffsetY + panDeltaY });
        setPanStart({ x: centerX, y: centerY });
      }
      return;
    }
    
    const clientX = e.clientX || (e.touches && e.touches[0]?.clientX);
    const clientY = e.clientY || (e.touches && e.touches[0]?.clientY);
    
    if (isPanning && panStart) {
      setOffset({
        x: offset.x + (clientX - panStart.x),
        y: offset.y + (clientY - panStart.y)
      });
      setPanStart({ x: clientX, y: clientY });
    } else if (isDrawing) {
      const pos = getPointerPos(e);
      const snappedPos = { x: snap(pos.x), y: snap(pos.y) };

      // Auto-pan when drawing near screen edges on mobile
      if (isMobile && canvasRef.current) {
        const rect = canvasRef.current.getBoundingClientRect();
        const edgeThreshold = 60; // pixels from edge to trigger pan
        const panSpeed = 8; // pixels to pan per move event

        let panX = 0;
        let panY = 0;

        // Check if pointer is near edges
        if (clientX < rect.left + edgeThreshold) {
          panX = panSpeed; // Pan right (move canvas left relative to view)
        } else if (clientX > rect.right - edgeThreshold) {
          panX = -panSpeed; // Pan left
        }

        if (clientY < rect.top + edgeThreshold) {
          panY = panSpeed; // Pan down
        } else if (clientY > rect.bottom - edgeThreshold) {
          panY = -panSpeed; // Pan up
        }

        // Apply auto-pan if near edge
        if (panX !== 0 || panY !== 0) {
          setOffset(prev => ({
            x: prev.x + panX,
            y: prev.y + panY
          }));
        }
      }

      if (tool === 'wall' && drawStart) {
        // Use angle snapping for walls
        const angleSnapped = snapAngle(drawStart, snappedPos);
        let finalPos = { x: snap(angleSnapped.x), y: snap(angleSnapped.y) };
        
        // Endpoint snap distance - larger for mobile finger use
        const ENDPOINT_SNAP_DIST = isMobile ? 50 : 20;
        const ALIGN_TOLERANCE = isMobile ? 20 : 10; // pixels
        
        // Collect all snap points for endpoint snapping
        const endpointSnapPoints = [];
        activeFloor.walls.forEach(wall => {
          endpointSnapPoints.push({ x: wall.start.x, y: wall.start.y, type: 'endpoint' });
          endpointSnapPoints.push({ x: wall.end.x, y: wall.end.y, type: 'endpoint' });
          endpointSnapPoints.push({ 
            x: (wall.start.x + wall.end.x) / 2, 
            y: (wall.start.y + wall.end.y) / 2,
            type: 'midpoint'
          });
        });
        
        // First check for direct endpoint/midpoint snap (highest priority)
        let snappedToEndpoint = null;
        let minEndpointDist = ENDPOINT_SNAP_DIST;
        
        endpointSnapPoints.forEach(pt => {
          // Skip if this is the drawStart point
          if (Math.abs(pt.x - drawStart.x) < 5 && Math.abs(pt.y - drawStart.y) < 5) return;
          
          const d = Math.sqrt((finalPos.x - pt.x) ** 2 + (finalPos.y - pt.y) ** 2);
          if (d < minEndpointDist) {
            minEndpointDist = d;
            snappedToEndpoint = pt;
          }
        });
        
        // If we found a nearby endpoint, snap to it
        if (snappedToEndpoint) {
          finalPos = { x: snappedToEndpoint.x, y: snappedToEndpoint.y };
          setWallDrawSnap(snappedToEndpoint); // For visual feedback
        } else {
          // Fall back to alignment snapping
          endpointSnapPoints.forEach(pt => {
            // Skip if too close to draw start
            if (Math.abs(pt.x - drawStart.x) < 5 && Math.abs(pt.y - drawStart.y) < 5) return;
            
            // Horizontal alignment (same Y)
            if (Math.abs(pt.y - finalPos.y) < ALIGN_TOLERANCE) {
              finalPos.y = pt.y;
            }
            
            // Vertical alignment (same X)
            if (Math.abs(pt.x - finalPos.x) < ALIGN_TOLERANCE) {
              finalPos.x = pt.x;
            }
          });
          setWallDrawSnap(null);
        }
        
        setDrawEnd(finalPos);
        return;
      }
      
      setDrawEnd(snappedPos);
    } else if (activeGrip) {
      // Handle grip dragging with snap to other grips, midpoints, perpendiculars
      const pos = getPointerPos(e);
      let snappedPos = { x: snap(pos.x), y: snap(pos.y) };
      const SNAP_DIST = (isMobile ? 50 : 25) / scale; // Larger snap distance for mobile
      
      // Collect all snap points (endpoints and midpoints of other walls)
      const snapPoints = [];
      const currentWall = activeFloor.walls.find(w => w.id === activeGrip.wallId);
      
      activeFloor.walls.forEach(wall => {
        // Don't snap to own endpoints
        if (wall.id === activeGrip.wallId) return;
        
        // Wall endpoints
        snapPoints.push({ x: wall.start.x, y: wall.start.y, type: 'endpoint', label: 'END' });
        snapPoints.push({ x: wall.end.x, y: wall.end.y, type: 'endpoint', label: 'END' });
        
        // Wall midpoint
        snapPoints.push({
          x: (wall.start.x + wall.end.x) / 2,
          y: (wall.start.y + wall.end.y) / 2,
          type: 'midpoint',
          label: 'MID'
        });
        
        // Perpendicular snap - find closest point on wall that's perpendicular
        if (currentWall) {
          const otherEnd = activeGrip.endpoint === 'start' ? currentWall.end : currentWall.start;
          const dx = wall.end.x - wall.start.x;
          const dy = wall.end.y - wall.start.y;
          const wallLen = Math.sqrt(dx * dx + dy * dy);
          
          if (wallLen > 0) {
            // Project cursor onto the wall line
            const t = ((pos.x - wall.start.x) * dx + (pos.y - wall.start.y) * dy) / (wallLen * wallLen);
            
            if (t >= 0 && t <= 1) {
              const projX = wall.start.x + t * dx;
              const projY = wall.start.y + t * dy;
              
              // Check if this creates a perpendicular (90¬∞) from otherEnd
              const toProj = { x: projX - otherEnd.x, y: projY - otherEnd.y };
              const wallDir = { x: dx / wallLen, y: dy / wallLen };
              const dot = Math.abs(toProj.x * wallDir.x + toProj.y * wallDir.y);
              const projLen = Math.sqrt(toProj.x * toProj.x + toProj.y * toProj.y);
              
              // If nearly perpendicular (dot product close to 0)
              if (projLen > 0 && dot / projLen < 0.1) {
                snapPoints.push({ x: projX, y: projY, type: 'perpendicular', label: 'PERP' });
              }
            }
          }
        }
      });
      
      // Find nearest snap point
      let nearestDist = SNAP_DIST;
      let nearestPoint = null;
      
      snapPoints.forEach(sp => {
        const d = Math.sqrt((pos.x - sp.x) ** 2 + (pos.y - sp.y) ** 2);
        if (d < nearestDist) {
          nearestDist = d;
          nearestPoint = sp;
        }
      });
      
      // Update grip snap target and all snap points for visualization
      setGripSnapTarget(nearestPoint);
      setAllSnapPoints(snapPoints);
      
      // Use snap point if found, otherwise use grid snapped position
      if (nearestPoint) {
        snappedPos = { x: nearestPoint.x, y: nearestPoint.y };
      }
      
      updateActiveFloor(f => ({
        ...f,
        walls: f.walls.map(w => {
          if (w.id === activeGrip.wallId) {
            if (activeGrip.endpoint === 'start') {
              return { ...w, start: snappedPos };
            } else {
              return { ...w, end: snappedPos };
            }
          }
          return w;
        })
      }));
    } else if (dragItem) {
      const pos = getPointerPos(e);
      const newX = snap(pos.x - dragOffset.x);
      const newY = snap(pos.y - dragOffset.y);
      
      // Update based on item type
      const itemType = selectedItems[0]?.type;
      if (itemType === 'furniture') {
        updateActiveFloor(f => ({
          ...f,
          furniture: f.furniture.map(furn =>
            furn.id === dragItem.id ? { ...furn, x: newX, y: newY } : furn
          )
        }));
      } else if (itemType === 'stairs') {
        updateActiveFloor(f => ({
          ...f,
          stairs: f.stairs.map(s =>
            s.id === dragItem.id ? { ...s, x: newX, y: newY } : s
          )
        }));
      } else if (itemType === 'electrical') {
        updateActiveFloor(f => ({
          ...f,
          electrical: f.electrical.map(e =>
            e.id === dragItem.id ? { ...e, x: newX, y: newY } : e
          )
        }));
      } else if (itemType === 'plumbing') {
        updateActiveFloor(f => ({
          ...f,
          plumbing: f.plumbing.map(p =>
            p.id === dragItem.id ? { ...p, x: newX, y: newY } : p
          )
        }));
      } else if (itemType === 'text') {
        updateActiveFloor(f => ({
          ...f,
          texts: (f.texts || []).map(t =>
            t.id === dragItem.id ? { ...t, x: newX, y: newY } : t
          )
        }));
      } else if (itemType === 'door') {
        // Drag door along its wall
        const door = activeFloor.doors.find(d => d.id === dragItem.id);
        const wall = activeFloor.walls.find(w => w.id === door?.wallId);
        if (wall && door) {
          const dx = wall.end.x - wall.start.x;
          const dy = wall.end.y - wall.start.y;
          const wallLength = Math.sqrt(dx * dx + dy * dy);
          
          // Project the cursor position onto the wall line
          const t = ((pos.x - wall.start.x) * dx + (pos.y - wall.start.y) * dy) / (wallLength * wallLength);
          const newPosition = Math.max(0.05, Math.min(0.95, t));
          
          updateActiveFloor(f => ({
            ...f,
            doors: f.doors.map(d =>
              d.id === dragItem.id ? { ...d, position: newPosition } : d
            )
          }));
        }
      } else if (itemType === 'window') {
        // Drag window along its wall
        const win = activeFloor.windows.find(w => w.id === dragItem.id);
        const wall = activeFloor.walls.find(w => w.id === win?.wallId);
        if (wall && win) {
          const dx = wall.end.x - wall.start.x;
          const dy = wall.end.y - wall.start.y;
          const wallLength = Math.sqrt(dx * dx + dy * dy);
          
          // Project the cursor position onto the wall line
          const t = ((pos.x - wall.start.x) * dx + (pos.y - wall.start.y) * dy) / (wallLength * wallLength);
          const newPosition = Math.max(0.05, Math.min(0.95, t));
          
          updateActiveFloor(f => ({
            ...f,
            windows: f.windows.map(w =>
              w.id === dragItem.id ? { ...w, position: newPosition } : w
            )
          }));
        }
      } else if (itemType === 'dimension') {
        // Drag dimension line - move perpendicular only (adjust offset)
        const dim = (activeFloor.dimensions || []).find(d => d.id === dragItem.id);
        if (dim) {
          const dx = dim.end.x - dim.start.x;
          const dy = dim.end.y - dim.start.y;
          const length = Math.sqrt(dx * dx + dy * dy);
          
          if (length > 0) {
            // Calculate perpendicular direction
            const perpX = -dy / length;
            const perpY = dx / length;
            
            // Calculate how far we've moved perpendicular to the line
            const moveX = pos.x - dragOffset.x;
            const moveY = pos.y - dragOffset.y;
            const perpDistance = moveX * perpX + moveY * perpY;
            
            updateActiveFloor(f => ({
              ...f,
              dimensions: f.dimensions.map(d =>
                d.id === dragItem.id ? {
                  ...d,
                  offset: (d.offset || 0) + perpDistance
                } : d
              )
            }));
            
            setDragOffset({ x: pos.x, y: pos.y });
          }
        }
      } else if (itemType === 'wall') {
        // Drag entire wall - move both start and end points with angle locking
        const wall = activeFloor.walls.find(w => w.id === dragItem.id);
        if (wall && wallDragStart) {
          // Calculate target position
          const targetX = pos.x - dragOffset.x;
          const targetY = pos.y - dragOffset.y;
          
          // Calculate delta from original position
          const dx = targetX - wallDragStart.x;
          const dy = targetY - wallDragStart.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          let finalDeltaX = dx;
          let finalDeltaY = dy;
          let snappedAngle = null;
          
          // Apply angle snapping if moved enough
          if (dist > 10) {
            let angle = Math.atan2(dy, dx);
            let angleDeg = angle * 180 / Math.PI;
            
            // Snap angles: 0, 45, 90, 135, 180, -135, -90, -45
            const SNAP_ANGLES = [0, 45, 90, 135, 180, -180, -135, -90, -45];
            const SNAP_TOLERANCE = 12; // degrees - good for touch
            
            for (const snapAngle of SNAP_ANGLES) {
              if (Math.abs(angleDeg - snapAngle) < SNAP_TOLERANCE) {
                snappedAngle = snapAngle;
                // Use snapped angle with original distance
                const snapRad = snapAngle * Math.PI / 180;
                finalDeltaX = Math.cos(snapRad) * dist;
                finalDeltaY = Math.sin(snapRad) * dist;
                break;
              }
            }
          }
          
          // Snap to grid
          const gridSnappedX = snap(wallDragStart.x + finalDeltaX);
          const gridSnappedY = snap(wallDragStart.y + finalDeltaY);
          finalDeltaX = gridSnappedX - wallDragStart.x;
          finalDeltaY = gridSnappedY - wallDragStart.y;
          
          // Update visual feedback state
          setWallDragSnap({
            startX: wallDragStart.x,
            startY: wallDragStart.y,
            endX: gridSnappedX,
            endY: gridSnappedY,
            angle: snappedAngle,
            snapped: snappedAngle !== null
          });
          
          // Get current wall center
          const wallCenterX = (wall.start.x + wall.end.x) / 2;
          const wallCenterY = (wall.start.y + wall.end.y) / 2;
          
          // Calculate actual delta to apply
          const newCenterX = wallDragStart.x + finalDeltaX;
          const newCenterY = wallDragStart.y + finalDeltaY;
          const deltaX = newCenterX - wallCenterX;
          const deltaY = newCenterY - wallCenterY;
          
          if (deltaX !== 0 || deltaY !== 0) {
            updateActiveFloor(f => ({
              ...f,
              walls: f.walls.map(w =>
                w.id === dragItem.id ? {
                  ...w,
                  start: { x: w.start.x + deltaX, y: w.start.y + deltaY },
                  end: { x: w.end.x + deltaX, y: w.end.y + deltaY },
                } : w
              )
            }));
          }
        }
      } else if (itemType === 'room') {
        // Drag room
        updateActiveFloor(f => ({
          ...f,
          rooms: f.rooms.map(r =>
            r.id === dragItem.id ? { ...r, x: newX, y: newY } : r
          )
        }));
      } else if (itemType === 'porch') {
        // Drag porch
        updateActiveFloor(f => ({
          ...f,
          porches: (f.porches || []).map(p =>
            p.id === dragItem.id ? { ...p, x: newX, y: newY } : p
          )
        }));
      }
    } else if (tool === 'measure' && measureStart && !measureEnd) {
      const pos = getPointerPos(e);
      setMeasureEnd({ x: snap(pos.x), y: snap(pos.y) });
    } else if (tool === 'dimension' && dimensionStartRef.current) {
      const pos = getPointerPos(e);
      const snapped = { x: snap(pos.x), y: snap(pos.y) };
      setMeasureEnd(snapped);
    } else if (tool === 'plumbing-line' && plumbingLineStart) {
      const pos = getPointerPos(e);
      setMeasureEnd({ x: snap(pos.x), y: snap(pos.y) });
    } else if (tool === 'line' && lineStartRef.current) {
      const pos = getPointerPos(e);
      setMeasureEnd({ x: snap(pos.x), y: snap(pos.y) });
    } else if (tool === 'move' && moveBasePoint) {
      // Update move preview with angle snapping for easier mobile use
      const pos = getPointerPos(e);
      
      // First check for snap points
      const snapPoint = findNearestSnapPoint(pos, 25 / scale);
      if (snapPoint) {
        setMovePreviewPoint(snapPoint);
        return;
      }
      
      // Calculate distance and angle from base point
      const dx = pos.x - moveBasePoint.x;
      const dy = pos.y - moveBasePoint.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 5) {
        // Too close, just use the position
        setMovePreviewPoint({ x: snap(pos.x), y: snap(pos.y) });
        return;
      }
      
      // Calculate angle and snap to 45-degree increments
      let angle = Math.atan2(dy, dx);
      let angleDeg = angle * 180 / Math.PI;
      
      // Snap angles: 0, 45, 90, 135, 180, -135, -90, -45
      const SNAP_ANGLES = [0, 45, 90, 135, 180, -180, -135, -90, -45];
      const SNAP_TOLERANCE = 8; // degrees - slightly larger for mobile
      
      let snapped = false;
      for (const snapAngle of SNAP_ANGLES) {
        if (Math.abs(angleDeg - snapAngle) < SNAP_TOLERANCE) {
          angleDeg = snapAngle;
          snapped = true;
          break;
        }
      }
      
      if (snapped) {
        // Use snapped angle with original distance
        const snapRad = angleDeg * Math.PI / 180;
        const newX = moveBasePoint.x + Math.cos(snapRad) * dist;
        const newY = moveBasePoint.y + Math.sin(snapRad) * dist;
        setMovePreviewPoint({ x: snap(newX), y: snap(newY), snapped: true, angle: angleDeg });
      } else {
        setMovePreviewPoint({ x: snap(pos.x), y: snap(pos.y), snapped: false });
      }
    } else if (tool === 'rotate' && rotateCenter && rotateStartAngle !== null) {
      // Update rotate preview with 45-degree snapping
      const pos = getPointerPos(e);
      let newAngle = Math.atan2(pos.y - rotateCenter.y, pos.x - rotateCenter.x);
      
      // Calculate angle delta from start
      let angleDelta = newAngle - rotateStartAngle;
      let angleDeltaDeg = (angleDelta * 180 / Math.PI);
      
      // Normalize to 0-360
      while (angleDeltaDeg < 0) angleDeltaDeg += 360;
      while (angleDeltaDeg >= 360) angleDeltaDeg -= 360;
      
      // Snap to 45-degree increments if close (within 5 degrees)
      const SNAP_ANGLES = [0, 45, 90, 135, 180, 225, 270, 315, 360];
      const SNAP_TOLERANCE = 5; // degrees
      
      for (const snapDeg of SNAP_ANGLES) {
        if (Math.abs(angleDeltaDeg - snapDeg) < SNAP_TOLERANCE) {
          angleDeltaDeg = snapDeg === 360 ? 0 : snapDeg;
          newAngle = rotateStartAngle + (angleDeltaDeg * Math.PI / 180);
          break;
        }
      }
      
      setRotatePreviewAngle(newAngle);
    }
  }, [isPanning, panStart, isDrawing, tool, drawStart, getPointerPos, offset, dragItem, dragOffset, measureStart, measureEnd, updateActiveFloor, selectedItems, plumbingLineStart, activeGrip, snap, snapAngle, pinchStart, scale, activeFloor.walls, moveBasePoint, rotateCenter, rotateStartAngle, findNearestSnapPoint, isMobile]);
  
  const handlePointerUp = useCallback(() => {
    if (isPanning) {
      setIsPanning(false);
      setPanStart(null);
    }
    
    if (pinchStart) {
      setPinchStart(null);
    }
    
    if (activeGrip) {
      setActiveGrip(null);
      setGripSnapTarget(null);
      setAllSnapPoints([]);
    }
    
    if (dragItem) {
      setDragItem(null);
      setWallDragStart(null); // Clear wall drag start point
      setWallDragSnap(null); // Clear wall drag visual feedback
    }
    
    if (isDrawing && drawStart && drawEnd) {
      if (tool === 'wall') {
        const length = distance(drawStart, drawEnd);
        if (length >= GRID_SIZE) {
          const wallConfig = WALL_THICKNESS_OPTIONS[wallType];
          const newWall = {
            id: generateId(),
            start: { ...drawStart },
            end: { ...drawEnd },
            type: wallType,
            height: wallConfig?.defaultHeight || DEFAULT_WALL_HEIGHT,
          };
          updateActiveFloor(f => ({ ...f, walls: [...f.walls, newWall] }));
        }
      } else if (tool === 'room') {
        const width = Math.abs(drawEnd.x - drawStart.x);
        const height = Math.abs(drawEnd.y - drawStart.y);
        if (width >= GRID_SIZE && height >= GRID_SIZE) {
          const newRoom = {
            id: generateId(),
            x: Math.min(drawStart.x, drawEnd.x),
            y: Math.min(drawStart.y, drawEnd.y),
            width,
            height,
            name: 'Room',
            color: ROOM_PRESETS[0].color,
          };
          updateActiveFloor(f => ({ ...f, rooms: [...f.rooms, newRoom] }));
          setShowRoomPanel(true);
        }
      } else if (tool === 'porch') {
        const width = Math.abs(drawEnd.x - drawStart.x);
        const height = Math.abs(drawEnd.y - drawStart.y);
        if (width >= GRID_SIZE && height >= GRID_SIZE) {
          const newPorch = {
            id: generateId(),
            x: Math.min(drawStart.x, drawEnd.x),
            y: Math.min(drawStart.y, drawEnd.y),
            width,
            height,
            type: porchType,
            name: PORCH_TYPES[porchType]?.name || 'Porch',
          };
          updateActiveFloor(f => ({ ...f, porches: [...(f.porches || []), newPorch] }));
        }
      } else if (tool === 'roof') {
        const width = Math.abs(drawEnd.x - drawStart.x);
        const height = Math.abs(drawEnd.y - drawStart.y);
        if (width >= GRID_SIZE && height >= GRID_SIZE) {
          const newRoof = {
            id: generateId(),
            x: Math.min(drawStart.x, drawEnd.x),
            y: Math.min(drawStart.y, drawEnd.y),
            width,
            height,
            type: roofType,
            pitch: roofPitch,
            overhang: roofOverhang,
            ridgeDirection: width > height ? 'horizontal' : 'vertical', // Ridge runs along longer dimension
          };
          updateActiveFloor(f => ({ ...f, roofs: [...(f.roofs || []), newRoof] }));
          setSelectedItems([{ type: 'roof', item: newRoof }]);
          setShowRoofPanel(true);
        }
      }
    }

    setIsDrawing(false);
    setDrawStart(null);
    setDrawEnd(null);
    setWallDrawSnap(null);
  }, [isPanning, isDrawing, tool, drawStart, drawEnd, wallType, porchType, roofType, roofPitch, roofOverhang, dragItem, activeGrip, updateActiveFloor]);
  
  // ============================================================================
  // ZOOM
  // ============================================================================
  const handleZoom = (delta) => {
    setScale(Math.max(0.25, Math.min(3, scale + delta)));
  };
  
  const handleWheel = useCallback((e) => {
    e.preventDefault();
    
    // Get cursor position relative to canvas
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate zoom
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newScale = Math.max(0.1, Math.min(5, scale * zoomFactor));
    
    // Calculate new offset to zoom towards cursor
    const scaleChange = newScale / scale;
    const newOffsetX = mouseX - (mouseX - offset.x) * scaleChange;
    const newOffsetY = mouseY - (mouseY - offset.y) * scaleChange;
    
    setScale(newScale);
    setOffset({ x: newOffsetX, y: newOffsetY });
  }, [scale, offset]);
  
  // ============================================================================
  // ITEM MANAGEMENT
  // ============================================================================
  const deleteSelected = () => {
    if (selectedItems.length === 0) return;
    
    selectedItems.forEach(sel => {
      if (sel.type === 'wall') {
        updateActiveFloor(f => ({
          ...f,
          walls: f.walls.filter(w => w.id !== sel.item.id),
          doors: f.doors.filter(d => d.wallId !== sel.item.id),
          windows: f.windows.filter(w => w.wallId !== sel.item.id),
        }));
      } else if (sel.type === 'furniture') {
        updateActiveFloor(f => ({
          ...f,
          furniture: f.furniture.filter(furn => furn.id !== sel.item.id),
        }));
      } else if (sel.type === 'room') {
        updateActiveFloor(f => ({
          ...f,
          rooms: f.rooms.filter(r => r.id !== sel.item.id),
        }));
      } else if (sel.type === 'stairs') {
        updateActiveFloor(f => ({
          ...f,
          stairs: f.stairs.filter(s => s.id !== sel.item.id),
        }));
      } else if (sel.type === 'electrical') {
        updateActiveFloor(f => ({
          ...f,
          electrical: f.electrical.filter(e => e.id !== sel.item.id),
        }));
      } else if (sel.type === 'plumbing') {
        updateActiveFloor(f => ({
          ...f,
          plumbing: f.plumbing.filter(p => p.id !== sel.item.id),
        }));
      } else if (sel.type === 'dimension') {
        updateActiveFloor(f => ({
          ...f,
          dimensions: (f.dimensions || []).filter(d => d.id !== sel.item.id),
        }));
      } else if (sel.type === 'door') {
        updateActiveFloor(f => ({
          ...f,
          doors: f.doors.filter(d => d.id !== sel.item.id),
        }));
      } else if (sel.type === 'window') {
        updateActiveFloor(f => ({
          ...f,
          windows: f.windows.filter(w => w.id !== sel.item.id),
        }));
      } else if (sel.type === 'text') {
        updateActiveFloor(f => ({
          ...f,
          texts: (f.texts || []).filter(t => t.id !== sel.item.id),
        }));
      } else if (sel.type === 'line') {
        updateActiveFloor(f => ({
          ...f,
          lines: (f.lines || []).filter(l => l.id !== sel.item.id),
        }));
      } else if (sel.type === 'polyline') {
        updateActiveFloor(f => ({
          ...f,
          polylines: (f.polylines || []).filter(p => p.id !== sel.item.id),
        }));
      } else if (sel.type === 'hatch') {
        updateActiveFloor(f => ({
          ...f,
          hatches: (f.hatches || []).filter(h => h.id !== sel.item.id),
        }));
      } else if (sel.type === 'porch') {
        updateActiveFloor(f => ({
          ...f,
          porches: (f.porches || []).filter(p => p.id !== sel.item.id),
        }));
      } else if (sel.type === 'roof') {
        updateActiveFloor(f => ({
          ...f,
          roofs: (f.roofs || []).filter(r => r.id !== sel.item.id),
        }));
      }
    });

    setSelectedItems([]);
    setShowWallEditor(false);
    setShowDoorWindowEditor(false);
    setShowRoofPanel(false);
  };
  
  // Copy selected items to clipboard
  const copySelected = () => {
    if (selectedItems.length === 0) return;
    
    const copiedItems = {
      walls: [],
      doors: [],
      windows: [],
      furniture: [],
      rooms: [],
      porches: [],
      lines: [],
      polylines: [],
      hatches: [],
    };
    
    // Calculate bounds for offset calculation
    let minX = Infinity, minY = Infinity;
    
    selectedItems.forEach(sel => {
      if (sel.type === 'wall') {
        copiedItems.walls.push({ ...sel.item });
        minX = Math.min(minX, sel.item.start.x, sel.item.end.x);
        minY = Math.min(minY, sel.item.start.y, sel.item.end.y);
        
        // Also copy attached doors and windows
        activeFloor.doors.filter(d => d.wallId === sel.item.id).forEach(d => {
          copiedItems.doors.push({ ...d, originalWallId: d.wallId });
        });
        activeFloor.windows.filter(w => w.wallId === sel.item.id).forEach(w => {
          copiedItems.windows.push({ ...w, originalWallId: w.wallId });
        });
      } else if (sel.type === 'furniture') {
        copiedItems.furniture.push({ ...sel.item });
        minX = Math.min(minX, sel.item.x);
        minY = Math.min(minY, sel.item.y);
      } else if (sel.type === 'room') {
        copiedItems.rooms.push({ ...sel.item });
        minX = Math.min(minX, sel.item.x);
        minY = Math.min(minY, sel.item.y);
      } else if (sel.type === 'porch') {
        copiedItems.porches.push({ ...sel.item });
        minX = Math.min(minX, sel.item.x);
        minY = Math.min(minY, sel.item.y);
      } else if (sel.type === 'line') {
        copiedItems.lines.push({ ...sel.item });
        minX = Math.min(minX, sel.item.start.x, sel.item.end.x);
        minY = Math.min(minY, sel.item.start.y, sel.item.end.y);
      } else if (sel.type === 'polyline') {
        copiedItems.polylines.push({ ...sel.item });
        sel.item.points.forEach(p => {
          minX = Math.min(minX, p.x);
          minY = Math.min(minY, p.y);
        });
      } else if (sel.type === 'hatch') {
        copiedItems.hatches.push({ ...sel.item });
        sel.item.points.forEach(p => {
          minX = Math.min(minX, p.x);
          minY = Math.min(minY, p.y);
        });
      }
    });
    
    setClipboard({
      items: copiedItems,
      originX: minX,
      originY: minY,
    });
  };
  
  // Paste items from clipboard
  const pasteClipboard = () => {
    if (!clipboard) return;
    
    // Paste at center of current view with offset
    const pasteOffsetX = 50;
    const pasteOffsetY = 50;
    
    // Create ID mapping for walls (so doors/windows can reference new walls)
    const wallIdMap = {};
    
    // Generate new walls with new IDs
    const newWalls = clipboard.items.walls.map(wall => {
      const newId = generateId();
      wallIdMap[wall.id] = newId;
      return {
        ...wall,
        id: newId,
        start: { x: wall.start.x + pasteOffsetX, y: wall.start.y + pasteOffsetY },
        end: { x: wall.end.x + pasteOffsetX, y: wall.end.y + pasteOffsetY },
      };
    });
    
    // Generate new doors with updated wall references
    const newDoors = clipboard.items.doors.map(door => ({
      ...door,
      id: generateId(),
      wallId: wallIdMap[door.originalWallId] || wallIdMap[door.wallId] || door.wallId,
    }));
    
    // Generate new windows with updated wall references
    const newWindows = clipboard.items.windows.map(win => ({
      ...win,
      id: generateId(),
      wallId: wallIdMap[win.originalWallId] || wallIdMap[win.wallId] || win.wallId,
    }));
    
    // Generate other items
    const newFurniture = clipboard.items.furniture.map(f => ({
      ...f,
      id: generateId(),
      x: f.x + pasteOffsetX,
      y: f.y + pasteOffsetY,
    }));
    
    const newRooms = clipboard.items.rooms.map(r => ({
      ...r,
      id: generateId(),
      x: r.x + pasteOffsetX,
      y: r.y + pasteOffsetY,
    }));
    
    const newPorches = clipboard.items.porches.map(p => ({
      ...p,
      id: generateId(),
      x: p.x + pasteOffsetX,
      y: p.y + pasteOffsetY,
    }));
    
    const newLines = clipboard.items.lines.map(l => ({
      ...l,
      id: generateId(),
      start: { x: l.start.x + pasteOffsetX, y: l.start.y + pasteOffsetY },
      end: { x: l.end.x + pasteOffsetX, y: l.end.y + pasteOffsetY },
    }));
    
    const newPolylines = clipboard.items.polylines.map(p => ({
      ...p,
      id: generateId(),
      points: p.points.map(pt => ({ x: pt.x + pasteOffsetX, y: pt.y + pasteOffsetY })),
    }));
    
    const newHatches = clipboard.items.hatches.map(h => ({
      ...h,
      id: generateId(),
      points: h.points.map(pt => ({ x: pt.x + pasteOffsetX, y: pt.y + pasteOffsetY })),
    }));
    
    // Add all items to floor
    updateActiveFloor(f => ({
      ...f,
      walls: [...f.walls, ...newWalls],
      doors: [...f.doors, ...newDoors],
      windows: [...f.windows, ...newWindows],
      furniture: [...f.furniture, ...newFurniture],
      rooms: [...f.rooms, ...newRooms],
      porches: [...(f.porches || []), ...newPorches],
      lines: [...(f.lines || []), ...newLines],
      polylines: [...(f.polylines || []), ...newPolylines],
      hatches: [...(f.hatches || []), ...newHatches],
    }));
    
    // Select pasted walls
    const newSelections = newWalls.map(w => ({ type: 'wall', item: w }));
    setSelectedItems(newSelections);
  };
  
  // Move selected items by delta
  const moveSelectedItems = (deltaX, deltaY) => {
    if (selectedItems.length === 0) return;

    // Batch all updates into a single state update
    const selectedIds = new Set();
    selectedItems.forEach(sel => {
      selectedIds.add(sel.type + ':' + sel.item.id);
    });

    updateActiveFloor(f => {
      const updatedFloor = { ...f };

      selectedItems.forEach(sel => {
        if (sel.type === 'wall') {
          updatedFloor.walls = updatedFloor.walls.map(w => w.id === sel.item.id ? {
            ...w,
            start: { x: w.start.x + deltaX, y: w.start.y + deltaY },
            end: { x: w.end.x + deltaX, y: w.end.y + deltaY },
          } : w);
        } else if (sel.type === 'furniture') {
          updatedFloor.furniture = updatedFloor.furniture.map(furn => furn.id === sel.item.id ? {
            ...furn,
            x: furn.x + deltaX,
            y: furn.y + deltaY,
          } : furn);
        } else if (sel.type === 'room') {
          updatedFloor.rooms = updatedFloor.rooms.map(r => r.id === sel.item.id ? {
            ...r,
            x: r.x + deltaX,
            y: r.y + deltaY,
          } : r);
        } else if (sel.type === 'stairs') {
          updatedFloor.stairs = updatedFloor.stairs.map(s => s.id === sel.item.id ? {
            ...s,
            x: s.x + deltaX,
            y: s.y + deltaY,
          } : s);
        } else if (sel.type === 'porch') {
          updatedFloor.porches = (updatedFloor.porches || []).map(p => p.id === sel.item.id ? {
            ...p,
            x: p.x + deltaX,
            y: p.y + deltaY,
          } : p);
        } else if (sel.type === 'line') {
          updatedFloor.lines = (updatedFloor.lines || []).map(l => l.id === sel.item.id ? {
            ...l,
            start: { x: l.start.x + deltaX, y: l.start.y + deltaY },
            end: { x: l.end.x + deltaX, y: l.end.y + deltaY },
          } : l);
        } else if (sel.type === 'text') {
          updatedFloor.texts = (updatedFloor.texts || []).map(t => t.id === sel.item.id ? {
            ...t,
            x: t.x + deltaX,
            y: t.y + deltaY,
          } : t);
        }
      });

      return updatedFloor;
    });
  };
  
  // Rotate selected items around a center point
  const rotateSelectedItems = (centerX, centerY, angleDelta) => {
    if (selectedItems.length === 0) return;
    
    const cos = Math.cos(angleDelta);
    const sin = Math.sin(angleDelta);
    
    const rotatePoint = (px, py) => {
      const dx = px - centerX;
      const dy = py - centerY;
      return {
        x: centerX + dx * cos - dy * sin,
        y: centerY + dx * sin + dy * cos
      };
    };
    
    selectedItems.forEach(sel => {
      if (sel.type === 'wall') {
        updateActiveFloor(f => ({
          ...f,
          walls: f.walls.map(w => {
            if (w.id !== sel.item.id) return w;
            const newStart = rotatePoint(w.start.x, w.start.y);
            const newEnd = rotatePoint(w.end.x, w.end.y);
            return { ...w, start: newStart, end: newEnd };
          })
        }));
      } else if (sel.type === 'furniture') {
        updateActiveFloor(f => ({
          ...f,
          furniture: f.furniture.map(furn => {
            if (furn.id !== sel.item.id) return furn;
            const centerPt = { x: furn.x + (furn.width || 40) / 2, y: furn.y + (furn.height || 40) / 2 };
            const newCenter = rotatePoint(centerPt.x, centerPt.y);
            return {
              ...furn,
              x: newCenter.x - (furn.width || 40) / 2,
              y: newCenter.y - (furn.height || 40) / 2,
              rotation: (furn.rotation || 0) + angleDelta * 180 / Math.PI,
            };
          })
        }));
      } else if (sel.type === 'room') {
        updateActiveFloor(f => ({
          ...f,
          rooms: f.rooms.map(r => {
            if (r.id !== sel.item.id) return r;
            const centerPt = { x: r.x + r.width / 2, y: r.y + r.height / 2 };
            const newCenter = rotatePoint(centerPt.x, centerPt.y);
            return { ...r, x: newCenter.x - r.width / 2, y: newCenter.y - r.height / 2 };
          })
        }));
      } else if (sel.type === 'stairs') {
        updateActiveFloor(f => ({
          ...f,
          stairs: f.stairs.map(s => {
            if (s.id !== sel.item.id) return s;
            const centerPt = { x: s.x + (s.width || 40) / 2, y: s.y + (s.height || 80) / 2 };
            const newCenter = rotatePoint(centerPt.x, centerPt.y);
            return {
              ...s,
              x: newCenter.x - (s.width || 40) / 2,
              y: newCenter.y - (s.height || 80) / 2,
              rotation: (s.rotation || 0) + angleDelta * 180 / Math.PI,
            };
          })
        }));
      } else if (sel.type === 'line') {
        updateActiveFloor(f => ({
          ...f,
          lines: (f.lines || []).map(l => {
            if (l.id !== sel.item.id) return l;
            const newStart = rotatePoint(l.start.x, l.start.y);
            const newEnd = rotatePoint(l.end.x, l.end.y);
            return { ...l, start: newStart, end: newEnd };
          })
        }));
      }
    });
  };
  
  const addFurniture = (template) => {
    // Furniture dimensions are in inches, convert to pixels (1 inch = GRID_SIZE/6 pixels = 2 pixels at default grid)
    const inchesToPixels = (inches) => inches * (GRID_SIZE / 6);
    const newFurniture = {
      id: generateId(),
      templateId: template.id,
      name: template.name,
      icon: template.icon,
      width: inchesToPixels(template.width),
      height: inchesToPixels(template.height),
      x: -offset.x / scale + dimensions.width / 2 / scale,
      y: -offset.y / scale + dimensions.height / 2 / scale,
      rotation: 0,
    };
    updateActiveFloor(f => ({ ...f, furniture: [...f.furniture, newFurniture] }));
  };
  
  const addStairs = (template) => {
    // Stairs dimensions are in inches, convert to pixels
    const inchesToPixels = (inches) => inches * (GRID_SIZE / 6);
    const newStairs = {
      id: generateId(),
      templateId: template.id,
      name: template.name,
      icon: template.icon,
      type: template.type,
      width: inchesToPixels(template.width),
      height: inchesToPixels(template.height),
      steps: template.steps,
      x: -offset.x / scale + dimensions.width / 2 / scale,
      y: -offset.y / scale + dimensions.height / 2 / scale,
      rotation: 0,
      goesTo: null, // Floor ID it connects to
    };
    updateActiveFloor(f => ({ ...f, stairs: [...(f.stairs || []), newStairs] }));
  };
  
  const addElectrical = (template) => {
    const newElectrical = {
      id: generateId(),
      templateId: template.id,
      name: template.name,
      icon: template.icon,
      symbol: template.symbol,
      category: template.category,
      x: -offset.x / scale + dimensions.width / 2 / scale,
      y: -offset.y / scale + dimensions.height / 2 / scale,
    };
    updateActiveFloor(f => ({ ...f, electrical: [...(f.electrical || []), newElectrical] }));
  };
  
  const addPlumbing = (template) => {
    if (template.lineType) {
      // Start drawing a line
      setPlumbingLineType(template.lineType);
      setTool('plumbing-line');
      return;
    }
    
    const newPlumbing = {
      id: generateId(),
      templateId: template.id,
      name: template.name,
      icon: template.icon,
      symbol: template.symbol,
      size: template.size || 16,
      x: -offset.x / scale + dimensions.width / 2 / scale,
      y: -offset.y / scale + dimensions.height / 2 / scale,
    };
    updateActiveFloor(f => ({ ...f, plumbing: [...(f.plumbing || []), newPlumbing] }));
  };
  
  const rotateItem = (id, itemType) => {
    if (itemType === 'furniture') {
      updateActiveFloor(f => ({
        ...f,
        furniture: f.furniture.map(furn => {
          if (furn.id === id) {
            return {
              ...furn,
              rotation: (furn.rotation + 90) % 360,
              width: furn.height,
              height: furn.width,
            };
          }
          return furn;
        }),
      }));
    } else if (itemType === 'stairs') {
      updateActiveFloor(f => ({
        ...f,
        stairs: f.stairs.map(s => {
          if (s.id === id) {
            return {
              ...s,
              rotation: (s.rotation + 90) % 360,
              width: s.height,
              height: s.width,
            };
          }
          return s;
        }),
      }));
    }
  };
  
  const updateWall = (id, updates) => {
    // Compute the new wall data
    let newWallData = null;
    
    updateActiveFloor(f => ({
      ...f,
      walls: f.walls.map(w => {
        if (w.id === id) {
          // If length is being updated, recalculate end point
          if (updates.length !== undefined) {
            const dx = w.end.x - w.start.x;
            const dy = w.end.y - w.start.y;
            const currentLength = Math.sqrt(dx * dx + dy * dy);
            const newLengthPx = feetToPixels(updates.length);
            const ratio = currentLength > 0 ? newLengthPx / currentLength : 1;
            newWallData = {
              ...w,
              end: {
                x: w.start.x + dx * ratio,
                y: w.start.y + dy * ratio,
              },
              height: updates.height !== undefined ? updates.height : w.height,
              type: updates.type !== undefined ? updates.type : w.type,
            };
            return newWallData;
          }
          newWallData = { ...w, ...updates };
          return newWallData;
        }
        return w;
      }),
    }));
    
    // Update selected item reference with the computed new wall data
    if (selectedItems[0]?.type === 'wall' && newWallData) {
      setSelectedItems([{ type: 'wall', item: newWallData }]);
    }
  };
  
  const updateRoom = (id, updates) => {
    updateActiveFloor(f => ({
      ...f,
      rooms: f.rooms.map(r => r.id === id ? { ...r, ...updates } : r),
    }));
  };
  
  const updateDoor = (id, updates) => {
    updateActiveFloor(f => ({
      ...f,
      doors: f.doors.map(d => d.id === id ? { ...d, ...updates } : d),
    }));
    // Also update selectedItems to keep UI in sync
    setSelectedItems(prev => prev.map(sel => 
      sel.type === 'door' && sel.item.id === id 
        ? { ...sel, item: { ...sel.item, ...updates } }
        : sel
    ));
  };
  
  const updateWindow = (id, updates) => {
    updateActiveFloor(f => ({
      ...f,
      windows: f.windows.map(w => w.id === id ? { ...w, ...updates } : w),
    }));
    // Also update selectedItems to keep UI in sync
    setSelectedItems(prev => prev.map(sel => 
      sel.type === 'window' && sel.item.id === id 
        ? { ...sel, item: { ...sel.item, ...updates } }
        : sel
    ));
  };
  
  const updateText = (id, updates) => {
    updateActiveFloor(f => ({
      ...f,
      texts: (f.texts || []).map(t => t.id === id ? { ...t, ...updates } : t),
    }));
  };
  
  const addText = (content, pos) => {
    const style = TEXT_STYLES[selectedTextStyle];
    const newText = {
      id: generateId(),
      content: content,
      x: pos.x,
      y: pos.y,
      style: selectedTextStyle,
      fontSize: style.fontSize,
      color: style.color,
      bold: style.fontWeight === 'bold',
      rotation: 0,
    };
    updateActiveFloor(f => ({
      ...f,
      texts: [...(f.texts || []), newText],
    }));
  };
  
  // Auto-generate dimensions for all walls
  const autoDimensionWalls = () => {
    const newDimensions = activeFloor.walls.map(wall => ({
      id: generateId(),
      start: { ...wall.start },
      end: { ...wall.end },
      style: dimensionStyle,
      offset: DIMENSION_STYLES[dimensionStyle].offset,
      label: '',
    }));
    
    updateActiveFloor(f => ({
      ...f,
      dimensions: [...(f.dimensions || []), ...newDimensions],
    }));
  };
  
  // Auto-generate dimensions for room perimeter
  const autoDimensionRoom = (room) => {
    const dims = [
      // Top
      { start: { x: room.x, y: room.y }, end: { x: room.x + room.width, y: room.y }, offset: -DIMENSION_STYLES[dimensionStyle].offset },
      // Right
      { start: { x: room.x + room.width, y: room.y }, end: { x: room.x + room.width, y: room.y + room.height }, offset: DIMENSION_STYLES[dimensionStyle].offset },
      // Bottom
      { start: { x: room.x + room.width, y: room.y + room.height }, end: { x: room.x, y: room.y + room.height }, offset: DIMENSION_STYLES[dimensionStyle].offset },
      // Left
      { start: { x: room.x, y: room.y + room.height }, end: { x: room.x, y: room.y }, offset: -DIMENSION_STYLES[dimensionStyle].offset },
    ];
    
    const newDimensions = dims.map(d => ({
      id: generateId(),
      ...d,
      style: dimensionStyle,
      label: '',
    }));
    
    updateActiveFloor(f => ({
      ...f,
      dimensions: [...(f.dimensions || []), ...newDimensions],
    }));
  };
  
  // Clear all dimensions
  const clearAllDimensions = () => {
    updateActiveFloor(f => ({
      ...f,
      dimensions: [],
    }));
  };
  
  // ============================================================================
  // SAVE / LOAD
  // ============================================================================
  const saveProject = () => {
    try {
      const data = {
        version: '3.1',
        floors,
        activeFloorId,
        layers,
        sheets,
        settings: {
          units,
          gridSize,
          angleSnap,
          showGrips,
        },
        savedAt: new Date().toISOString(),
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'floorplan-project.json';
      a.click();
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Error saving project:', err);
      alert('Failed to save project. Please try again.');
    }
  };
  
  const loadProject = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (!data || typeof data !== 'object') {
          throw new Error('Invalid JSON structure');
        }
        if (!data.floors || !Array.isArray(data.floors) || data.floors.length === 0) {
          throw new Error('No valid floors found in project file');
        }

        // Ensure all floors have the new properties
        const migratedFloors = data.floors.map(f => ({
          ...f,
          stairs: f.stairs || [],
          electrical: f.electrical || [],
          plumbing: f.plumbing || [],
          plumbingLines: f.plumbingLines || [],
          dimensions: f.dimensions || [],
          texts: f.texts || [],
        }));
        setFloors(migratedFloors);
        setActiveFloorId(data.activeFloorId || migratedFloors[0].id);
        saveToHistory(migratedFloors);

        // Restore new settings if present
        if (data.layers) setLayers(data.layers);
        if (data.sheets) setSheets(data.sheets);
        if (data.settings) {
          if (data.settings.units) setUnits(data.settings.units);
          if (data.settings.gridSize) setGridSize(data.settings.gridSize);
          if (data.settings.angleSnap) setAngleSnap(data.settings.angleSnap);
          if (data.settings.showGrips !== undefined) setShowGrips(data.settings.showGrips);
        }

        alert('Project loaded successfully!');
      } catch (err) {
        console.error('Error loading project:', err);
        alert(`Failed to load project: ${err.message || 'Invalid project file format'}`);
      }
    };
    reader.onerror = () => {
      alert('Failed to read file. Please try again.');
    };
    reader.readAsText(file);
  };
  
  const exportImage = () => {
    try {
      const canvas = canvasRef.current;
      if (!canvas) {
        alert('Canvas not available for export');
        return;
      }

      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'floorplan.png';
      a.click();
    } catch (err) {
      console.error('Error exporting image:', err);
      alert('Failed to export image. Please try again.');
    }
  };
  
  // ============================================================================
  // CALCULATE STATS
  // ============================================================================
  const stats = useMemo(() => {
    let totalArea = 0;
    activeFloor.rooms.forEach(room => {
      const widthFt = room.width / GRID_SIZE / 2;
      const heightFt = room.height / GRID_SIZE / 2;
      totalArea += widthFt * heightFt;
    });
    
    return {
      walls: activeFloor.walls.length,
      doors: activeFloor.doors.length,
      windows: activeFloor.windows.length,
      furniture: activeFloor.furniture.length,
      rooms: activeFloor.rooms.length,
      stairs: (activeFloor.stairs || []).length,
      electrical: (activeFloor.electrical || []).length,
      plumbing: (activeFloor.plumbing || []).length,
      dimensions: (activeFloor.dimensions || []).length,
      area: totalArea.toFixed(0),
    };
  }, [activeFloor]);
  
  // Get selected wall data
  const selectedWall = useMemo(() => {
    if (selectedItems[0]?.type === 'wall') {
      const wall = selectedItems[0].item;
      const length = distance(wall.start, wall.end);
      return {
        ...wall,
        lengthFeet: pixelsToFeet(length),
        heightFeet: inchesToFeet(wall.height || DEFAULT_WALL_HEIGHT),
      };
    }
    return null;
  }, [selectedItems]);
  
  // Find dimensions linked to the currently selected door/window
  const linkedDimensions = useMemo(() => {
    const selected = selectedItems[0];
    if (!selected || (selected.type !== 'door' && selected.type !== 'window')) {
      return [];
    }
    
    const itemId = selected.item.id;
    const itemType = selected.type;
    
    return (activeFloor.dimensions || []).filter(dim => {
      const startLinked = dim.startLink?.type === itemType && dim.startLink?.id === itemId;
      const endLinked = dim.endLink?.type === itemType && dim.endLink?.id === itemId;
      return startLinked || endLinked;
    });
  }, [selectedItems, activeFloor.dimensions]);
  
  // Update a linked dimension's offset
  const updateLinkedDimension = useCallback((dimId, newOffset) => {
    updateActiveFloor(f => ({
      ...f,
      dimensions: (f.dimensions || []).map(d =>
        d.id === dimId ? { ...d, offset: newOffset } : d
      )
    }));
  }, [updateActiveFloor]);
  
  // Delete a linked dimension
  const deleteLinkedDimension = useCallback((dimId) => {
    updateActiveFloor(f => ({
      ...f,
      dimensions: (f.dimensions || []).filter(d => d.id !== dimId)
    }));
  }, [updateActiveFloor]);
  
  // Move a linked door/window by changing dimension length
  const updateLinkedItemByDimension = useCallback((dim, newLengthFeet) => {
    const newLengthPx = feetToPixels(newLengthFeet);
    
    // Determine which end is linked to a moveable item (door/window)
    const startLink = dim.startLink;
    const endLink = dim.endLink;
    
    // Get the fixed point (the end that's linked to a wall or nothing)
    let fixedPoint, moveableLink;
    
    if (startLink?.type === 'door' || startLink?.type === 'window') {
      // Start is moveable, end is fixed
      moveableLink = startLink;
      fixedPoint = resolveLinkPoint(endLink, dim.end);
    } else if (endLink?.type === 'door' || endLink?.type === 'window') {
      // End is moveable, start is fixed
      moveableLink = endLink;
      fixedPoint = resolveLinkPoint(startLink, dim.start);
    } else {
      return; // No moveable item
    }
    
    // Find the item and its wall
    const itemType = moveableLink.type;
    const itemId = moveableLink.id;
    const edge = moveableLink.edge;
    
    const item = itemType === 'door' 
      ? activeFloor.doors.find(d => d.id === itemId)
      : activeFloor.windows.find(w => w.id === itemId);
    
    if (!item) return;
    
    const wall = activeFloor.walls.find(w => w.id === item.wallId);
    if (!wall) return;
    
    // Calculate wall direction
    const wallDx = wall.end.x - wall.start.x;
    const wallDy = wall.end.y - wall.start.y;
    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
    if (wallLength < 0.001) return;
    
    const unitX = wallDx / wallLength;
    const unitY = wallDy / wallLength;
    
    // Calculate where the edge should be
    // Direction from fixed point along the wall
    const currentPos = resolveLinkPoint(moveableLink, dim.start);
    const dirToFixed = {
      x: fixedPoint.x - currentPos.x,
      y: fixedPoint.y - currentPos.y
    };
    
    // Determine if we're measuring toward wall start or end
    const dot = dirToFixed.x * unitX + dirToFixed.y * unitY;
    const direction = dot > 0 ? 1 : -1;
    
    // New edge position
    const newEdgeX = fixedPoint.x - direction * unitX * newLengthPx;
    const newEdgeY = fixedPoint.y - direction * unitY * newLengthPx;
    
    // Calculate new center position based on edge
    const itemWidth = item.width || (itemType === 'door' ? 36 : 48);
    let newCenterX, newCenterY;
    
    if (edge === 'left') {
      newCenterX = newEdgeX + unitX * itemWidth / 2;
      newCenterY = newEdgeY + unitY * itemWidth / 2;
    } else if (edge === 'right') {
      newCenterX = newEdgeX - unitX * itemWidth / 2;
      newCenterY = newEdgeY - unitY * itemWidth / 2;
    } else {
      newCenterX = newEdgeX;
      newCenterY = newEdgeY;
    }
    
    // Convert center position to wall position (0-1)
    const t = ((newCenterX - wall.start.x) * wallDx + (newCenterY - wall.start.y) * wallDy) / (wallLength * wallLength);
    const newPosition = Math.max(0.05, Math.min(0.95, t));
    
    // Update the item
    if (itemType === 'door') {
      updateActiveFloor(f => ({
        ...f,
        doors: f.doors.map(d => d.id === itemId ? { ...d, position: newPosition } : d)
      }));
    } else {
      updateActiveFloor(f => ({
        ...f,
        windows: f.windows.map(w => w.id === itemId ? { ...w, position: newPosition } : w)
      }));
    }
  }, [activeFloor, resolveLinkPoint, updateActiveFloor]);
  
  // ============================================================================
  // PAPER CANVAS DRAWING
  // ============================================================================
  useEffect(() => {
    if (viewMode !== 'paper' || !activeSheet || !paperCanvasRef.current) return;
    
    const canvas = paperCanvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const w = canvas.width;
    const h = canvas.height;

    // Clear and fill white
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, w, h);
    
    // Draw border
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(24, 24, w - 48, h - 48);
    
    // Calculate architectural scale
    // 1/4" = 1' means 0.25 inches on paper represents 12 inches real
    // At 96 DPI: 0.25 * 96 = 24 pixels represents 12 inches
    // Our model uses SCALE = 10/3 pixels per inch
    // So drawScale = (paperInchesPerFoot * 96) / (realInchesPerFoot * SCALE)
    const scaleMap = {
      '1/8" = 1\'': 0.125 * 96 / (12 * (10/3)),
      '1/4" = 1\'': 0.25 * 96 / (12 * (10/3)),
      '3/8" = 1\'': 0.375 * 96 / (12 * (10/3)),
      '1/2" = 1\'': 0.5 * 96 / (12 * (10/3)),
      '1" = 1\'': 1 * 96 / (12 * (10/3)),
    };
    const drawScale = scaleMap[activeSheet.scale] || 0.06;
    
    // Calculate bounds of drawing
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    activeFloor.walls.forEach(wall => {
      minX = Math.min(minX, wall.start.x, wall.end.x);
      minY = Math.min(minY, wall.start.y, wall.end.y);
      maxX = Math.max(maxX, wall.start.x, wall.end.x);
      maxY = Math.max(maxY, wall.start.y, wall.end.y);
    });
    
    if (minX === Infinity) {
      // No walls - draw placeholder text
      ctx.fillStyle = '#999';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Draw walls in Model Space to see them here', w/2, h/2);
      return;
    }
    
    const drawingWidth = (maxX - minX) * drawScale;
    const drawingHeight = (maxY - minY) * drawScale;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // Drawing area (leave room for title block)
    const titleBlockWidth = 320;
    const margin = 40;
    const drawAreaWidth = w - margin * 2 - titleBlockWidth - 20;
    const drawAreaHeight = h - margin * 2;
    const drawAreaCenterX = margin + drawAreaWidth / 2;
    const drawAreaCenterY = h / 2;
    
    ctx.save();
    ctx.translate(drawAreaCenterX, drawAreaCenterY);
    ctx.scale(drawScale, drawScale);
    ctx.translate(-centerX, -centerY);
    
    // Draw walls
    activeFloor.walls.forEach(wall => {
      const thickness = WALL_THICKNESS_OPTIONS[wall.type]?.thickness || 8;
      ctx.strokeStyle = '#000';
      ctx.lineWidth = thickness;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(wall.start.x, wall.start.y);
      ctx.lineTo(wall.end.x, wall.end.y);
      ctx.stroke();
    });
    
    // Draw doors
    activeFloor.doors.forEach(door => {
      const wall = activeFloor.walls.find(w => w.id === door.wallId);
      if (!wall) return;
      
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const pos = { x: wall.start.x + dx * door.position, y: wall.start.y + dy * door.position };
      const angle = Math.atan2(dy, dx);
      const thickness = WALL_THICKNESS_OPTIONS[wall.type]?.thickness || 8;
      const doorWidth = door.width || 36;
      
      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.rotate(angle);
      
      // Clear opening
      ctx.fillStyle = '#fff';
      ctx.fillRect(-doorWidth/2 - 1, -thickness/2 - 4, doorWidth + 2, thickness + 8);
      
      // Door arc
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.arc(-doorWidth/2, thickness/2 + 2, doorWidth, -Math.PI/2, 0);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Door panel
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-doorWidth/2, thickness/2 + 2);
      ctx.lineTo(-doorWidth/2, thickness/2 + 2 - doorWidth);
      ctx.stroke();
      
      ctx.restore();
    });
    
    // Draw windows
    activeFloor.windows.forEach(win => {
      const wall = activeFloor.walls.find(w => w.id === win.wallId);
      if (!wall) return;
      
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const pos = { x: wall.start.x + dx * win.position, y: wall.start.y + dy * win.position };
      const angle = Math.atan2(dy, dx);
      const thickness = WALL_THICKNESS_OPTIONS[wall.type]?.thickness || 8;
      const winWidth = win.width || 48;
      
      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.rotate(angle);
      
      // Clear opening
      ctx.fillStyle = '#fff';
      ctx.fillRect(-winWidth/2, -thickness/2 - 2, winWidth, thickness + 4);
      
      // Window lines
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-winWidth/2, -thickness/2);
      ctx.lineTo(winWidth/2, -thickness/2);
      ctx.moveTo(-winWidth/2, thickness/2);
      ctx.lineTo(winWidth/2, thickness/2);
      ctx.moveTo(-winWidth/2, 0);
      ctx.lineTo(winWidth/2, 0);
      ctx.stroke();
      
      ctx.restore();
    });
    
    // Draw dimensions
    (activeFloor.dimensions || []).forEach(dim => {
      const dimStart = resolveLinkPoint(dim.startLink, dim.start);
      const dimEnd = resolveLinkPoint(dim.endLink, dim.end);
      const ddx = dimEnd.x - dimStart.x;
      const ddy = dimEnd.y - dimStart.y;
      const length = Math.sqrt(ddx * ddx + ddy * ddy);
      const angle = Math.atan2(ddy, ddx);
      const dimOffset = dim.offset || 0;
      
      const perpX = -Math.sin(angle) * dimOffset;
      const perpY = Math.cos(angle) * dimOffset;
      const start = { x: dimStart.x + perpX, y: dimStart.y + perpY };
      const end = { x: dimEnd.x + perpX, y: dimEnd.y + perpY };
      
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 0.5;
      
      // Extension lines
      ctx.beginPath();
      ctx.moveTo(dimStart.x, dimStart.y);
      ctx.lineTo(start.x, start.y);
      ctx.moveTo(dimEnd.x, dimEnd.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      
      // Dimension line
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      
      // Tick marks
      const tickSize = 5;
      const tickX = Math.sin(angle) * tickSize;
      const tickY = -Math.cos(angle) * tickSize;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(start.x - tickX, start.y - tickY);
      ctx.lineTo(start.x + tickX, start.y + tickY);
      ctx.moveTo(end.x - tickX, end.y - tickY);
      ctx.lineTo(end.x + tickX, end.y + tickY);
      ctx.stroke();
      
      // Text
      const midX = (start.x + end.x) / 2;
      const midY = (start.y + end.y) / 2;
      ctx.save();
      ctx.translate(midX, midY);
      let textAngle = angle;
      if (textAngle > Math.PI/2) textAngle -= Math.PI;
      if (textAngle < -Math.PI/2) textAngle += Math.PI;
      ctx.rotate(textAngle);
      ctx.fillStyle = '#fff';
      ctx.fillRect(-25, -10, 50, 16);
      ctx.fillStyle = '#000';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(formatMeasurement(pixelsToFeet(length)), 0, 0);
      ctx.restore();
    });
    
    ctx.restore();
    
    // Draw title block
    const tbX = w - margin - titleBlockWidth;
    const tbY = h - margin - 140;
    const tbW = titleBlockWidth;
    const tbH = 140;
    
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(tbX, tbY, tbW, tbH);
    
    // Title block content
    ctx.fillStyle = '#000';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(projectInfo.projectName || 'PROJECT NAME', tbX + tbW/2, tbY + 20);
    
    ctx.font = '10px Arial';
    ctx.fillText(projectInfo.clientName || '', tbX + tbW/2, tbY + 35);
    ctx.fillText(projectInfo.address || '', tbX + tbW/2, tbY + 50);
    
    // Divider
    ctx.beginPath();
    ctx.moveTo(tbX, tbY + 60);
    ctx.lineTo(tbX + tbW, tbY + 60);
    ctx.stroke();
    
    // Info grid
    ctx.font = '8px Arial';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#666';
    ctx.fillText('DRAWN BY', tbX + 10, tbY + 75);
    ctx.fillText('DATE', tbX + tbW/2 + 10, tbY + 75);
    ctx.fillText('SCALE', tbX + 10, tbY + 100);
    ctx.fillText('SHEET', tbX + tbW/2 + 10, tbY + 100);
    
    ctx.fillStyle = '#000';
    ctx.font = '10px Arial';
    ctx.fillText(projectInfo.drawnBy || '-', tbX + 10, tbY + 88);
    ctx.fillText(projectInfo.date || '-', tbX + tbW/2 + 10, tbY + 88);
    ctx.fillText(activeSheet.scale, tbX + 10, tbY + 113);
    ctx.font = 'bold 16px Arial';
    ctx.fillText(activeSheet.sheetNumber || 'A01', tbX + tbW/2 + 10, tbY + 115);
    
    // Divider
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(tbX, tbY + 120);
    ctx.lineTo(tbX + tbW, tbY + 120);
    ctx.moveTo(tbX + tbW/2, tbY + 60);
    ctx.lineTo(tbX + tbW/2, tbY + 120);
    ctx.stroke();
    
    // Sheet title
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(activeSheet.sheetTitle || 'FLOOR PLAN', tbX + tbW/2, tbY + 133);
    
  }, [viewMode, activeSheet, activeFloor, paperZoom, projectInfo, formatMeasurement, resolveLinkPoint]);

  // ============================================================================
  // ELEVATION RENDERING
  // ============================================================================
  useEffect(() => {
    if (viewMode !== 'elevations' || !elevationCanvasRef.current) return;

    const canvas = elevationCanvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const { width, height } = { width: canvas.width, height: canvas.height };

    // Clear canvas
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(0, 0, width, height);

    // Get all walls from active floor
    const walls = activeFloor.walls || [];
    if (walls.length === 0) {
      ctx.fillStyle = '#666';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('No walls to display', width / 2, height / 2);
      ctx.font = '14px Arial';
      ctx.fillText('Draw some walls in Model Space first', width / 2, height / 2 + 30);
      return;
    }

    // Determine wall orientation - horizontal vs vertical
    const isHorizontalWall = (wall) => {
      if (!wall.start || !wall.end) return false;
      const dx = Math.abs(wall.end.x - wall.start.x);
      const dy = Math.abs(wall.end.y - wall.start.y);
      return dx > dy; // Wall is more horizontal than vertical
    };

    // Filter walls based on elevation direction
    // North/South: horizontal walls, East/West: vertical walls
    const isHorizontalElevation = activeElevation === 'north' || activeElevation === 'south';

    const elevationWalls = walls.filter(wall => {
      if (!wall.start || !wall.end) return false;
      return isHorizontalElevation ? isHorizontalWall(wall) : !isHorizontalWall(wall);
    });

    if (elevationWalls.length === 0) {
      ctx.fillStyle = '#666';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`No ${activeElevation} facing walls found`, width / 2, height / 2);
      ctx.font = '14px Arial';
      ctx.fillText('Try a different direction or draw more walls', width / 2, height / 2 + 30);
      return;
    }

    // Calculate bounds - use X for horizontal walls, Y for vertical walls
    let minPos = Infinity, maxPos = -Infinity;
    elevationWalls.forEach(wall => {
      if (isHorizontalElevation) {
        minPos = Math.min(minPos, wall.start.x, wall.end.x);
        maxPos = Math.max(maxPos, wall.start.x, wall.end.x);
      } else {
        minPos = Math.min(minPos, wall.start.y, wall.end.y);
        maxPos = Math.max(maxPos, wall.start.y, wall.end.y);
      }
    });

    const elevationWidth = maxPos - minPos;
    // Wall height in same units as the grid (GRID_SIZE = 20 = 6 inches, so 10 feet = 200 units)
    const wallHeight = 200; // ~10 feet in grid units

    // Calculate max roof rise to include in height calculation
    const roofs = activeFloor.roofs || [];
    let maxRoofRise = 0;
    roofs.forEach(roof => {
      const pitchDef = ROOF_PITCHES[roof.pitch] || ROOF_PITCHES['6:12'];
      const roofSpan = isHorizontalElevation ? roof.height : roof.width;
      const roofRise = (roofSpan / 2) * (pitchDef.rise / pitchDef.run);
      maxRoofRise = Math.max(maxRoofRise, roofRise);
    });

    // Total height includes walls plus roof
    const totalHeight = wallHeight + maxRoofRise;

    // Scale to fit canvas with padding
    const padding = 80;
    const availableWidth = width - padding * 2;
    const availableHeight = height - padding * 2;
    const scaleX = availableWidth / Math.max(elevationWidth, 1);
    const scaleY = availableHeight / totalHeight;
    const elevScale = Math.min(scaleX, scaleY, 3); // Cap max scale

    // Center offset
    const scaledWidth = elevationWidth * elevScale;
    const scaledHeight = wallHeight * elevScale;
    const offsetX = (width - scaledWidth) / 2;
    const offsetY = height - padding - 20; // Ground line position

    // Draw title
    ctx.fillStyle = '#333';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`${activeElevation.toUpperCase()} ELEVATION`, width / 2, 35);

    // Draw ground line
    ctx.strokeStyle = '#654321';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(padding / 2, offsetY);
    ctx.lineTo(width - padding / 2, offsetY);
    ctx.stroke();

    // Draw ground texture
    ctx.fillStyle = '#8B7355';
    ctx.fillRect(padding / 2, offsetY, width - padding, 15);

    // Draw each wall
    elevationWalls.forEach(wall => {
      const wallLength = Math.sqrt(
        Math.pow(wall.end.x - wall.start.x, 2) + Math.pow(wall.end.y - wall.start.y, 2)
      );

      // Calculate wall X position on the elevation
      let wallStartPos;
      if (isHorizontalElevation) {
        wallStartPos = Math.min(wall.start.x, wall.end.x);
      } else {
        wallStartPos = Math.min(wall.start.y, wall.end.y);
      }

      const wallX = offsetX + (wallStartPos - minPos) * elevScale;
      const wallW = wallLength * elevScale;
      const wallH = wallHeight * elevScale;
      const wallY = offsetY - wallH;

      // Draw wall fill
      ctx.fillStyle = wall.type === 'exterior' ? '#d4c5b0' : '#e8e0d5';
      ctx.fillRect(wallX, wallY, wallW, wallH);

      // Draw siding pattern for exterior walls
      if (wall.type === 'exterior') {
        ctx.strokeStyle = 'rgba(0,0,0,0.12)';
        ctx.lineWidth = 1;
        const sidingSpacing = 12; // pixels
        for (let y = wallY + sidingSpacing; y < offsetY; y += sidingSpacing) {
          ctx.beginPath();
          ctx.moveTo(wallX, y);
          ctx.lineTo(wallX + wallW, y);
          ctx.stroke();
        }
      }

      // Draw wall outline
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.strokeRect(wallX, wallY, wallW, wallH);

      // Draw doors on this wall
      const wallDoors = (activeFloor.doors || []).filter(door => door.wallId === wall.id);
      wallDoors.forEach(door => {
        const doorWidthPx = (door.width || 36) * elevScale;
        const doorHeightPx = 140 * elevScale; // ~7 feet door height
        const doorPosRatio = door.position || 0.5;
        const doorX = wallX + doorPosRatio * wallW - doorWidthPx / 2;
        const doorY = offsetY - doorHeightPx;

        // Door frame
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(doorX, doorY, doorWidthPx, doorHeightPx);

        // Door panel detail
        ctx.strokeStyle = '#5d3a1a';
        ctx.lineWidth = 2;
        ctx.strokeRect(doorX + 4, doorY + 4, doorWidthPx - 8, doorHeightPx - 8);

        // Door panels
        const panelW = (doorWidthPx - 16) / 2;
        const panelH = (doorHeightPx - 20) / 2;
        ctx.strokeRect(doorX + 6, doorY + 8, panelW, panelH);
        ctx.strokeRect(doorX + 8 + panelW, doorY + 8, panelW, panelH);
        ctx.strokeRect(doorX + 6, doorY + 12 + panelH, panelW, panelH);
        ctx.strokeRect(doorX + 8 + panelW, doorY + 12 + panelH, panelW, panelH);

        // Door handle
        ctx.fillStyle = '#c0a000';
        ctx.beginPath();
        ctx.arc(doorX + doorWidthPx - 12, doorY + doorHeightPx / 2, 4, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw windows on this wall
      const wallWindows = (activeFloor.windows || []).filter(win => win.wallId === wall.id);
      wallWindows.forEach(win => {
        const winWidthPx = (win.width || 48) * elevScale;
        const winHeightPx = (win.height || 48) * elevScale;
        const sillHeightPx = (win.sillHeight || 36) * elevScale;
        const winPosRatio = win.position || 0.5;
        const winX = wallX + winPosRatio * wallW - winWidthPx / 2;
        const winY = offsetY - sillHeightPx - winHeightPx;

        // Window frame (white/cream)
        ctx.fillStyle = '#f0f8ff';
        ctx.fillRect(winX, winY, winWidthPx, winHeightPx);

        // Glass reflection effect
        ctx.fillStyle = 'rgba(135, 206, 250, 0.3)';
        ctx.fillRect(winX + 2, winY + 2, winWidthPx - 4, winHeightPx - 4);

        // Window frame outline
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.strokeRect(winX, winY, winWidthPx, winHeightPx);

        // Window muntins (cross pattern)
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(winX + winWidthPx / 2, winY);
        ctx.lineTo(winX + winWidthPx / 2, winY + winHeightPx);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(winX, winY + winHeightPx / 2);
        ctx.lineTo(winX + winWidthPx, winY + winHeightPx / 2);
        ctx.stroke();

        // Window sill
        ctx.fillStyle = '#ddd';
        ctx.fillRect(winX - 4, winY + winHeightPx, winWidthPx + 8, 6);
      });
    });

    // Draw roofs
    const roofs = activeFloor.roofs || [];
    roofs.forEach(roof => {
      const roofDef = ROOF_TYPES[roof.type] || ROOF_TYPES.gable;
      const pitchDef = ROOF_PITCHES[roof.pitch] || ROOF_PITCHES['6:12'];
      const overhang = (roof.overhang || 12) * elevScale;

      // Calculate roof position based on elevation direction
      let roofStartPos, roofEndPos;
      if (isHorizontalElevation) {
        // North/South elevation - roof spans X
        roofStartPos = roof.x;
        roofEndPos = roof.x + roof.width;
      } else {
        // East/West elevation - roof spans Y
        roofStartPos = roof.y;
        roofEndPos = roof.y + roof.height;
      }

      // Check if roof is visible in this elevation (within bounds)
      if (roofEndPos < minPos || roofStartPos > maxPos) return;

      const roofX = offsetX + (roofStartPos - minPos) * elevScale - overhang;
      const roofW = (roofEndPos - roofStartPos) * elevScale + overhang * 2;
      const roofBaseY = offsetY - wallHeight * elevScale;

      // Calculate roof peak height based on pitch
      const roofSpan = isHorizontalElevation ? roof.height : roof.width;
      const roofRise = (roofSpan / 2) * (pitchDef.rise / pitchDef.run) * elevScale;

      if (roof.type === 'gable' || roof.type === 'gambrel') {
        // Determine if we're viewing the gable end or the eave side
        const viewingGableEnd = (isHorizontalElevation && roof.ridgeDirection === 'horizontal') ||
                                (!isHorizontalElevation && roof.ridgeDirection === 'vertical');

        if (viewingGableEnd) {
          // Draw triangular gable end
          ctx.fillStyle = '#b8860b';
          ctx.beginPath();
          ctx.moveTo(roofX, roofBaseY);
          ctx.lineTo(roofX + roofW / 2, roofBaseY - roofRise);
          ctx.lineTo(roofX + roofW, roofBaseY);
          ctx.closePath();
          ctx.fill();

          // Gable outline
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Shingle lines
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          const shingleSpacing = 8;
          for (let i = 1; i < roofRise / shingleSpacing; i++) {
            const y = roofBaseY - i * shingleSpacing;
            const xOffset = i * shingleSpacing * (roofW / 2) / roofRise;
            ctx.beginPath();
            ctx.moveTo(roofX + xOffset, y);
            ctx.lineTo(roofX + roofW - xOffset, y);
            ctx.stroke();
          }
        } else {
          // Draw eave side (rectangular with slight slope indication)
          ctx.fillStyle = '#b8860b';
          ctx.fillRect(roofX, roofBaseY - 20, roofW, 20);

          // Roof edge/fascia
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(roofX, roofBaseY);
          ctx.lineTo(roofX + roofW, roofBaseY);
          ctx.stroke();

          // Shingle lines
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          for (let x = roofX + 15; x < roofX + roofW; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, roofBaseY - 20);
            ctx.lineTo(x, roofBaseY);
            ctx.stroke();
          }
        }
      } else if (roof.type === 'hip') {
        // Hip roof - always shows sloped sides
        ctx.fillStyle = '#b8860b';
        ctx.beginPath();
        ctx.moveTo(roofX, roofBaseY);
        ctx.lineTo(roofX + roofW * 0.2, roofBaseY - roofRise * 0.7);
        ctx.lineTo(roofX + roofW * 0.8, roofBaseY - roofRise * 0.7);
        ctx.lineTo(roofX + roofW, roofBaseY);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (roof.type === 'shed') {
        // Shed roof - single slope
        ctx.fillStyle = '#b8860b';
        ctx.beginPath();
        ctx.moveTo(roofX, roofBaseY);
        ctx.lineTo(roofX, roofBaseY - roofRise);
        ctx.lineTo(roofX + roofW, roofBaseY - roofRise * 0.3);
        ctx.lineTo(roofX + roofW, roofBaseY);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (roof.type === 'flat') {
        // Flat roof - just a cap
        ctx.fillStyle = '#808080';
        ctx.fillRect(roofX, roofBaseY - 10, roofW, 10);

        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.strokeRect(roofX, roofBaseY - 10, roofW, 10);
      }
    });

    // Draw scale reference
    ctx.fillStyle = '#666';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Scale: 1 grid = 6"`, 10, height - 10);

  }, [viewMode, activeElevation, activeFloor]);

  // Reset drawing states when tool changes
  const prevToolRef = useRef(tool);
  useEffect(() => {
    const prevTool = prevToolRef.current;
    prevToolRef.current = tool;
    
    // Only reset lineStart if switching AWAY from line tool
    if (prevTool === 'line' && tool !== 'line') {
      setLineStart(null);
      lineStartRef.current = null;
    }
    
    setMeasureEnd(null);
    if (tool !== 'polyline' && tool !== 'hatch' && tool !== 'freehand') {
      setPolylinePoints([]);
      setIsDrawingPolyline(false);
    }
  }, [tool]);
  
  // ============================================================================
  // CANVAS DRAWING
  // ============================================================================
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const { width, height } = dimensions;

    ctx.fillStyle = '#080c10';
    ctx.fillRect(0, 0, width, height);
    
    ctx.save();
    ctx.translate(offset.x, offset.y);
    ctx.scale(scale, scale);
    
    // Grid
    const gridExtent = 3000;
    ctx.strokeStyle = '#141c24';
    ctx.lineWidth = 0.5;
    
    for (let x = -gridExtent; x <= gridExtent; x += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(x, -gridExtent);
      ctx.lineTo(x, gridExtent);
      ctx.stroke();
    }
    for (let y = -gridExtent; y <= gridExtent; y += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(-gridExtent, y);
      ctx.lineTo(gridExtent, y);
      ctx.stroke();
    }
    
    ctx.strokeStyle = '#1c2830';
    ctx.lineWidth = 1;
    for (let x = -gridExtent; x <= gridExtent; x += GRID_SIZE * 5) {
      ctx.beginPath();
      ctx.moveTo(x, -gridExtent);
      ctx.lineTo(x, gridExtent);
      ctx.stroke();
    }
    for (let y = -gridExtent; y <= gridExtent; y += GRID_SIZE * 5) {
      ctx.beginPath();
      ctx.moveTo(-gridExtent, y);
      ctx.lineTo(gridExtent, y);
      ctx.stroke();
    }
    
    // Draw rooms
    activeFloor.rooms.forEach(room => {
      const isSelected = selectedItems.some(s => s.type === 'room' && s.item.id === room.id);
      
      ctx.fillStyle = room.color;
      ctx.fillRect(room.x, room.y, room.width, room.height);
      
      ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(255,255,255,0.2)';
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.setLineDash(isSelected ? [] : [5, 5]);
      ctx.strokeRect(room.x, room.y, room.width, room.height);
      ctx.setLineDash([]);
      
      // Auto-scale room labels for mobile readability
      const roomLabelScale = Math.max(isMobile ? 1.3 : 1.0, 1 / scale);
      const nameFontSize = Math.round(14 * roomLabelScale);
      const dimFontSize = Math.round(11 * roomLabelScale);
      
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.font = `${nameFontSize}px "Inter", sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText(room.name, room.x + room.width / 2, room.y + room.height / 2 - 8 * roomLabelScale);
      
      const widthFt = (room.width / GRID_SIZE / 2).toFixed(1);
      const heightFt = (room.height / GRID_SIZE / 2).toFixed(1);
      ctx.font = `${dimFontSize}px "SF Mono", monospace`;
      ctx.fillStyle = 'rgba(0,200,255,0.8)';
      ctx.fillText(`${formatMeasurement(widthFt)} √ó ${formatMeasurement(heightFt)}`, room.x + room.width / 2, room.y + room.height / 2 + 10 * roomLabelScale);
    });
    
    // Draw hatches
    if (layers.hatches?.visible) {
      (activeFloor.hatches || []).forEach(hatch => {
        const isSelected = selectedItems.some(s => s.type === 'hatch' && s.item.id === hatch.id);
        drawHatchPattern(ctx, hatch.points, hatch.pattern, hatch.scale || 1, isSelected ? 0.7 : 0.5);
        if (isSelected) {
          // Draw selection handles
          hatch.points.forEach(p => {
            ctx.fillStyle = '#00ffaa';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();
          });
        }
      });
    }
    
    // Draw porches
    if (layers.porches?.visible) {
      (activeFloor.porches || []).forEach(porch => {
        const isSelected = selectedItems.some(s => s.type === 'porch' && s.item.id === porch.id);
        const porchDef = PORCH_TYPES[porch.type] || PORCH_TYPES.open;
        
        // Fill
        ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.2)' : porchDef.color;
        ctx.fillRect(porch.x, porch.y, porch.width, porch.height);
        
        // Decking lines for deck type
        if (porch.type === 'deck') {
          ctx.strokeStyle = 'rgba(160,130,90,0.5)';
          ctx.lineWidth = 1;
          const spacing = 15;
          for (let x = porch.x + spacing; x < porch.x + porch.width; x += spacing) {
            ctx.beginPath();
            ctx.moveTo(x, porch.y);
            ctx.lineTo(x, porch.y + porch.height);
            ctx.stroke();
          }
        }
        
        // Screen pattern for screened porch
        if (porchDef.hasScreens) {
          ctx.strokeStyle = 'rgba(100,100,100,0.3)';
          ctx.lineWidth = 0.5;
          const gridSize = 8;
          for (let x = porch.x; x < porch.x + porch.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, porch.y);
            ctx.lineTo(x, porch.y + porch.height);
            ctx.stroke();
          }
          for (let y = porch.y; y < porch.y + porch.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(porch.x, y);
            ctx.lineTo(porch.x + porch.width, y);
            ctx.stroke();
          }
        }
        
        // Border
        ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(139,119,101,0.8)';
        ctx.lineWidth = isSelected ? 2 : 1.5;
        ctx.setLineDash(porchDef.hasRoof ? [] : [5, 5]);
        ctx.strokeRect(porch.x, porch.y, porch.width, porch.height);
        ctx.setLineDash([]);
        
        // Roof indication (diagonal lines in corners)
        if (porchDef.hasRoof) {
          ctx.strokeStyle = 'rgba(139,119,101,0.5)';
          ctx.lineWidth = 1;
          const roofSize = 20;
          // Top-left
          ctx.beginPath();
          ctx.moveTo(porch.x, porch.y + roofSize);
          ctx.lineTo(porch.x + roofSize, porch.y);
          ctx.stroke();
          // Top-right
          ctx.beginPath();
          ctx.moveTo(porch.x + porch.width - roofSize, porch.y);
          ctx.lineTo(porch.x + porch.width, porch.y + roofSize);
          ctx.stroke();
        }
        
        // Label
        ctx.font = 'bold 12px "SF Pro", system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = isSelected ? '#00ffaa' : 'rgba(139,119,101,0.9)';
        ctx.fillText(porch.name || porchDef.name, porch.x + porch.width / 2, porch.y + porch.height / 2);
        
        // Dimensions
        ctx.font = '10px "SF Mono", monospace';
        ctx.fillStyle = 'rgba(139,119,101,0.7)';
        const porchWFt = pixelsToFeet(porch.width);
        const porchHFt = pixelsToFeet(porch.height);
        ctx.fillText(`${formatMeasurement(porchWFt)} √ó ${formatMeasurement(porchHFt)}`, porch.x + porch.width / 2, porch.y + porch.height / 2 + 15);
      });
    }

    // Draw roofs
    if (layers.roofs?.visible) {
    (activeFloor.roofs || []).forEach(roof => {
      const isSelected = selectedItems.some(s => s.type === 'roof' && s.item.id === roof.id);
      const roofDef = ROOF_TYPES[roof.type] || ROOF_TYPES.gable;
      const pitchDef = ROOF_PITCHES[roof.pitch] || ROOF_PITCHES['6:12'];
      const overhang = (roof.overhang || 12) * (GRID_SIZE / 6) / 12; // Convert inches to pixels

      // Roof outline with overhang
      const roofX = roof.x - overhang;
      const roofY = roof.y - overhang;
      const roofW = roof.width + overhang * 2;
      const roofH = roof.height + overhang * 2;

      // Fill with roof color (semi-transparent)
      ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.15)' : 'rgba(139,90,43,0.1)';
      ctx.fillRect(roofX, roofY, roofW, roofH);

      // Draw roof pattern based on type
      ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(139,90,43,0.6)';
      ctx.lineWidth = isSelected ? 2 : 1;

      if (roof.type === 'gable' || roof.type === 'gambrel') {
        // Ridge line
        ctx.setLineDash([]);
        ctx.lineWidth = isSelected ? 3 : 2;
        if (roof.ridgeDirection === 'horizontal') {
          // Ridge runs horizontally (east-west)
          const ridgeY = roofY + roofH / 2;
          ctx.beginPath();
          ctx.moveTo(roofX, ridgeY);
          ctx.lineTo(roofX + roofW, ridgeY);
          ctx.stroke();

          // Slope lines from ridge to eaves
          ctx.lineWidth = 1;
          ctx.setLineDash([8, 4]);
          const slopeSpacing = 30;
          for (let x = roofX + slopeSpacing; x < roofX + roofW; x += slopeSpacing) {
            // North slope
            ctx.beginPath();
            ctx.moveTo(x, ridgeY);
            ctx.lineTo(x, roofY);
            ctx.stroke();
            // South slope
            ctx.beginPath();
            ctx.moveTo(x, ridgeY);
            ctx.lineTo(x, roofY + roofH);
            ctx.stroke();
          }
        } else {
          // Ridge runs vertically (north-south)
          const ridgeX = roofX + roofW / 2;
          ctx.beginPath();
          ctx.moveTo(ridgeX, roofY);
          ctx.lineTo(ridgeX, roofY + roofH);
          ctx.stroke();

          // Slope lines from ridge to eaves
          ctx.lineWidth = 1;
          ctx.setLineDash([8, 4]);
          const slopeSpacing = 30;
          for (let y = roofY + slopeSpacing; y < roofY + roofH; y += slopeSpacing) {
            // West slope
            ctx.beginPath();
            ctx.moveTo(ridgeX, y);
            ctx.lineTo(roofX, y);
            ctx.stroke();
            // East slope
            ctx.beginPath();
            ctx.moveTo(ridgeX, y);
            ctx.lineTo(roofX + roofW, y);
            ctx.stroke();
          }
        }
      } else if (roof.type === 'hip') {
        // Hip roof - slopes on all four sides
        ctx.setLineDash([]);
        ctx.lineWidth = isSelected ? 2 : 1.5;
        const centerX = roofX + roofW / 2;
        const centerY = roofY + roofH / 2;

        // Determine ridge based on shape
        if (roofW > roofH) {
          // Horizontal ridge
          const ridgeLen = (roofW - roofH) / 2;
          const ridgeStartX = centerX - ridgeLen;
          const ridgeEndX = centerX + ridgeLen;
          // Ridge line
          ctx.beginPath();
          ctx.moveTo(ridgeStartX, centerY);
          ctx.lineTo(ridgeEndX, centerY);
          ctx.stroke();
          // Hip lines to corners
          ctx.beginPath();
          ctx.moveTo(ridgeStartX, centerY);
          ctx.lineTo(roofX, roofY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(ridgeStartX, centerY);
          ctx.lineTo(roofX, roofY + roofH);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(ridgeEndX, centerY);
          ctx.lineTo(roofX + roofW, roofY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(ridgeEndX, centerY);
          ctx.lineTo(roofX + roofW, roofY + roofH);
          ctx.stroke();
        } else {
          // Vertical ridge or pyramid
          const ridgeLen = (roofH - roofW) / 2;
          const ridgeStartY = centerY - ridgeLen;
          const ridgeEndY = centerY + ridgeLen;
          if (ridgeLen > 0) {
            ctx.beginPath();
            ctx.moveTo(centerX, ridgeStartY);
            ctx.lineTo(centerX, ridgeEndY);
            ctx.stroke();
          }
          // Hip lines to corners
          ctx.beginPath();
          ctx.moveTo(centerX, ridgeStartY);
          ctx.lineTo(roofX, roofY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(centerX, ridgeStartY);
          ctx.lineTo(roofX + roofW, roofY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(centerX, ridgeEndY);
          ctx.lineTo(roofX, roofY + roofH);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(centerX, ridgeEndY);
          ctx.lineTo(roofX + roofW, roofY + roofH);
          ctx.stroke();
        }
      } else if (roof.type === 'shed') {
        // Shed roof - single slope
        ctx.setLineDash([8, 4]);
        ctx.lineWidth = 1;
        const slopeSpacing = 20;
        if (roof.ridgeDirection === 'horizontal') {
          for (let x = roofX + slopeSpacing; x < roofX + roofW; x += slopeSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, roofY);
            ctx.lineTo(x, roofY + roofH);
            ctx.stroke();
          }
          // Arrow indicating slope direction
          ctx.setLineDash([]);
          ctx.beginPath();
          ctx.moveTo(roofX + roofW / 2, roofY + 10);
          ctx.lineTo(roofX + roofW / 2, roofY + roofH - 10);
          ctx.lineTo(roofX + roofW / 2 - 8, roofY + roofH - 20);
          ctx.moveTo(roofX + roofW / 2, roofY + roofH - 10);
          ctx.lineTo(roofX + roofW / 2 + 8, roofY + roofH - 20);
          ctx.stroke();
        } else {
          for (let y = roofY + slopeSpacing; y < roofY + roofH; y += slopeSpacing) {
            ctx.beginPath();
            ctx.moveTo(roofX, y);
            ctx.lineTo(roofX + roofW, y);
            ctx.stroke();
          }
          // Arrow indicating slope direction
          ctx.setLineDash([]);
          ctx.beginPath();
          ctx.moveTo(roofX + 10, roofY + roofH / 2);
          ctx.lineTo(roofX + roofW - 10, roofY + roofH / 2);
          ctx.lineTo(roofX + roofW - 20, roofY + roofH / 2 - 8);
          ctx.moveTo(roofX + roofW - 10, roofY + roofH / 2);
          ctx.lineTo(roofX + roofW - 20, roofY + roofH / 2 + 8);
          ctx.stroke();
        }
      } else if (roof.type === 'flat') {
        // Flat roof - just outline with drainage pattern
        ctx.setLineDash([4, 4]);
        ctx.lineWidth = 0.5;
        // Grid pattern for flat roof
        const gridSpacing = 20;
        for (let x = roofX + gridSpacing; x < roofX + roofW; x += gridSpacing) {
          ctx.beginPath();
          ctx.moveTo(x, roofY);
          ctx.lineTo(x, roofY + roofH);
          ctx.stroke();
        }
        for (let y = roofY + gridSpacing; y < roofY + roofH; y += gridSpacing) {
          ctx.beginPath();
          ctx.moveTo(roofX, y);
          ctx.lineTo(roofX + roofW, y);
          ctx.stroke();
        }
      }

      ctx.setLineDash([]);

      // Outer border (eaves line)
      ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(139,90,43,0.8)';
      ctx.lineWidth = isSelected ? 2.5 : 2;
      ctx.strokeRect(roofX, roofY, roofW, roofH);

      // Building footprint (inner dashed line)
      ctx.strokeStyle = isSelected ? 'rgba(0,255,170,0.5)' : 'rgba(139,90,43,0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.strokeRect(roof.x, roof.y, roof.width, roof.height);
      ctx.setLineDash([]);

      // Label
      ctx.font = 'bold 11px "SF Pro", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = isSelected ? '#00ffaa' : 'rgba(139,90,43,0.9)';
      ctx.fillText(`${roofDef.label} Roof`, roof.x + roof.width / 2, roof.y + roof.height / 2 - 8);

      // Pitch and dimensions
      ctx.font = '10px "SF Mono", monospace';
      ctx.fillStyle = 'rgba(139,90,43,0.7)';
      ctx.fillText(`${pitchDef.label}`, roof.x + roof.width / 2, roof.y + roof.height / 2 + 6);
      const roofWFt = pixelsToFeet(roof.width);
      const roofHFt = pixelsToFeet(roof.height);
      ctx.fillText(`${formatMeasurement(roofWFt)} √ó ${formatMeasurement(roofHFt)}`, roof.x + roof.width / 2, roof.y + roof.height / 2 + 18);
    });
    }

    // Draw lines
    if (layers.lines?.visible) {
      (activeFloor.lines || []).forEach(line => {
        const isSelected = selectedItems.some(s => s.type === 'line' && s.item.id === line.id);
        const lineTypeDef = LINE_TYPES[line.lineType] || LINE_TYPES.solid;
        
        ctx.strokeStyle = isSelected ? '#00ffaa' : (line.color || '#aaaaaa');
        ctx.lineWidth = line.lineWeight || 1;
        ctx.setLineDash(lineTypeDef.dash);
        ctx.lineCap = 'round';
        
        ctx.beginPath();
        ctx.moveTo(line.start.x, line.start.y);
        ctx.lineTo(line.end.x, line.end.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw endpoints if selected
        if (isSelected) {
          ctx.fillStyle = '#00ffaa';
          ctx.beginPath();
          ctx.arc(line.start.x, line.start.y, 4, 0, Math.PI * 2);
          ctx.arc(line.end.x, line.end.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Draw polylines
      (activeFloor.polylines || []).forEach(poly => {
        const isSelected = selectedItems.some(s => s.type === 'polyline' && s.item.id === poly.id);
        const lineTypeDef = LINE_TYPES[poly.lineType] || LINE_TYPES.solid;
        
        if (poly.points.length < 2) return;
        
        ctx.strokeStyle = isSelected ? '#00ffaa' : (poly.color || '#aaaaaa');
        ctx.lineWidth = poly.lineWeight || 1;
        ctx.setLineDash(lineTypeDef.dash);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.beginPath();
        ctx.moveTo(poly.points[0].x, poly.points[0].y);
        for (let i = 1; i < poly.points.length; i++) {
          ctx.lineTo(poly.points[i].x, poly.points[i].y);
        }
        if (poly.closed) ctx.closePath();
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw points if selected
        if (isSelected) {
          poly.points.forEach(p => {
            ctx.fillStyle = '#00ffaa';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            ctx.fill();
          });
        }
      });
    }
    
    // Draw active polyline/hatch being drawn
    if (isDrawingPolyline && polylinePoints.length > 0) {
      const isHatch = tool === 'hatch';
      ctx.strokeStyle = isHatch ? '#66aa66' : '#aaaaaa';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      
      ctx.beginPath();
      ctx.moveTo(polylinePoints[0].x, polylinePoints[0].y);
      for (let i = 1; i < polylinePoints.length; i++) {
        ctx.lineTo(polylinePoints[i].x, polylinePoints[i].y);
      }
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw points
      polylinePoints.forEach((p, i) => {
        ctx.fillStyle = i === 0 && isHatch ? '#00ff00' : '#00c8ff';
        ctx.beginPath();
        ctx.arc(p.x, p.y, i === 0 ? 6 : 4, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Hint for closing hatch
      if (isHatch && polylinePoints.length >= 3) {
        ctx.font = '10px sans-serif';
        ctx.fillStyle = '#00ff00';
        ctx.textAlign = 'center';
        ctx.fillText('Click first point to close', polylinePoints[0].x, polylinePoints[0].y - 15);
      }
    }
    
    // Draw plumbing lines
    (activeFloor.plumbingLines || []).forEach(line => {
      ctx.strokeStyle = line.type === 'hot' ? '#ff6666' : 
                        line.type === 'cold' ? '#6666ff' : 
                        line.type === 'drain' ? '#666666' : '#996633';
      ctx.lineWidth = line.type === 'drain' ? 4 : 2;
      ctx.setLineDash(line.type === 'vent' ? [5, 5] : []);
      ctx.beginPath();
      ctx.moveTo(line.start.x, line.start.y);
      ctx.lineTo(line.end.x, line.end.y);
      ctx.stroke();
      ctx.setLineDash([]);
    });
    
    // Draw dimension lines (architectural style)
    if (showDimensions) {
      (activeFloor.dimensions || []).forEach(dim => {
        const isSelected = selectedItems.some(s => s.type === 'dimension' && s.item.id === dim.id);
        const style = DIMENSION_STYLES[dim.style] || DIMENSION_STYLES.standard;
        
        // Auto-scale dimensions to stay readable regardless of zoom
        // Minimum scale factor ensures readability on mobile when zoomed out
        const minScaleFactor = isMobile ? 1.5 : 1.0;
        const scaleFactor = Math.max(minScaleFactor, 1 / scale);
        const scaledFontSize = style.fontSize * scaleFactor;
        const scaledTickSize = style.tickSize * scaleFactor;
        const scaledLineWidth = Math.max(1.5, 1.5 * scaleFactor);
        
        // Resolve linked points (doors/windows that may have moved)
        const dimStart = resolveLinkPoint(dim.startLink, dim.start);
        const dimEnd = resolveLinkPoint(dim.endLink, dim.end);
        
        const dx = dimEnd.x - dimStart.x;
        const dy = dimEnd.y - dimStart.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        // Calculate perpendicular offset direction
        const perpX = -Math.sin(angle) * (dim.offset || 0);
        const perpY = Math.cos(angle) * (dim.offset || 0);
        
        // Offset points
        const start = { x: dimStart.x + perpX, y: dimStart.y + perpY };
        const end = { x: dimEnd.x + perpX, y: dimEnd.y + perpY };
        
        ctx.save();
        
        // Show link indicator for linked dimensions
        if (dim.startLink || dim.endLink) {
          ctx.fillStyle = 'rgba(0,200,255,0.3)';
          if (dim.startLink) {
            ctx.beginPath();
            ctx.arc(dimStart.x, dimStart.y, 5 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
          }
          if (dim.endLink) {
            ctx.beginPath();
            ctx.arc(dimEnd.x, dimEnd.y, 5 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Extension lines (from original points to dimension line)
        ctx.strokeStyle = isSelected ? '#00ffaa' : style.color;
        ctx.lineWidth = scaledLineWidth * 0.7;
        ctx.setLineDash([]);
        
        // Extension line 1
        ctx.beginPath();
        ctx.moveTo(dimStart.x, dimStart.y);
        ctx.lineTo(start.x + Math.sin(angle) * 4 * scaleFactor, start.y - Math.cos(angle) * 4 * scaleFactor);
        ctx.stroke();
        
        // Extension line 2
        ctx.beginPath();
        ctx.moveTo(dimEnd.x, dimEnd.y);
        ctx.lineTo(end.x + Math.sin(angle) * 4 * scaleFactor, end.y - Math.cos(angle) * 4 * scaleFactor);
        ctx.stroke();
        
        // Main dimension line
        ctx.lineWidth = isSelected ? scaledLineWidth * 1.3 : scaledLineWidth;
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        
        // Tick marks at ends
        const tickX = Math.sin(angle) * scaledTickSize;
        const tickY = -Math.cos(angle) * scaledTickSize;
        
        ctx.lineWidth = scaledLineWidth * 1.3;
        ctx.beginPath();
        ctx.moveTo(start.x - tickX, start.y - tickY);
        ctx.lineTo(start.x + tickX, start.y + tickY);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(end.x - tickX, end.y - tickY);
        ctx.lineTo(end.x + tickX, end.y + tickY);
        ctx.stroke();
        
        // Dimension text
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        const lengthFeet = pixelsToFeet(length);
        const labelText = dim.label || formatMeasurement(lengthFeet);
        
        ctx.save();
        ctx.translate(midX, midY);
        
        // Rotate text to be readable
        let textAngle = angle;
        if (textAngle > Math.PI / 2) textAngle -= Math.PI;
        if (textAngle < -Math.PI / 2) textAngle += Math.PI;
        ctx.rotate(textAngle);
        
        // Background for text
        ctx.font = `bold ${scaledFontSize}px "SF Mono", monospace`;
        const textWidth = ctx.measureText(labelText).width;
        ctx.fillStyle = 'rgba(8,12,16,0.9)';
        ctx.fillRect(-textWidth / 2 - 6 * scaleFactor, -scaledFontSize / 2 - 3 * scaleFactor, textWidth + 12 * scaleFactor, scaledFontSize + 6 * scaleFactor);
        
        // Text
        ctx.fillStyle = isSelected ? '#00ffaa' : style.color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(labelText, 0, 0);
        
        ctx.restore();
        ctx.restore();
      });
      
      // Auto-generate wall dimensions if enabled
      if (autoDimensions) {
        activeFloor.walls.forEach(wall => {
          // Already showing on wall itself, skip auto-dimensions
        });
      }
    }
    
    // Draw snap points when dimension tool is active
    if (tool === 'dimension') {
      ctx.fillStyle = 'rgba(0,200,255,0.4)';
      
      // Wall endpoints
      activeFloor.walls.forEach(wall => {
        ctx.beginPath();
        ctx.arc(wall.start.x, wall.start.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(wall.end.x, wall.end.y, 6, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Door centers
      ctx.fillStyle = 'rgba(255,170,0,0.5)';
      activeFloor.doors.forEach(door => {
        const wall = activeFloor.walls.find(w => w.id === door.wallId);
        if (wall) {
          const dx = wall.end.x - wall.start.x;
          const dy = wall.end.y - wall.start.y;
          const doorCenter = {
            x: wall.start.x + dx * door.position,
            y: wall.start.y + dy * door.position
          };
          ctx.beginPath();
          ctx.arc(doorCenter.x, doorCenter.y, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Window centers
      ctx.fillStyle = 'rgba(0,255,170,0.5)';
      activeFloor.windows.forEach(win => {
        const wall = activeFloor.walls.find(w => w.id === win.wallId);
        if (wall) {
          const dx = wall.end.x - wall.start.x;
          const dy = wall.end.y - wall.start.y;
          const winCenter = {
            x: wall.start.x + dx * win.position,
            y: wall.start.y + dy * win.position
          };
          ctx.beginPath();
          ctx.arc(winCenter.x, winCenter.y, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }
    
    // Draw dimension line in progress
    if (dimensionStart && tool === 'dimension') {
      const endPos = measureEnd || dimensionStart;
      const style = DIMENSION_STYLES[dimensionStyle];
      const dx = endPos.x - dimensionStart.x;
      const dy = endPos.y - dimensionStart.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      
      if (length > 5) { // Only draw if there's some distance
        const angle = Math.atan2(dy, dx);
        const offset = style.offset;
        
        const perpX = -Math.sin(angle) * offset;
        const perpY = Math.cos(angle) * offset;
        
        const start = { x: dimensionStart.x + perpX, y: dimensionStart.y + perpY };
        const end = { x: endPos.x + perpX, y: endPos.y + perpY };
        
        ctx.strokeStyle = style.color;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 5]);
        
        // Extension lines
        ctx.beginPath();
        ctx.moveTo(dimensionStart.x, dimensionStart.y);
        ctx.lineTo(start.x, start.y);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(endPos.x, endPos.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        
        // Main line
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Start point marker
        ctx.fillStyle = style.color;
        ctx.beginPath();
        ctx.arc(dimensionStart.x, dimensionStart.y, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Preview text
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        ctx.fillStyle = style.color;
        ctx.font = `bold ${style.fontSize}px "SF Mono", monospace`;
        ctx.textAlign = 'center';
        ctx.fillText(formatMeasurement(pixelsToFeet(length)), midX, midY - 10);
      } else {
        // Just show start point
        ctx.fillStyle = DIMENSION_STYLES[dimensionStyle].color;
        ctx.beginPath();
        ctx.arc(dimensionStart.x, dimensionStart.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Draw line in progress
    if (lineStart && tool === 'line') {
      const endPos = measureEnd || lineStart;
      const lineTypeDef = LINE_TYPES[lineType] || LINE_TYPES.solid;
      
      ctx.strokeStyle = '#aaaaaa';
      ctx.lineWidth = lineWeight || 1;
      ctx.setLineDash(lineTypeDef.dash.length > 0 ? lineTypeDef.dash : [5, 5]);
      ctx.lineCap = 'round';
      
      ctx.beginPath();
      ctx.moveTo(lineStart.x, lineStart.y);
      ctx.lineTo(endPos.x, endPos.y);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Start point marker
      ctx.fillStyle = '#00c8ff';
      ctx.beginPath();
      ctx.arc(lineStart.x, lineStart.y, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Length indicator
      const length = distance(lineStart, endPos);
      if (length > 10) {
        const midX = (lineStart.x + endPos.x) / 2;
        const midY = (lineStart.y + endPos.y) / 2;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(midX - 30, midY - 20, 60, 16);
        ctx.fillStyle = '#aaaaaa';
        ctx.font = 'bold 11px "SF Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(formatMeasurement(pixelsToFeet(length)), midX, midY - 8);
      }
    }
    
    // Draw walls
    if (layers.walls.visible) {
      activeFloor.walls.forEach(wall => {
        const isSelected = selectedItems.some(s => s.type === 'wall' && s.item.id === wall.id);
        const thickness = WALL_THICKNESS_OPTIONS[wall.type]?.thickness || 8;
        const wallConfig = WALL_LAYERS[wall.type] || WALL_LAYERS['interior'];
        
        const dx = wall.end.x - wall.start.x;
        const dy = wall.end.y - wall.start.y;
        const wallLength = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        ctx.save();
        ctx.translate(wall.start.x, wall.start.y);
        ctx.rotate(angle);
        
        if (wallDetailLevel === 'simple') {
          // Simple mode - just solid fill (original behavior)
          ctx.strokeStyle = 'rgba(0,200,255,0.15)';
          ctx.lineWidth = thickness + 8;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(wallLength, 0);
          ctx.stroke();
          
          ctx.strokeStyle = isSelected ? '#00ffaa' : (wall.type?.includes('exterior') ? '#f0f8ff' : '#c0d0e0');
          ctx.lineWidth = thickness;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(wallLength, 0);
          ctx.stroke();
        } else if (wallDetailLevel === 'standard') {
          // Standard mode - show layer outlines
          const totalThickness = wallConfig.layers.reduce((sum, l) => sum + l.thickness, 0);
          const scaleFactor = thickness / totalThickness;
          let yOffset = -thickness / 2;
          
          // Draw each layer as a simple colored band
          wallConfig.layers.forEach(layer => {
            const layerThickness = layer.thickness * scaleFactor;
            ctx.fillStyle = isSelected ? adjustColor(layer.color, 30) : layer.color;
            ctx.fillRect(0, yOffset, wallLength, layerThickness);
            yOffset += layerThickness;
          });
          
          // Draw outline
          ctx.strokeStyle = isSelected ? '#00ffaa' : '#888';
          ctx.lineWidth = 1;
          ctx.strokeRect(0, -thickness / 2, wallLength, thickness);
          
          // Draw layer separators
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 0.5;
          yOffset = -thickness / 2;
          wallConfig.layers.forEach((layer, i) => {
            if (i > 0) {
              ctx.beginPath();
              ctx.moveTo(0, yOffset);
              ctx.lineTo(wallLength, yOffset);
              ctx.stroke();
            }
            yOffset += layer.thickness * scaleFactor;
          });
        } else if (wallDetailLevel === 'detailed') {
          // Detailed mode - full construction with patterns and studs
          const totalThickness = wallConfig.layers.reduce((sum, l) => sum + l.thickness, 0);
          const scaleFactor = thickness / totalThickness;

          if (renderMode === 'linework') {
            // LINE WORK MODE - Clean CAD-style drawing with hatches
            // Draw wall as outline with layer divisions and CAD-standard hatches

            // Background fill (white/light for paper-like appearance)
            ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.1)' : '#1a1a1a';
            ctx.fillRect(0, -thickness / 2, wallLength, thickness);

            // Draw layer divisions as thin lines
            let yOffset = -thickness / 2;
            ctx.strokeStyle = isSelected ? '#00ffaa' : '#666';
            ctx.lineWidth = 0.5;
            wallConfig.layers.forEach((layer, i) => {
              const layerThickness = layer.thickness * scaleFactor;
              if (i > 0) {
                ctx.beginPath();
                ctx.moveTo(0, yOffset);
                ctx.lineTo(wallLength, yOffset);
                ctx.stroke();
              }

              // Draw CAD-standard hatches for each layer type
              ctx.save();
              ctx.beginPath();
              ctx.rect(0, yOffset, wallLength, layerThickness);
              ctx.clip();

              if (layer.pattern === 'siding' || layer.pattern === 'plywood') {
                // Diagonal hatch for wood/siding (45 degrees)
                ctx.strokeStyle = isSelected ? 'rgba(0,255,170,0.4)' : 'rgba(100,100,100,0.5)';
                ctx.lineWidth = 0.5;
                const spacing = 4;
                for (let x = -wallLength; x < wallLength * 2; x += spacing) {
                  ctx.beginPath();
                  ctx.moveTo(x, yOffset);
                  ctx.lineTo(x + layerThickness, yOffset + layerThickness);
                  ctx.stroke();
                }
              } else if (layer.pattern === 'insulation') {
                // X-hatch for insulation
                ctx.strokeStyle = isSelected ? 'rgba(0,255,170,0.3)' : 'rgba(100,100,100,0.4)';
                ctx.lineWidth = 0.3;
                const spacing = 6;
                // Forward diagonal
                for (let x = -wallLength; x < wallLength * 2; x += spacing) {
                  ctx.beginPath();
                  ctx.moveTo(x, yOffset);
                  ctx.lineTo(x + layerThickness, yOffset + layerThickness);
                  ctx.stroke();
                }
                // Back diagonal
                for (let x = -wallLength; x < wallLength * 2; x += spacing) {
                  ctx.beginPath();
                  ctx.moveTo(x + layerThickness, yOffset);
                  ctx.lineTo(x, yOffset + layerThickness);
                  ctx.stroke();
                }
              } else if (layer.pattern === 'drywall') {
                // Stipple/dots for drywall
                ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.3)' : 'rgba(100,100,100,0.3)';
                const spacing = 8;
                for (let x = spacing/2; x < wallLength; x += spacing) {
                  for (let dy = spacing/2; dy < layerThickness; dy += spacing) {
                    ctx.beginPath();
                    ctx.arc(x, yOffset + dy, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                  }
                }
              } else if (layer.pattern === 'cavity') {
                // Empty cavity - no fill
              }

              ctx.restore();
              yOffset += layerThickness;
            });

            // Draw studs as simple rectangles with X inside
            if (wallConfig.studs) {
              const studSpacing = wallConfig.studs.spacing * (GRID_SIZE / 6) / 12 * scaleFactor;
              const studWidth = wallConfig.studs.width * (GRID_SIZE / 6) / 12 * scaleFactor;

              let cavityStart = -thickness / 2;
              let cavityThickness = 0;
              wallConfig.layers.forEach(layer => {
                const layerThick = layer.thickness * scaleFactor;
                if (layer.pattern === 'cavity' || layer.pattern === 'insulation') {
                  cavityThickness = layerThick;
                } else if (cavityThickness === 0) {
                  cavityStart += layerThick;
                }
              });

              ctx.strokeStyle = isSelected ? '#00ffaa' : '#888';
              ctx.lineWidth = 0.75;

              // End studs
              ctx.strokeRect(0, cavityStart, studWidth, cavityThickness);
              ctx.strokeRect(wallLength - studWidth, cavityStart, studWidth, cavityThickness);

              // Interior studs
              for (let x = studSpacing; x < wallLength - studWidth; x += studSpacing) {
                ctx.strokeRect(x - studWidth / 2, cavityStart, studWidth, cavityThickness);
              }
            }

            // Wall outline
            ctx.strokeStyle = isSelected ? '#00ffaa' : '#aaa';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(0, -thickness / 2, wallLength, thickness);

          } else {
            // REALISTIC MODE - Full color with textures
            let yOffset = -thickness / 2;

            // Draw each layer with realistic colors and patterns
            wallConfig.layers.forEach(layer => {
              const layerThickness = layer.thickness * scaleFactor;

              ctx.save();
              ctx.translate(0, yOffset);

              // Base fill with realistic color
              ctx.fillStyle = isSelected ? adjustColor(layer.color, 20) : layer.color;
              ctx.fillRect(0, 0, wallLength, layerThickness);

              // Draw pattern based on layer type
              if (layer.pattern === 'siding') {
                // Horizontal siding lines with shadow effect
                ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                ctx.lineWidth = 0.75;
                const lineSpacing = Math.max(2, layerThickness / 3);
                for (let y = lineSpacing; y < layerThickness; y += lineSpacing) {
                  ctx.beginPath();
                  ctx.moveTo(0, y);
                  ctx.lineTo(wallLength, y);
                  ctx.stroke();
                  // Highlight below each line
                  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                  ctx.beginPath();
                  ctx.moveTo(0, y + 0.5);
                  ctx.lineTo(wallLength, y + 0.5);
                  ctx.stroke();
                  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                }
              } else if (layer.pattern === 'plywood') {
                // Wood grain with panel joints
                ctx.strokeStyle = 'rgba(101,67,33,0.4)';
                ctx.lineWidth = 0.5;
                // Grain lines
                for (let y = 2; y < layerThickness; y += 3) {
                  ctx.beginPath();
                  ctx.moveTo(0, y + Math.sin(y) * 0.5);
                  ctx.lineTo(wallLength, y + Math.sin(y + wallLength * 0.01) * 0.5);
                  ctx.stroke();
                }
                // Panel joints every 48" (4 feet)
                ctx.strokeStyle = 'rgba(50,30,10,0.5)';
                ctx.lineWidth = 1;
                const panelWidth = 48 * (GRID_SIZE / 6) / 12;
                for (let x = panelWidth; x < wallLength; x += panelWidth) {
                  ctx.beginPath();
                  ctx.moveTo(x, 0);
                  ctx.lineTo(x, layerThickness);
                  ctx.stroke();
                }
              } else if (layer.pattern === 'insulation') {
                // Fluffy insulation texture
                ctx.fillStyle = 'rgba(255,200,220,0.3)';
                const blobSize = 4;
                for (let x = 0; x < wallLength; x += blobSize * 1.5) {
                  for (let y = 0; y < layerThickness; y += blobSize) {
                    const offsetX = (y / blobSize % 2) * blobSize * 0.5;
                    ctx.beginPath();
                    ctx.arc(x + offsetX, y + blobSize/2, blobSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                  }
                }
              } else if (layer.pattern === 'drywall') {
                // Subtle texture for drywall
                ctx.fillStyle = 'rgba(200,200,200,0.1)';
                for (let x = 0; x < wallLength; x += 12) {
                  for (let y = 0; y < layerThickness; y += 12) {
                    ctx.fillRect(x, y, 1, 1);
                  }
                }
              } else if (layer.pattern === 'cavity') {
                // Dark cavity
                ctx.fillStyle = isSelected ? '#2a2a2a' : '#0a0a0a';
                ctx.fillRect(0, 0, wallLength, layerThickness);
              }

              ctx.restore();
              yOffset += layerThickness;
            });

            // Draw studs in realistic mode
            if (wallConfig.studs) {
              const studSpacing = wallConfig.studs.spacing * (GRID_SIZE / 6) / 12 * scaleFactor;
              const studWidth = wallConfig.studs.width * (GRID_SIZE / 6) / 12 * scaleFactor;

              let cavityStart = -thickness / 2;
              let cavityThickness = 0;
              wallConfig.layers.forEach(layer => {
                const layerThick = layer.thickness * scaleFactor;
                if (layer.pattern === 'cavity' || layer.pattern === 'insulation') {
                  cavityThickness = layerThick;
                } else if (cavityThickness === 0) {
                  cavityStart += layerThick;
                }
              });

              // Draw studs with wood grain
              ctx.fillStyle = isSelected ? '#E8C888' : wallConfig.studs.color;

              // End studs
              ctx.fillRect(0, cavityStart, studWidth, cavityThickness);
              ctx.fillRect(wallLength - studWidth, cavityStart, studWidth, cavityThickness);

              // Interior studs
              for (let x = studSpacing; x < wallLength - studWidth; x += studSpacing) {
                ctx.fillRect(x - studWidth / 2, cavityStart, studWidth, cavityThickness);
              }

              // Wood grain on studs
              ctx.strokeStyle = 'rgba(139,90,43,0.3)';
              ctx.lineWidth = 0.5;
              for (let x = studSpacing; x < wallLength - studWidth; x += studSpacing) {
                for (let y = cavityStart + 2; y < cavityStart + cavityThickness; y += 3) {
                  ctx.beginPath();
                  ctx.moveTo(x - studWidth / 2, y);
                  ctx.lineTo(x + studWidth / 2, y);
                  ctx.stroke();
                }
              }
            }

            // Wall outline
            ctx.strokeStyle = isSelected ? '#00ffaa' : '#444';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(0, -thickness / 2, wallLength, thickness);
          }
        }
        
        ctx.restore();
        
        // Measurement - auto-scale for readability
        const length = distance(wall.start, wall.end);
        const midX = (wall.start.x + wall.end.x) / 2;
        const midY = (wall.start.y + wall.end.y) / 2;
        
        // Auto-scale font size - larger on mobile when zoomed out
        const minScaleFactor = isMobile ? 1.3 : 1.0;
        const labelScaleFactor = Math.max(minScaleFactor, 1 / scale);
        const labelFontSize = Math.round(10 * labelScaleFactor);
        
        ctx.save();
        ctx.translate(midX, midY);
        ctx.rotate(angle);
        
        // Background for better readability
        const measureText = `${formatMeasurement(pixelsToFeet(length))} (h:${formatMeasurement(inchesToFeet(wall.height || DEFAULT_WALL_HEIGHT))})`;
        ctx.font = `${labelFontSize}px "SF Mono", monospace`;
        const textWidth = ctx.measureText(measureText).width;
        ctx.fillStyle = 'rgba(8,12,16,0.8)';
        ctx.fillRect(-textWidth / 2 - 4 * labelScaleFactor, -thickness - 4 - labelFontSize, textWidth + 8 * labelScaleFactor, labelFontSize + 4 * labelScaleFactor);
        
        ctx.fillStyle = '#00c8ff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(measureText, 0, -thickness - 4);
        ctx.restore();
        
        // Draw grips for selected wall or when in select mode
        if ((isSelected || tool === 'select') && showGrips && !layers.walls.locked) {
          const gripSize = isSelected ? 10 / scale : 6 / scale; // Selected wall gets larger grips
          
          // Start grip
          ctx.fillStyle = isSelected ? '#00ffaa' : 'rgba(0,200,255,0.6)';
          ctx.strokeStyle = isSelected ? '#fff' : 'rgba(255,255,255,0.6)';
          ctx.lineWidth = (isSelected ? 2 : 1) / scale;
          ctx.beginPath();
          ctx.arc(wall.start.x, wall.start.y, gripSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // End grip
          ctx.beginPath();
          ctx.arc(wall.end.x, wall.end.y, gripSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Midpoint grip (for adding joints later)
          ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.5)' : 'rgba(0,200,255,0.3)';
          ctx.beginPath();
          ctx.rect(midX - gripSize/2, midY - gripSize/2, gripSize, gripSize);
          ctx.fill();
          ctx.stroke();
        }
      });

      // Draw corner caps for detailed mode to clean up wall intersections
      if (wallDetailLevel === 'detailed' || wallDetailLevel === 'standard') {
        const walls = activeFloor.walls || [];
        const cornerThreshold = 5; // How close endpoints need to be to form a corner

        // Find all corner connections
        walls.forEach((wall1, i) => {
          walls.forEach((wall2, j) => {
            if (i >= j) return; // Avoid duplicates

            const thickness1 = WALL_THICKNESS_OPTIONS[wall1.type]?.thickness || 8;
            const thickness2 = WALL_THICKNESS_OPTIONS[wall2.type]?.thickness || 8;
            const maxThickness = Math.max(thickness1, thickness2);

            // Check all endpoint combinations
            const endpoints = [
              { p1: wall1.start, p2: wall2.start },
              { p1: wall1.start, p2: wall2.end },
              { p1: wall1.end, p2: wall2.start },
              { p1: wall1.end, p2: wall2.end },
            ];

            endpoints.forEach(({ p1, p2 }) => {
              const dist = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
              if (dist < cornerThreshold) {
                // Found a corner - draw a corner cap
                const cornerX = (p1.x + p2.x) / 2;
                const cornerY = (p1.y + p2.y) / 2;

                // Get wall configurations
                const config1 = WALL_LAYERS[wall1.type] || WALL_LAYERS['interior'];
                const config2 = WALL_LAYERS[wall2.type] || WALL_LAYERS['interior'];

                if (wallDetailLevel === 'detailed' && renderMode === 'realistic') {
                  // Realistic corner cap - use the outermost layer color
                  const outerColor = config1.layers[0]?.color || '#8B7355';
                  ctx.fillStyle = outerColor;
                  ctx.beginPath();
                  ctx.arc(cornerX, cornerY, maxThickness / 2 + 1, 0, Math.PI * 2);
                  ctx.fill();

                  // Inner fill matching interior
                  const innerColor = config1.layers[config1.layers.length - 1]?.color || '#E8E4DF';
                  ctx.fillStyle = innerColor;
                  ctx.beginPath();
                  ctx.arc(cornerX, cornerY, maxThickness / 2 - 2, 0, Math.PI * 2);
                  ctx.fill();
                } else if (wallDetailLevel === 'detailed' && renderMode === 'linework') {
                  // Line work corner cap - clean outline
                  ctx.fillStyle = '#1a1a1a';
                  ctx.beginPath();
                  ctx.arc(cornerX, cornerY, maxThickness / 2 + 1, 0, Math.PI * 2);
                  ctx.fill();

                  ctx.strokeStyle = '#aaa';
                  ctx.lineWidth = 1.5;
                  ctx.beginPath();
                  ctx.arc(cornerX, cornerY, maxThickness / 2 + 1, 0, Math.PI * 2);
                  ctx.stroke();
                } else {
                  // Standard mode corner cap
                  const outerColor = config1.layers[0]?.color || '#8B7355';
                  ctx.fillStyle = outerColor;
                  ctx.beginPath();
                  ctx.arc(cornerX, cornerY, maxThickness / 2, 0, Math.PI * 2);
                  ctx.fill();

                  ctx.strokeStyle = '#888';
                  ctx.lineWidth = 1;
                  ctx.beginPath();
                  ctx.arc(cornerX, cornerY, maxThickness / 2, 0, Math.PI * 2);
                  ctx.stroke();
                }
              }
            });
          });
        });
      }
    }

    // Draw doors
    if (layers.doors.visible) {
    activeFloor.doors.forEach(door => {
      const wall = activeFloor.walls.find(w => w.id === door.wallId);
      if (!wall) return;
      
      const isSelected = selectedItems.some(s => s.type === 'door' && s.item.id === door.id);
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const pos = { x: wall.start.x + dx * door.position, y: wall.start.y + dy * door.position };
      const angle = Math.atan2(dy, dx);
      const thickness = WALL_THICKNESS_OPTIONS[wall.type]?.thickness || 8;
      const doorWidth = door.width || 36;
      const doorType = door.type || 'single';
      const swing = door.swing || 'left';
      
      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.rotate(angle);
      
      // Clear wall opening - make it larger to fully clear the wall glow
      ctx.fillStyle = '#080c10';
      ctx.fillRect(-doorWidth / 2 - 1, -thickness / 2 - 6, doorWidth + 2, thickness + 12);
      
      // Draw door frame (jambs on each side)
      ctx.fillStyle = isSelected ? '#00ffaa' : '#8B7355';
      ctx.fillRect(-doorWidth / 2 - 3, -thickness / 2 - 2, 3, thickness + 4); // Left jamb
      ctx.fillRect(doorWidth / 2, -thickness / 2 - 2, 3, thickness + 4); // Right jamb
      
      // Selection highlight
      if (isSelected) {
        ctx.strokeStyle = '#00ffaa';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(-doorWidth / 2 - 8, -thickness / 2 - 10, doorWidth + 16, thickness + 55);
        ctx.setLineDash([]);
      }
      
      // Door styling based on type
      ctx.strokeStyle = isSelected ? '#00ffaa' : '#00c8ff';
      ctx.lineWidth = isSelected ? 2 : 1.5;
      
      if (doorType === 'single' || doorType === 'barn') {
        // Single door with swing arc
        const swingDir = swing === 'right' ? -1 : 1;
        const openDir = (door.openDirection || 'inward') === 'inward' ? 1 : -1;
        
        // Hinge point
        const hingeX = -doorWidth / 2 * swingDir;
        const hingeY = openDir === 1 ? thickness / 2 + 2 : -thickness / 2 - 2;
        
        // Arc angles depend on both swing and open direction
        let arcStart, arcEnd;
        if (openDir === 1) { // Inward
          arcStart = swing === 'right' ? -Math.PI : -Math.PI / 2;
          arcEnd = swing === 'right' ? -Math.PI / 2 : 0;
        } else { // Outward
          arcStart = swing === 'right' ? Math.PI / 2 : 0;
          arcEnd = swing === 'right' ? Math.PI : Math.PI / 2;
        }
        
        // Door panel (solid rectangle)
        ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.25)' : 'rgba(139,90,43,0.5)';
        ctx.fillRect(-doorWidth / 2, hingeY, doorWidth, 3 * openDir);
        ctx.setLineDash([]);
        ctx.strokeRect(-doorWidth / 2, hingeY, doorWidth, 3 * openDir);
        
        // Swing arc (dashed)
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(hingeX, hingeY, doorWidth, arcStart, arcEnd);
        ctx.stroke();
        
        // Dashed line from hinge perpendicular to wall (toward the arc)
        ctx.beginPath();
        ctx.moveTo(hingeX, hingeY);
        ctx.lineTo(hingeX, hingeY - doorWidth * openDir);
        ctx.stroke();
        ctx.setLineDash([]);
        
      } else if (doorType === 'double' || doorType === 'french') {
        // Double doors
        const halfWidth = doorWidth / 2;
        const openDir = (door.openDirection || 'inward') === 'inward' ? 1 : -1;
        const hingeY = openDir === 1 ? thickness / 2 + 2 : -thickness / 2 - 2;
        
        // Left door panel (solid)
        ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.15)' : 'rgba(139,90,43,0.3)';
        ctx.fillRect(-halfWidth, hingeY, halfWidth - 2, 3 * openDir);
        ctx.setLineDash([]);
        ctx.strokeRect(-halfWidth, hingeY, halfWidth - 2, 3 * openDir);
        
        // Right door panel (solid)
        ctx.fillRect(2, hingeY, halfWidth - 2, 3 * openDir);
        ctx.strokeRect(2, hingeY, halfWidth - 2, 3 * openDir);
        
        // Left door swing arc (dashed)
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        if (openDir === 1) {
          ctx.arc(-halfWidth, hingeY, halfWidth - 2, -Math.PI / 2, 0);
        } else {
          ctx.arc(-halfWidth, hingeY, halfWidth - 2, 0, Math.PI / 2);
        }
        ctx.stroke();
        
        // Left door open position line - perpendicular to wall
        ctx.beginPath();
        ctx.moveTo(-halfWidth, hingeY);
        ctx.lineTo(-halfWidth, hingeY - (halfWidth - 2) * openDir);
        ctx.stroke();
        
        // Right door swing arc (dashed)
        ctx.beginPath();
        if (openDir === 1) {
          ctx.arc(halfWidth, hingeY, halfWidth - 2, -Math.PI, -Math.PI / 2);
        } else {
          ctx.arc(halfWidth, hingeY, halfWidth - 2, Math.PI / 2, Math.PI);
        }
        ctx.stroke();
        
        // Right door open position line - perpendicular to wall
        ctx.beginPath();
        ctx.moveTo(halfWidth, hingeY);
        ctx.lineTo(halfWidth, hingeY - (halfWidth - 2) * openDir);
        ctx.stroke();
        
        ctx.setLineDash([]);
        
        // French door glass panels indicator
        if (doorType === 'french') {
          ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(135,206,235,0.8)';
          ctx.lineWidth = 1;
          ctx.strokeRect(-halfWidth + 3, hingeY + 0.5 * openDir, halfWidth - 8, 2 * openDir);
          ctx.strokeRect(5, hingeY + 0.5 * openDir, halfWidth - 8, 2 * openDir);
        }
        
      } else if (doorType === 'sliding') {
        // Sliding door
        const hingeY = thickness / 2 + 2;
        
        // Door panels (solid fill)
        ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.15)' : 'rgba(135,206,235,0.2)';
        ctx.fillRect(-doorWidth / 2, hingeY, doorWidth, 4);
        ctx.setLineDash([]);
        ctx.strokeRect(-doorWidth / 2, hingeY, doorWidth, 4);
        
        // Glass panel dividers
        ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(135,206,235,0.8)';
        ctx.beginPath();
        ctx.moveTo(0, hingeY);
        ctx.lineTo(0, hingeY + 4);
        ctx.stroke();
        
        // Arrow indicator showing slide direction
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#00c8ff';
        ctx.beginPath();
        ctx.moveTo(-10, hingeY + 12);
        ctx.lineTo(10, hingeY + 12);
        ctx.moveTo(5, hingeY + 9);
        ctx.lineTo(10, hingeY + 12);
        ctx.lineTo(5, hingeY + 15);
        ctx.stroke();
        
      } else if (doorType === 'pocket') {
        // Pocket door
        const hingeY = thickness / 2 + 2;
        
        // Door panel (solid)
        ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.15)' : 'rgba(139,90,43,0.3)';
        ctx.fillRect(-doorWidth / 2, hingeY, doorWidth * 0.6, 3);
        ctx.setLineDash([]);
        ctx.strokeRect(-doorWidth / 2, hingeY, doorWidth * 0.6, 3);
        
        // Wall pocket indication (dashed)
        ctx.setLineDash([2, 2]);
        ctx.strokeRect(doorWidth / 2 - doorWidth * 0.4, -thickness / 2 - 3, doorWidth * 0.4, thickness + 6);
        ctx.setLineDash([]);
        
        // Arrow showing slide direction
        ctx.beginPath();
        ctx.moveTo(0, hingeY + 10);
        ctx.lineTo(doorWidth / 4, hingeY + 10);
        ctx.moveTo(doorWidth / 4 - 5, hingeY + 7);
        ctx.lineTo(doorWidth / 4, hingeY + 10);
        ctx.lineTo(doorWidth / 4 - 5, hingeY + 13);
        ctx.stroke();
        
      } else if (doorType === 'bifold') {
        // Bifold door
        const panelWidth = doorWidth / 4;
        const hingeY = thickness / 2 + 2;
        
        ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.15)' : 'rgba(139,90,43,0.3)';
        ctx.setLineDash([]);
        
        // Draw 4 panels
        for (let i = 0; i < 4; i++) {
          const x = -doorWidth / 2 + i * panelWidth;
          ctx.fillRect(x + 1, hingeY, panelWidth - 2, 3);
          ctx.strokeRect(x + 1, hingeY, panelWidth - 2, 3);
        }
        
        // Fold lines (dashed)
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.moveTo(-doorWidth / 4, hingeY + 5);
        ctx.lineTo(-doorWidth / 4, hingeY + 15);
        ctx.moveTo(doorWidth / 4, hingeY + 5);
        ctx.lineTo(doorWidth / 4, hingeY + 15);
        ctx.stroke();
        ctx.setLineDash([]);
        
      } else if (doorType === 'garage') {
        // Garage door
        const hingeY = thickness / 2 + 2;
        
        ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.15)' : 'rgba(100,100,100,0.3)';
        ctx.fillRect(-doorWidth / 2, hingeY, doorWidth, 6);
        ctx.setLineDash([]);
        ctx.strokeRect(-doorWidth / 2, hingeY, doorWidth, 6);
        
        // Panel lines (vertical)
        const panels = 4;
        const panelWidth = doorWidth / panels;
        for (let i = 1; i < panels; i++) {
          ctx.beginPath();
          ctx.moveTo(-doorWidth / 2 + i * panelWidth, hingeY);
          ctx.lineTo(-doorWidth / 2 + i * panelWidth, hingeY + 6);
          ctx.stroke();
        }
        
        // Horizontal lines (panel sections)
        ctx.beginPath();
        ctx.moveTo(-doorWidth / 2, hingeY + 2);
        ctx.lineTo(doorWidth / 2, hingeY + 2);
        ctx.moveTo(-doorWidth / 2, hingeY + 4);
        ctx.lineTo(doorWidth / 2, hingeY + 4);
        ctx.stroke();
      }
      
      // Width label - auto-scaled for mobile readability
      if (isSelected || scale > 0.5) {
        const labelScaleFactor = Math.max(isMobile ? 1.3 : 1.0, 1 / scale);
        const labelFontSize = Math.round(9 * labelScaleFactor);
        ctx.fillStyle = isSelected ? '#00ffaa' : '#00c8ff';
        ctx.font = `${labelFontSize}px "SF Mono", monospace`;
        ctx.textAlign = 'center';
        // Convert pixels to feet (doorWidth is in pixels now)
        const doorWidthFeet = doorWidth / (GRID_SIZE / 6) / 12;
        const labelY = -thickness / 2 - 6 * labelScaleFactor;
        
        // Background for better readability
        const labelText = formatMeasurement(doorWidthFeet);
        const textWidth = ctx.measureText(labelText).width;
        ctx.fillStyle = 'rgba(8,12,16,0.8)';
        ctx.fillRect(-textWidth / 2 - 3 * labelScaleFactor, labelY - labelFontSize, textWidth + 6 * labelScaleFactor, labelFontSize + 2 * labelScaleFactor);
        
        ctx.fillStyle = isSelected ? '#00ffaa' : '#00c8ff';
        ctx.fillText(labelText, 0, labelY);
      }
      
      ctx.restore();
    });
    }
    
    // Draw windows
    if (layers.windows.visible) {
    activeFloor.windows.forEach(win => {
      const wall = activeFloor.walls.find(w => w.id === win.wallId);
      if (!wall) return;
      
      const isSelected = selectedItems.some(s => s.type === 'window' && s.item.id === win.id);
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const pos = { x: wall.start.x + dx * win.position, y: wall.start.y + dy * win.position };
      const angle = Math.atan2(dy, dx);
      const thickness = WALL_THICKNESS_OPTIONS[wall.type]?.thickness || 8;
      const winWidth = win.width || 48;
      const winType = win.type || 'double-hung';
      
      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.rotate(angle);
      
      // Selection highlight
      if (isSelected) {
        ctx.fillStyle = 'rgba(0,255,170,0.2)';
        ctx.fillRect(-winWidth / 2 - 5, -thickness / 2 - 5, winWidth + 10, thickness + 10);
      }
      
      // Clear wall opening
      ctx.fillStyle = '#080c10';
      ctx.fillRect(-winWidth / 2, -thickness / 2 - 1, winWidth, thickness + 2);
      
      // Window frame
      ctx.strokeStyle = isSelected ? '#00ffaa' : '#00c8ff';
      ctx.lineWidth = isSelected ? 2 : 1.5;
      ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.1)' : 'rgba(135,206,235,0.15)';
      
      // Outer frame
      ctx.fillRect(-winWidth / 2 + 2, -thickness / 2 + 1, winWidth - 4, thickness - 2);
      ctx.strokeRect(-winWidth / 2 + 2, -thickness / 2 + 1, winWidth - 4, thickness - 2);
      
      // Inner details based on type
      ctx.strokeStyle = isSelected ? 'rgba(0,255,170,0.7)' : 'rgba(135,206,235,0.7)';
      ctx.lineWidth = 1;
      
      if (winType === 'single-hung' || winType === 'double-hung') {
        // Horizontal divider
        ctx.beginPath();
        ctx.moveTo(-winWidth / 2 + 3, 0);
        ctx.lineTo(winWidth / 2 - 3, 0);
        ctx.stroke();
        
        // Vertical divider (mullion)
        ctx.beginPath();
        ctx.moveTo(0, -thickness / 2 + 2);
        ctx.lineTo(0, thickness / 2 - 2);
        ctx.stroke();
        
        // Movement indicator
        if (winType === 'double-hung') {
          ctx.fillStyle = isSelected ? '#00ffaa' : '#00c8ff';
          ctx.font = '7px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('‚Üï', -winWidth / 4, 0);
          ctx.fillText('‚Üï', winWidth / 4, 0);
        } else {
          ctx.fillText('‚Üë', 0, thickness / 4);
        }
        
      } else if (winType === 'casement') {
        // Vertical divider
        ctx.beginPath();
        ctx.moveTo(0, -thickness / 2 + 2);
        ctx.lineTo(0, thickness / 2 - 2);
        ctx.stroke();
        
        // Hinge indicators
        ctx.fillStyle = isSelected ? '#00ffaa' : '#888';
        ctx.fillRect(-winWidth / 2 + 3, -thickness / 4, 2, 2);
        ctx.fillRect(-winWidth / 2 + 3, thickness / 4 - 2, 2, 2);
        ctx.fillRect(winWidth / 2 - 5, -thickness / 4, 2, 2);
        ctx.fillRect(winWidth / 2 - 5, thickness / 4 - 2, 2, 2);
        
        // Crank indicator
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#00c8ff';
        ctx.beginPath();
        ctx.arc(-winWidth / 4, 0, 3, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(winWidth / 4, 0, 3, 0, Math.PI * 2);
        ctx.stroke();
        
      } else if (winType === 'sliding') {
        // Two sliding panels
        ctx.strokeRect(-winWidth / 2 + 3, -thickness / 2 + 2, winWidth / 2 - 4, thickness - 4);
        ctx.strokeRect(1, -thickness / 2 + 2, winWidth / 2 - 4, thickness - 4);
        
        // Arrow indicator
        ctx.fillStyle = isSelected ? '#00ffaa' : '#00c8ff';
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('‚Üî', 0, 0);
        
      } else if (winType === 'fixed') {
        // Fixed picture window - just frame, no operators
        ctx.strokeRect(-winWidth / 2 + 4, -thickness / 2 + 2, winWidth - 8, thickness - 4);
        
        // Cross pattern for large fixed
        if (winWidth > 48) {
          ctx.beginPath();
          ctx.moveTo(0, -thickness / 2 + 2);
          ctx.lineTo(0, thickness / 2 - 2);
          ctx.moveTo(-winWidth / 2 + 4, 0);
          ctx.lineTo(winWidth / 2 - 4, 0);
          ctx.stroke();
        }
        
      } else if (winType === 'awning') {
        // Hinged at top
        ctx.strokeRect(-winWidth / 2 + 3, -thickness / 2 + 2, winWidth - 6, thickness - 4);
        
        // Hinge line at top
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-winWidth / 2 + 4, -thickness / 2 + 3);
        ctx.lineTo(winWidth / 2 - 4, -thickness / 2 + 3);
        ctx.stroke();
        
        // Open direction indicator
        ctx.fillStyle = isSelected ? '#00ffaa' : '#00c8ff';
        ctx.font = '7px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('‚§¥', 0, thickness / 4);
        
      } else if (winType === 'bay') {
        // 3-panel bay window
        const sideWidth = winWidth / 4;
        const centerWidth = winWidth / 2;
        
        // Side panels (angled)
        ctx.strokeRect(-winWidth / 2 + 2, -thickness / 2 + 2, sideWidth - 2, thickness - 4);
        ctx.strokeRect(winWidth / 2 - sideWidth, -thickness / 2 + 2, sideWidth - 2, thickness - 4);
        
        // Center panel
        ctx.strokeRect(-centerWidth / 2, -thickness / 2 + 2, centerWidth, thickness - 4);
        
        // Angle indicators
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.moveTo(-winWidth / 2 + sideWidth, -thickness);
        ctx.lineTo(-centerWidth / 2, -thickness / 2);
        ctx.moveTo(winWidth / 2 - sideWidth, -thickness);
        ctx.lineTo(centerWidth / 2, -thickness / 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
      } else if (winType === 'bow') {
        // Curved bow window
        ctx.beginPath();
        ctx.arc(0, thickness * 2, winWidth / 2, Math.PI + 0.3, -0.3);
        ctx.stroke();
        
        // Panel dividers
        const panels = 5;
        for (let i = 1; i < panels; i++) {
          const x = -winWidth / 2 + (winWidth / panels) * i;
          ctx.beginPath();
          ctx.moveTo(x, -thickness / 2 + 2);
          ctx.lineTo(x, thickness / 2 - 2);
          ctx.stroke();
        }
      }
      
      // Sill indicator (bottom line)
      ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(139,90,43,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-winWidth / 2, thickness / 2);
      ctx.lineTo(winWidth / 2, thickness / 2);
      ctx.stroke();
      
      // Width label - auto-scaled for mobile readability
      if (isSelected || scale > 0.5) {
        const labelScaleFactor = Math.max(isMobile ? 1.3 : 1.0, 1 / scale);
        const labelFontSize = Math.round(9 * labelScaleFactor);
        ctx.fillStyle = isSelected ? '#00ffaa' : '#00c8ff';
        ctx.font = `${labelFontSize}px "SF Mono", monospace`;
        ctx.textAlign = 'center';
        // Convert pixels to feet (winWidth is in pixels now)
        const winWidthFeet = winWidth / (GRID_SIZE / 6) / 12;
        const labelY = -thickness / 2 - 6 * labelScaleFactor;
        
        // Background for better readability
        const labelText = formatMeasurement(winWidthFeet);
        const textWidth = ctx.measureText(labelText).width;
        ctx.fillStyle = 'rgba(8,12,16,0.8)';
        ctx.fillRect(-textWidth / 2 - 3 * labelScaleFactor, labelY - labelFontSize, textWidth + 6 * labelScaleFactor, labelFontSize + 2 * labelScaleFactor);
        
        ctx.fillStyle = isSelected ? '#00ffaa' : '#00c8ff';
        ctx.fillText(labelText, 0, labelY);
      }
      
      ctx.restore();
    });
    }
    
    // Draw stairs
    (activeFloor.stairs || []).forEach(stair => {
      const isSelected = selectedItems.some(s => s.type === 'stairs' && s.item.id === stair.id);
      
      ctx.save();
      ctx.translate(stair.x, stair.y);
      
      // Background
      ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.2)' : 'rgba(80,60,40,0.6)';
      ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(160,140,100,0.8)';
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.fillRect(-stair.width / 2, -stair.height / 2, stair.width, stair.height);
      ctx.strokeRect(-stair.width / 2, -stair.height / 2, stair.width, stair.height);
      
      // Draw steps
      const stepHeight = stair.height / (stair.steps || 12);
      ctx.strokeStyle = 'rgba(200,180,140,0.6)';
      ctx.lineWidth = 1;
      for (let i = 1; i < (stair.steps || 12); i++) {
        const y = -stair.height / 2 + i * stepHeight;
        ctx.beginPath();
        ctx.moveTo(-stair.width / 2, y);
        ctx.lineTo(stair.width / 2, y);
        ctx.stroke();
      }
      
      // Arrow indicating direction
      ctx.fillStyle = '#c0a080';
      ctx.beginPath();
      ctx.moveTo(0, -stair.height / 2 + 10);
      ctx.lineTo(-8, -stair.height / 2 + 25);
      ctx.lineTo(8, -stair.height / 2 + 25);
      ctx.closePath();
      ctx.fill();
      
      // Label
      ctx.fillStyle = '#fff';
      ctx.font = '10px "Inter", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(stair.type === 'ramp' ? 'RAMP' : 'UP', 0, stair.height / 2 - 5);
      
      ctx.restore();
    });
    
    // Draw furniture with realistic shapes
    if (layers.furniture.visible) {
    activeFloor.furniture.forEach(furn => {
      const isSelected = selectedItems.some(s => s.type === 'furniture' && s.item.id === furn.id);
      const template = FURNITURE_LIBRARY.find(f => f.id === furn.templateId);
      const shape = template?.shape || 'default';
      
      ctx.save();
      ctx.translate(furn.x, furn.y);
      if (furn.rotation) {
        ctx.rotate(furn.rotation * Math.PI / 180);
      }
      
      const w = furn.width;
      const h = furn.height;
      const hw = w / 2;
      const hh = h / 2;
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(-hw + 2, -hh + 2, w, h);
      
      // Draw based on shape type
      if (shape === 'bed') {
        // Bed frame
        ctx.fillStyle = isSelected ? 'rgba(139,90,43,0.9)' : 'rgba(139,90,43,0.8)';
        ctx.fillRect(-hw, -hh, w, h);
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#8b5a2b';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
        // Mattress
        ctx.fillStyle = '#e8e8e8';
        ctx.fillRect(-hw + 4, -hh + 4, w - 8, h - 8);
        // Pillow(s)
        ctx.fillStyle = '#fff';
        const pillowH = h * 0.15;
        ctx.fillRect(-hw + 8, -hh + 8, w - 16, pillowH);
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        ctx.strokeRect(-hw + 8, -hh + 8, w - 16, pillowH);
        // Blanket fold
        ctx.strokeStyle = '#ccc';
        ctx.beginPath();
        ctx.moveTo(-hw + 8, -hh + pillowH + 20);
        ctx.lineTo(hw - 8, -hh + pillowH + 20);
        ctx.stroke();
      } else if (shape === 'sofa') {
        // Back
        ctx.fillStyle = isSelected ? 'rgba(70,90,120,0.9)' : 'rgba(70,90,120,0.85)';
        ctx.fillRect(-hw, -hh, w, h * 0.3);
        // Seat
        ctx.fillStyle = isSelected ? 'rgba(90,110,140,0.9)' : 'rgba(90,110,140,0.85)';
        ctx.fillRect(-hw, -hh + h * 0.3, w, h * 0.7);
        // Arms
        ctx.fillStyle = 'rgba(60,80,100,0.9)';
        ctx.fillRect(-hw, -hh, w * 0.1, h);
        ctx.fillRect(hw - w * 0.1, -hh, w * 0.1, h);
        // Cushion lines
        ctx.strokeStyle = 'rgba(50,70,90,0.6)';
        ctx.lineWidth = 1;
        const cushions = w > 70 ? 3 : 2;
        for (let i = 1; i < cushions; i++) {
          const cx = -hw + w * 0.1 + (w * 0.8 / cushions) * i;
          ctx.beginPath();
          ctx.moveTo(cx, -hh + h * 0.35);
          ctx.lineTo(cx, hh - 4);
          ctx.stroke();
        }
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#5a6a80';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
      } else if (shape === 'chair') {
        // Seat (circle or square)
        ctx.fillStyle = isSelected ? 'rgba(100,120,150,0.9)' : 'rgba(100,120,150,0.85)';
        ctx.beginPath();
        ctx.arc(0, 0, Math.min(hw, hh) * 0.9, 0, Math.PI * 2);
        ctx.fill();
        // Back
        ctx.fillStyle = 'rgba(80,100,130,0.9)';
        ctx.beginPath();
        ctx.arc(0, -hh * 0.5, Math.min(hw, hh) * 0.7, Math.PI, 0);
        ctx.fill();
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#6a7a90';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, Math.min(hw, hh) * 0.9, 0, Math.PI * 2);
        ctx.stroke();
      } else if (shape === 'table') {
        // Table top
        ctx.fillStyle = isSelected ? 'rgba(139,119,101,0.9)' : 'rgba(139,119,101,0.85)';
        ctx.fillRect(-hw, -hh, w, h);
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#8b7765';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
        // Wood grain lines
        ctx.strokeStyle = 'rgba(100,80,60,0.3)';
        ctx.lineWidth = 1;
        for (let i = 1; i < 4; i++) {
          ctx.beginPath();
          ctx.moveTo(-hw + w * (i/4), -hh);
          ctx.lineTo(-hw + w * (i/4), hh);
          ctx.stroke();
        }
      } else if (shape === 'counter' || shape === 'island') {
        // Counter base (cabinet)
        ctx.fillStyle = isSelected ? 'rgba(180,160,140,0.9)' : 'rgba(180,160,140,0.85)';
        ctx.fillRect(-hw, -hh, w, h);
        // Counter top (slightly larger, darker)
        ctx.fillStyle = isSelected ? 'rgba(80,80,85,0.95)' : 'rgba(60,60,65,0.95)';
        ctx.fillRect(-hw - 1, -hh - 1, w + 2, h * 0.15);
        // Cabinet doors
        ctx.strokeStyle = 'rgba(140,120,100,0.8)';
        ctx.lineWidth = 1;
        const doors = Math.max(1, Math.floor(w / 20));
        const doorW = w / doors;
        for (let i = 0; i < doors; i++) {
          ctx.strokeRect(-hw + i * doorW + 2, -hh + h * 0.2, doorW - 4, h * 0.75);
          // Handle
          ctx.fillStyle = '#888';
          ctx.fillRect(-hw + i * doorW + doorW/2 - 2, -hh + h * 0.55, 4, 8);
        }
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#a08060';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
      } else if (shape === 'counter-corner') {
        // L-shaped corner counter
        ctx.fillStyle = isSelected ? 'rgba(180,160,140,0.9)' : 'rgba(180,160,140,0.85)';
        ctx.beginPath();
        ctx.moveTo(-hw, -hh);
        ctx.lineTo(hw, -hh);
        ctx.lineTo(hw, hh);
        ctx.lineTo(-hw + w * 0.4, hh);
        ctx.lineTo(-hw + w * 0.4, -hh + h * 0.4);
        ctx.lineTo(-hw, -hh + h * 0.4);
        ctx.closePath();
        ctx.fill();
        // Counter top
        ctx.fillStyle = 'rgba(60,60,65,0.95)';
        ctx.fillRect(-hw, -hh, w, h * 0.12);
        ctx.fillRect(-hw, -hh, w * 0.12, h * 0.4);
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#a08060';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (shape === 'stove') {
        // Stove body
        ctx.fillStyle = isSelected ? 'rgba(50,50,55,0.95)' : 'rgba(40,40,45,0.95)';
        ctx.fillRect(-hw, -hh, w, h);
        // Burners (4 circles)
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        const bSize = Math.min(w, h) * 0.2;
        [[-0.25, -0.3], [0.25, -0.3], [-0.25, 0.25], [0.25, 0.25]].forEach(([bx, by]) => {
          ctx.beginPath();
          ctx.arc(w * bx, h * by, bSize, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(w * bx, h * by, bSize * 0.5, 0, Math.PI * 2);
          ctx.stroke();
        });
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#555';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
      } else if (shape === 'sink') {
        // Counter around sink
        ctx.fillStyle = 'rgba(180,160,140,0.85)';
        ctx.fillRect(-hw, -hh, w, h);
        // Sink basin
        ctx.fillStyle = isSelected ? 'rgba(220,220,225,0.95)' : 'rgba(200,200,205,0.95)';
        ctx.fillRect(-hw + 4, -hh + 4, w - 8, h - 8);
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw + 4, -hh + 4, w - 8, h - 8);
        // Faucet
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.arc(0, -hh + 10, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#a08060';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
      } else if (shape === 'toilet') {
        // Tank
        ctx.fillStyle = isSelected ? 'rgba(240,240,245,0.95)' : 'rgba(230,230,235,0.95)';
        ctx.fillRect(-hw, -hh, w, h * 0.35);
        // Bowl (oval)
        ctx.beginPath();
        ctx.ellipse(0, hh * 0.3, hw * 0.85, hh * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
        // Seat
        ctx.strokeStyle = '#bbb';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(0, hh * 0.3, hw * 0.7, hh * 0.45, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#ccc';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h * 0.35);
      } else if (shape === 'tub') {
        // Tub outer
        ctx.fillStyle = isSelected ? 'rgba(240,240,245,0.95)' : 'rgba(230,230,235,0.95)';
        ctx.beginPath();
        ctx.roundRect(-hw, -hh, w, h, 8);
        ctx.fill();
        // Inner basin
        ctx.fillStyle = 'rgba(200,220,240,0.5)';
        ctx.beginPath();
        ctx.roundRect(-hw + 5, -hh + 5, w - 10, h - 10, 5);
        ctx.fill();
        // Drain
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.arc(hw - 15, 0, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#bbb';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(-hw, -hh, w, h, 8);
        ctx.stroke();
      } else if (shape === 'shower') {
        // Floor pan
        ctx.fillStyle = isSelected ? 'rgba(200,210,220,0.9)' : 'rgba(190,200,210,0.9)';
        ctx.fillRect(-hw, -hh, w, h);
        // Drain (center)
        ctx.fillStyle = '#777';
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI * 2);
        ctx.fill();
        // Tile pattern
        ctx.strokeStyle = 'rgba(150,160,170,0.5)';
        ctx.lineWidth = 1;
        const tileSize = 12;
        for (let tx = -hw; tx < hw; tx += tileSize) {
          ctx.beginPath();
          ctx.moveTo(tx, -hh);
          ctx.lineTo(tx, hh);
          ctx.stroke();
        }
        for (let ty = -hh; ty < hh; ty += tileSize) {
          ctx.beginPath();
          ctx.moveTo(-hw, ty);
          ctx.lineTo(hw, ty);
          ctx.stroke();
        }
        // Shower head
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.arc(0, -hh + 8, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#aabbcc';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
      } else if (shape === 'appliance') {
        // Generic appliance (fridge, washer, dryer, dishwasher)
        ctx.fillStyle = isSelected ? 'rgba(220,220,225,0.95)' : 'rgba(200,200,205,0.95)';
        ctx.fillRect(-hw, -hh, w, h);
        // Control panel area
        ctx.fillStyle = 'rgba(60,60,65,0.9)';
        ctx.fillRect(-hw + 4, -hh + 4, w - 8, h * 0.15);
        // Door line
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-hw + 4, -hh + h * 0.25);
        ctx.lineTo(hw - 4, -hh + h * 0.25);
        ctx.stroke();
        // Handle
        ctx.fillStyle = '#666';
        ctx.fillRect(-hw + 8, -hh + h * 0.35, 3, h * 0.4);
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#aaa';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
      } else if (shape === 'cabinet') {
        // Cabinet/dresser
        ctx.fillStyle = isSelected ? 'rgba(139,119,101,0.9)' : 'rgba(139,119,101,0.85)';
        ctx.fillRect(-hw, -hh, w, h);
        // Drawers or doors
        ctx.strokeStyle = 'rgba(100,80,60,0.6)';
        ctx.lineWidth = 1;
        const rows = h > 30 ? 3 : 2;
        const rowH = h / rows;
        for (let i = 0; i < rows; i++) {
          ctx.strokeRect(-hw + 3, -hh + 3 + i * rowH, w - 6, rowH - 3);
          // Handle
          ctx.fillStyle = '#888';
          ctx.fillRect(-3, -hh + rowH/2 + i * rowH - 2, 6, 4);
        }
        ctx.strokeStyle = isSelected ? '#00ffaa' : '#8b7765';
        ctx.lineWidth = 2;
        ctx.strokeRect(-hw, -hh, w, h);
      } else {
        // Default fallback
        ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.3)' : 'rgba(60,80,100,0.8)';
        ctx.strokeStyle = isSelected ? '#00ffaa' : 'rgba(100,140,180,0.8)';
        ctx.lineWidth = isSelected ? 2 : 1;
        ctx.fillRect(-hw, -hh, w, h);
        ctx.strokeRect(-hw, -hh, w, h);
        // Icon for unknown shapes
        ctx.font = `${Math.min(w, h) * 0.4}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.fillText(furn.icon, 0, 0);
      }
      
      ctx.restore();
    });
    }
    
    // Draw electrical
    if (layers.electrical.visible) {
    (activeFloor.electrical || []).forEach(elec => {
      const isSelected = selectedItems.some(s => s.type === 'electrical' && s.item.id === elec.id);
      
      ctx.save();
      ctx.translate(elec.x, elec.y);
      
      // Background circle
      ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.3)' : 'rgba(255,220,100,0.3)';
      ctx.strokeStyle = isSelected ? '#00ffaa' : '#ffcc00';
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Symbol
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px "SF Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(elec.symbol, 0, 0);
      
      ctx.restore();
    });
    }
    
    // Draw plumbing fixtures
    if (layers.plumbing.visible) {
    (activeFloor.plumbing || []).forEach(plumb => {
      const isSelected = selectedItems.some(s => s.type === 'plumbing' && s.item.id === plumb.id);
      
      ctx.save();
      ctx.translate(plumb.x, plumb.y);
      
      // Background
      ctx.fillStyle = isSelected ? 'rgba(0,255,170,0.3)' : 'rgba(100,150,255,0.3)';
      ctx.strokeStyle = isSelected ? '#00ffaa' : '#6699ff';
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.beginPath();
      ctx.arc(0, 0, plumb.size / 2 || 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Symbol
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px "SF Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(plumb.symbol, 0, 0);
      
      ctx.restore();
    });
    }
    
    // Draw text annotations
    if (layers.text.visible) {
    (activeFloor.texts || []).forEach(text => {
      const isSelected = selectedItems.some(s => s.type === 'text' && s.item.id === text.id);
      
      ctx.save();
      ctx.translate(text.x, text.y);
      
      if (text.rotation) {
        ctx.rotate(text.rotation * Math.PI / 180);
      }
      
      // Selection highlight
      if (isSelected) {
        const textWidth = (text.content?.length || 5) * (text.fontSize || 14) * 0.6;
        const textHeight = (text.fontSize || 14) * 1.2;
        ctx.fillStyle = 'rgba(0,255,170,0.15)';
        ctx.fillRect(-5, -textHeight, textWidth + 10, textHeight + 10);
        ctx.strokeStyle = '#00ffaa';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(-5, -textHeight, textWidth + 10, textHeight + 10);
        ctx.setLineDash([]);
      }
      
      // Text shadow for readability
      ctx.fillStyle = 'rgba(8,12,16,0.8)';
      ctx.font = `${text.bold ? 'bold ' : ''}${text.italic ? 'italic ' : ''}${text.fontSize || 14}px ${text.fontFamily || '"SF Pro", sans-serif'}`;
      ctx.textBaseline = 'bottom';
      ctx.fillText(text.content, 1, 1);
      
      // Text
      ctx.fillStyle = text.color || '#ffffff';
      ctx.fillText(text.content, 0, 0);
      
      ctx.restore();
    });
    }
    
    // Draw current drawing preview
    if (isDrawing && drawStart && drawEnd) {
      if (tool === 'wall') {
        // Draw alignment guide lines from existing wall endpoints
        const GUIDE_TOLERANCE = 8; // pixels - how close to trigger guide
        const guidePoints = [];
        
        // Collect all wall endpoints and midpoints
        activeFloor.walls.forEach(wall => {
          guidePoints.push({ x: wall.start.x, y: wall.start.y, type: 'endpoint' });
          guidePoints.push({ x: wall.end.x, y: wall.end.y, type: 'endpoint' });
          guidePoints.push({ 
            x: (wall.start.x + wall.end.x) / 2, 
            y: (wall.start.y + wall.end.y) / 2, 
            type: 'midpoint' 
          });
        });
        
        // Check for horizontal and vertical alignments
        const alignments = [];
        guidePoints.forEach(pt => {
          // Skip if too close to draw start
          if (Math.abs(pt.x - drawStart.x) < 5 && Math.abs(pt.y - drawStart.y) < 5) return;
          
          // Horizontal alignment (same Y)
          if (Math.abs(pt.y - drawEnd.y) < GUIDE_TOLERANCE) {
            alignments.push({
              type: 'horizontal',
              fromX: pt.x,
              fromY: pt.y,
              toX: drawEnd.x,
              toY: pt.y,
              snapY: pt.y,
              pointType: pt.type
            });
          }
          
          // Vertical alignment (same X)
          if (Math.abs(pt.x - drawEnd.x) < GUIDE_TOLERANCE) {
            alignments.push({
              type: 'vertical',
              fromX: pt.x,
              fromY: pt.y,
              toX: pt.x,
              toY: drawEnd.y,
              snapX: pt.x,
              pointType: pt.type
            });
          }
        });
        
        // Draw guide lines
        ctx.save();
        
        // Draw extension lines from the start point (faint, shows where straight horiz/vert would go)
        ctx.strokeStyle = isMobile ? 'rgba(0,200,255,0.3)' : 'rgba(0,200,255,0.15)';
        ctx.lineWidth = isMobile ? 2 : 1;
        ctx.setLineDash(isMobile ? [4, 8] : [2, 6]);
        // Horizontal extension from start
        ctx.beginPath();
        ctx.moveTo(drawStart.x - 2000, drawStart.y);
        ctx.lineTo(drawStart.x + 2000, drawStart.y);
        ctx.stroke();
        // Vertical extension from start
        ctx.beginPath();
        ctx.moveTo(drawStart.x, drawStart.y - 2000);
        ctx.lineTo(drawStart.x, drawStart.y + 2000);
        ctx.stroke();
        
        // Draw extension lines from the end point (brighter, shows current position)
        ctx.strokeStyle = isMobile ? 'rgba(0,255,200,0.4)' : 'rgba(0,255,200,0.2)';
        ctx.setLineDash(isMobile ? [4, 6] : [2, 4]);
        // Horizontal extension from end
        ctx.beginPath();
        ctx.moveTo(drawEnd.x - 2000, drawEnd.y);
        ctx.lineTo(drawEnd.x + 2000, drawEnd.y);
        ctx.stroke();
        // Vertical extension from end  
        ctx.beginPath();
        ctx.moveTo(drawEnd.x, drawEnd.y - 2000);
        ctx.lineTo(drawEnd.x, drawEnd.y + 2000);
        ctx.stroke();
        
        alignments.forEach(align => {
          // Guide line - thicker on mobile for visibility
          ctx.strokeStyle = align.pointType === 'midpoint' ? '#ff8800' : '#00ff88';
          ctx.lineWidth = isMobile ? 3 : 2;
          ctx.setLineDash(isMobile ? [8, 6] : [4, 4]);
          ctx.globalAlpha = isMobile ? 0.9 : 0.8;
          ctx.beginPath();
          ctx.moveTo(align.fromX, align.fromY);
          ctx.lineTo(align.toX, align.toY);
          ctx.stroke();
          
          // Source point indicator (small diamond) - larger on mobile
          ctx.setLineDash([]);
          ctx.fillStyle = align.pointType === 'midpoint' ? '#ff8800' : '#00ff88';
          const diamondSize = isMobile ? 7 : 4;
          ctx.beginPath();
          ctx.moveTo(align.fromX, align.fromY - diamondSize);
          ctx.lineTo(align.fromX + diamondSize, align.fromY);
          ctx.lineTo(align.fromX, align.fromY + diamondSize);
          ctx.lineTo(align.fromX - diamondSize, align.fromY);
          ctx.closePath();
          ctx.fill();
        });
        
        // Draw intersection indicator if both horizontal and vertical guides exist
        const hasHoriz = alignments.find(a => a.type === 'horizontal');
        const hasVert = alignments.find(a => a.type === 'vertical');
        if (hasHoriz && hasVert) {
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 2;
          ctx.setLineDash([]);
          ctx.beginPath();
          ctx.arc(hasVert.snapX, hasHoriz.snapY, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
        ctx.restore();
        
        // Draw the wall preview
        const thickness = WALL_THICKNESS_OPTIONS[wallType]?.thickness || 8;
        ctx.strokeStyle = 'rgba(0,200,255,0.3)';
        ctx.lineWidth = thickness + 8;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(drawStart.x, drawStart.y);
        ctx.lineTo(drawEnd.x, drawEnd.y);
        ctx.stroke();
        
        ctx.strokeStyle = '#00c8ff';
        ctx.lineWidth = thickness;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(drawStart.x, drawStart.y);
        ctx.lineTo(drawEnd.x, drawEnd.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        const length = distance(drawStart, drawEnd);
        ctx.fillStyle = '#00c8ff';
        ctx.font = 'bold 14px "SF Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(formatMeasurement(pixelsToFeet(length)), (drawStart.x + drawEnd.x) / 2, (drawStart.y + drawEnd.y) / 2 - 20);
        
        // Draw snap point indicator when near an endpoint/midpoint
        if (wallDrawSnap) {
          ctx.save();
          const snapColor = wallDrawSnap.type === 'endpoint' ? '#00ff88' : '#ff8800';
          
          // Large target circle
          ctx.beginPath();
          ctx.arc(wallDrawSnap.x, wallDrawSnap.y, isMobile ? 20 : 14, 0, Math.PI * 2);
          ctx.fillStyle = snapColor + '40';
          ctx.fill();
          ctx.strokeStyle = snapColor;
          ctx.lineWidth = 3;
          ctx.stroke();
          
          // Crosshairs
          ctx.strokeStyle = snapColor;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(wallDrawSnap.x - 25, wallDrawSnap.y);
          ctx.lineTo(wallDrawSnap.x + 25, wallDrawSnap.y);
          ctx.moveTo(wallDrawSnap.x, wallDrawSnap.y - 25);
          ctx.lineTo(wallDrawSnap.x, wallDrawSnap.y + 25);
          ctx.stroke();
          
          // Center dot
          ctx.beginPath();
          ctx.arc(wallDrawSnap.x, wallDrawSnap.y, 5, 0, Math.PI * 2);
          ctx.fillStyle = '#fff';
          ctx.fill();
          ctx.strokeStyle = snapColor;
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Label
          ctx.fillStyle = snapColor;
          ctx.font = 'bold 11px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(wallDrawSnap.type === 'endpoint' ? '‚úì ENDPOINT' : '‚úì MIDPOINT', wallDrawSnap.x, wallDrawSnap.y - 25);
          
          ctx.restore();
        }
      } else if (tool === 'room') {
        const x = Math.min(drawStart.x, drawEnd.x);
        const y = Math.min(drawStart.y, drawEnd.y);
        const w = Math.abs(drawEnd.x - drawStart.x);
        const h = Math.abs(drawEnd.y - drawStart.y);
        
        ctx.fillStyle = 'rgba(100,200,255,0.1)';
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = '#00c8ff';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(x, y, w, h);
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#00c8ff';
        ctx.font = 'bold 12px "SF Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${formatMeasurement(pixelsToFeet(w))} √ó ${formatMeasurement(pixelsToFeet(h))}`, x + w / 2, y + h / 2);
      } else if (tool === 'porch') {
        const x = Math.min(drawStart.x, drawEnd.x);
        const y = Math.min(drawStart.y, drawEnd.y);
        const w = Math.abs(drawEnd.x - drawStart.x);
        const h = Math.abs(drawEnd.y - drawStart.y);
        const porchDef = PORCH_TYPES[porchType] || PORCH_TYPES.open;
        
        ctx.fillStyle = 'rgba(139,119,101,0.2)';
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = '#8b7765';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(x, y, w, h);
        ctx.setLineDash([]);
        
        // Show dimensions
        ctx.fillStyle = '#8b7765';
        ctx.font = 'bold 12px "SF Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${formatMeasurement(pixelsToFeet(w))} √ó ${formatMeasurement(pixelsToFeet(h))}`, x + w / 2, y + h / 2 - 10);
        ctx.font = '11px sans-serif';
        ctx.fillText(porchDef.name, x + w / 2, y + h / 2 + 8);
      } else if (tool === 'roof') {
        const x = Math.min(drawStart.x, drawEnd.x);
        const y = Math.min(drawStart.y, drawEnd.y);
        const w = Math.abs(drawEnd.x - drawStart.x);
        const h = Math.abs(drawEnd.y - drawStart.y);
        const roofDef = ROOF_TYPES[roofType] || ROOF_TYPES.gable;
        const overhang = roofOverhang * (GRID_SIZE / 6) / 12;

        // Building footprint
        ctx.fillStyle = 'rgba(139,90,43,0.15)';
        ctx.fillRect(x, y, w, h);

        // Roof outline with overhang (dashed)
        ctx.strokeStyle = '#8b5a2b';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(x - overhang, y - overhang, w + overhang * 2, h + overhang * 2);
        ctx.setLineDash([]);

        // Building footprint outline (solid)
        ctx.strokeStyle = 'rgba(139,90,43,0.6)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);

        // Ridge line preview
        ctx.strokeStyle = '#8b5a2b';
        ctx.lineWidth = 2;
        if (roofType === 'gable' || roofType === 'gambrel') {
          if (w > h) {
            // Horizontal ridge
            ctx.beginPath();
            ctx.moveTo(x - overhang, y + h / 2);
            ctx.lineTo(x + w + overhang, y + h / 2);
            ctx.stroke();
          } else {
            // Vertical ridge
            ctx.beginPath();
            ctx.moveTo(x + w / 2, y - overhang);
            ctx.lineTo(x + w / 2, y + h + overhang);
            ctx.stroke();
          }
        } else if (roofType === 'hip') {
          const centerX = x + w / 2;
          const centerY = y + h / 2;
          // Draw hip lines to corners
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(x - overhang, y - overhang);
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(x + w + overhang, y - overhang);
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(x - overhang, y + h + overhang);
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(x + w + overhang, y + h + overhang);
          ctx.stroke();
        }

        // Show dimensions and type
        ctx.fillStyle = '#8b5a2b';
        ctx.font = 'bold 12px "SF Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${formatMeasurement(pixelsToFeet(w))} √ó ${formatMeasurement(pixelsToFeet(h))}`, x + w / 2, y + h / 2 - 10);
        ctx.font = '11px sans-serif';
        ctx.fillText(`${roofDef.label} Roof`, x + w / 2, y + h / 2 + 8);
      }
    }

    // Draw plumbing line in progress
    if (plumbingLineStart && tool === 'plumbing-line') {
      const pos = getPointerPos({ clientX: 0, clientY: 0 }); // Will update on move
      ctx.strokeStyle = plumbingLineType === 'hot' ? '#ff6666' : 
                        plumbingLineType === 'cold' ? '#6666ff' : 
                        plumbingLineType === 'drain' ? '#666666' : '#996633';
      ctx.lineWidth = plumbingLineType === 'drain' ? 4 : 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(plumbingLineStart.x, plumbingLineStart.y);
      ctx.lineTo(measureEnd?.x || plumbingLineStart.x, measureEnd?.y || plumbingLineStart.y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    
    // Draw measurement
    if (measureStart) {
      const end = measureEnd || measureStart;
      
      ctx.strokeStyle = '#ffaa00';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(measureStart.x, measureStart.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      ctx.setLineDash([]);
      
      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.arc(measureStart.x, measureStart.y, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(end.x, end.y, 5, 0, Math.PI * 2);
      ctx.fill();
      
      const dist = distance(measureStart, end);
      ctx.fillStyle = '#ffaa00';
      ctx.font = 'bold 14px "SF Mono", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(formatMeasurement(pixelsToFeet(dist)), (measureStart.x + end.x) / 2, (measureStart.y + end.y) / 2 - 15);
    }
    
    // Move command preview
    if (tool === 'move' && moveBasePoint) {
      // Draw angle guide lines from base point (faint)
      ctx.save();
      ctx.strokeStyle = 'rgba(0,255,136,0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 8]);
      
      // Draw guides at 0, 45, 90, 135, 180, -135, -90, -45 degrees
      const guideLength = 150;
      [0, 45, 90, 135, 180, -135, -90, -45].forEach(deg => {
        const rad = deg * Math.PI / 180;
        ctx.beginPath();
        ctx.moveTo(moveBasePoint.x, moveBasePoint.y);
        ctx.lineTo(moveBasePoint.x + Math.cos(rad) * guideLength, moveBasePoint.y + Math.sin(rad) * guideLength);
        ctx.stroke();
      });
      ctx.setLineDash([]);
      ctx.restore();
      
      // Draw base point
      ctx.fillStyle = '#00ff88';
      ctx.beginPath();
      ctx.arc(moveBasePoint.x, moveBasePoint.y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw "BASE" label
      ctx.fillStyle = '#00ff88';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('BASE', moveBasePoint.x, moveBasePoint.y - 15);
      
      // Draw preview line and destination
      if (movePreviewPoint && (movePreviewPoint.x !== moveBasePoint.x || movePreviewPoint.y !== moveBasePoint.y)) {
        const isSnapped = movePreviewPoint.snapped;
        
        // Draw the move line
        ctx.strokeStyle = isSnapped ? '#00ff88' : '#00ffff';
        ctx.lineWidth = isSnapped ? 3 : 2;
        ctx.setLineDash(isSnapped ? [] : [8, 4]);
        ctx.beginPath();
        ctx.moveTo(moveBasePoint.x, moveBasePoint.y);
        ctx.lineTo(movePreviewPoint.x, movePreviewPoint.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw destination point
        ctx.fillStyle = isSnapped ? '#00ff88' : '#00ffff';
        ctx.beginPath();
        ctx.arc(movePreviewPoint.x, movePreviewPoint.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw delta distance
        const deltaX = movePreviewPoint.x - moveBasePoint.x;
        const deltaY = movePreviewPoint.y - moveBasePoint.y;
        const moveDist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        ctx.fillStyle = isSnapped ? '#00ff88' : '#00ffff';
        ctx.font = isSnapped ? 'bold 13px sans-serif' : 'bold 11px sans-serif';
        ctx.fillText(formatMeasurement(pixelsToFeet(moveDist)), (moveBasePoint.x + movePreviewPoint.x) / 2, (moveBasePoint.y + movePreviewPoint.y) / 2 - 15);
        
        // Show angle and SNAP indicator when snapped
        if (isSnapped && movePreviewPoint.angle !== undefined) {
          ctx.fillStyle = '#00ff88';
          ctx.font = 'bold 10px sans-serif';
          const angleLabel = movePreviewPoint.angle === 0 || movePreviewPoint.angle === 180 || movePreviewPoint.angle === -180 ? '‚Üí' :
                            movePreviewPoint.angle === 90 || movePreviewPoint.angle === -90 ? '‚Üì' :
                            movePreviewPoint.angle === 45 || movePreviewPoint.angle === -135 ? '‚Üò' :
                            movePreviewPoint.angle === 135 || movePreviewPoint.angle === -45 ? '‚Üô' : '';
          ctx.fillText(`${angleLabel} ${Math.abs(movePreviewPoint.angle)}¬∞ SNAP`, (moveBasePoint.x + movePreviewPoint.x) / 2, (moveBasePoint.y + movePreviewPoint.y) / 2 + 5);
        }
      }
    }
    
    // Rotate command preview
    if (tool === 'rotate' && rotateCenter) {
      const radius = 80;
      const SNAP_ANGLES = [0, 45, 90, 135, 180, 225, 270, 315]; // degrees
      
      // Draw 45-degree guide lines (faint)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,136,0,0.2)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 8]);
      
      SNAP_ANGLES.forEach(deg => {
        const rad = deg * Math.PI / 180;
        ctx.beginPath();
        ctx.moveTo(rotateCenter.x, rotateCenter.y);
        ctx.lineTo(rotateCenter.x + Math.cos(rad) * radius * 1.5, rotateCenter.y + Math.sin(rad) * radius * 1.5);
        ctx.stroke();
      });
      ctx.setLineDash([]);
      
      // Draw degree labels at each 45¬∞ mark
      ctx.fillStyle = 'rgba(255,136,0,0.4)';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      SNAP_ANGLES.forEach(deg => {
        const rad = deg * Math.PI / 180;
        const labelDist = radius * 1.7;
        ctx.fillText(`${deg}¬∞`, rotateCenter.x + Math.cos(rad) * labelDist, rotateCenter.y + Math.sin(rad) * labelDist);
      });
      ctx.restore();
      
      // Draw center point
      ctx.fillStyle = '#ff8800';
      ctx.beginPath();
      ctx.arc(rotateCenter.x, rotateCenter.y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw crosshair at center
      ctx.strokeStyle = '#ff8800';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(rotateCenter.x - 15, rotateCenter.y);
      ctx.lineTo(rotateCenter.x + 15, rotateCenter.y);
      ctx.moveTo(rotateCenter.x, rotateCenter.y - 15);
      ctx.lineTo(rotateCenter.x, rotateCenter.y + 15);
      ctx.stroke();
      
      ctx.fillStyle = '#ff8800';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('CENTER', rotateCenter.x, rotateCenter.y - 18);
      
      if (rotateStartAngle !== null) {
        // Draw reference line
        ctx.strokeStyle = '#ff8800';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(rotateCenter.x, rotateCenter.y);
        ctx.lineTo(rotateCenter.x + Math.cos(rotateStartAngle) * radius, rotateCenter.y + Math.sin(rotateStartAngle) * radius);
        ctx.stroke();
        
        // Draw 45-degree snap guides relative to start angle
        ctx.save();
        ctx.strokeStyle = 'rgba(0,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 6]);
        SNAP_ANGLES.forEach(deg => {
          if (deg === 0) return; // Skip 0 (that's the reference line)
          const snapRad = rotateStartAngle + (deg * Math.PI / 180);
          ctx.beginPath();
          ctx.moveTo(rotateCenter.x, rotateCenter.y);
          ctx.lineTo(rotateCenter.x + Math.cos(snapRad) * radius * 1.2, rotateCenter.y + Math.sin(snapRad) * radius * 1.2);
          ctx.stroke();
        });
        ctx.restore();
        
        // Draw preview angle
        if (rotatePreviewAngle !== null && rotatePreviewAngle !== rotateStartAngle) {
          // Check if snapped to 45-degree
          const angleDelta = rotatePreviewAngle - rotateStartAngle;
          let angleDeltaDeg = (angleDelta * 180 / Math.PI) % 360;
          if (angleDeltaDeg < 0) angleDeltaDeg += 360;
          
          const isSnapped = SNAP_ANGLES.some(snapDeg => 
            Math.abs(angleDeltaDeg - snapDeg) < 3 || Math.abs(angleDeltaDeg - snapDeg + 360) < 3 || Math.abs(angleDeltaDeg - snapDeg - 360) < 3
          );
          
          ctx.strokeStyle = isSnapped ? '#00ff88' : '#00ffff';
          ctx.lineWidth = isSnapped ? 3 : 2;
          ctx.setLineDash(isSnapped ? [] : [4, 4]);
          ctx.beginPath();
          ctx.moveTo(rotateCenter.x, rotateCenter.y);
          ctx.lineTo(rotateCenter.x + Math.cos(rotatePreviewAngle) * radius, rotateCenter.y + Math.sin(rotatePreviewAngle) * radius);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Draw arc showing rotation
          ctx.strokeStyle = isSnapped ? '#00ff88' : '#00ffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          if (angleDelta > 0) {
            ctx.arc(rotateCenter.x, rotateCenter.y, radius * 0.5, rotateStartAngle, rotatePreviewAngle);
          } else {
            ctx.arc(rotateCenter.x, rotateCenter.y, radius * 0.5, rotatePreviewAngle, rotateStartAngle);
          }
          ctx.stroke();
          
          // Show angle in degrees
          const displayAngle = (angleDelta * 180 / Math.PI).toFixed(1);
          ctx.fillStyle = isSnapped ? '#00ff88' : '#00ffff';
          ctx.font = isSnapped ? 'bold 13px sans-serif' : 'bold 11px sans-serif';
          ctx.fillText(`${displayAngle}¬∞`, rotateCenter.x, rotateCenter.y + radius + 20);
          
          // Show "SNAP" indicator when snapped
          if (isSnapped) {
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 10px sans-serif';
            ctx.fillText('SNAP', rotateCenter.x, rotateCenter.y + radius + 35);
          }
        }
      }
    }
    
    // Wall drag angle lock visualization
    if (wallDragSnap && wallDragStart) {
      ctx.save();
      
      // Draw angle guide lines from start point (faint)
      ctx.strokeStyle = 'rgba(0,200,255,0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 8]);
      
      const guideLength = 200;
      [0, 45, 90, 135, 180, -135, -90, -45].forEach(deg => {
        const rad = deg * Math.PI / 180;
        ctx.beginPath();
        ctx.moveTo(wallDragSnap.startX, wallDragSnap.startY);
        ctx.lineTo(wallDragSnap.startX + Math.cos(rad) * guideLength, wallDragSnap.startY + Math.sin(rad) * guideLength);
        ctx.stroke();
      });
      ctx.setLineDash([]);
      
      // Draw start point
      ctx.fillStyle = '#00c8ff';
      ctx.beginPath();
      ctx.arc(wallDragSnap.startX, wallDragSnap.startY, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw movement line
      const isSnapped = wallDragSnap.snapped;
      ctx.strokeStyle = isSnapped ? '#00ff88' : '#00c8ff';
      ctx.lineWidth = isSnapped ? 3 : 2;
      ctx.setLineDash(isSnapped ? [] : [6, 4]);
      ctx.beginPath();
      ctx.moveTo(wallDragSnap.startX, wallDragSnap.startY);
      ctx.lineTo(wallDragSnap.endX, wallDragSnap.endY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw end point
      ctx.fillStyle = isSnapped ? '#00ff88' : '#00c8ff';
      ctx.beginPath();
      ctx.arc(wallDragSnap.endX, wallDragSnap.endY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Show angle and distance
      const dx = wallDragSnap.endX - wallDragSnap.startX;
      const dy = wallDragSnap.endY - wallDragSnap.startY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const midX = (wallDragSnap.startX + wallDragSnap.endX) / 2;
      const midY = (wallDragSnap.startY + wallDragSnap.endY) / 2;
      
      ctx.fillStyle = isSnapped ? '#00ff88' : '#00c8ff';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(formatMeasurement(pixelsToFeet(dist)), midX, midY - 8);
      
      if (isSnapped && wallDragSnap.angle !== null) {
        const angleLabel = wallDragSnap.angle === 0 || wallDragSnap.angle === 180 || wallDragSnap.angle === -180 ? '‚Üí' :
                          Math.abs(wallDragSnap.angle) === 90 ? '‚Üì' :
                          wallDragSnap.angle === 45 || wallDragSnap.angle === -135 ? '‚Üò' :
                          wallDragSnap.angle === 135 || wallDragSnap.angle === -45 ? '‚Üô' : '';
        ctx.font = 'bold 11px sans-serif';
        ctx.textBaseline = 'top';
        ctx.fillText(`${angleLabel} ${Math.abs(wallDragSnap.angle)}¬∞ LOCK`, midX, midY + 5);
      }
      
      ctx.restore();
    }
    
    // Show all potential snap points while dragging a grip
    if (activeGrip && allSnapPoints.length > 0) {
      ctx.save();
      
      const snapColors = {
        endpoint: { fill: '#00ff88', stroke: 'rgba(0,255,136,0.5)' },
        midpoint: { fill: '#ff8800', stroke: 'rgba(255,136,0,0.5)' },
        perpendicular: { fill: '#00ffff', stroke: 'rgba(0,255,255,0.5)' },
      };
      
      // Draw all potential snap points as small indicators
      allSnapPoints.forEach(sp => {
        // Skip the active snap target (we'll draw it bigger below)
        if (gripSnapTarget && sp.x === gripSnapTarget.x && sp.y === gripSnapTarget.y) return;
        
        const colors = snapColors[sp.type] || snapColors.endpoint;
        
        // Small circle for potential snap point
        ctx.fillStyle = colors.stroke;
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner dot
        ctx.fillStyle = colors.fill;
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
      
      ctx.restore();
    }
    
    // Active grip snap target visualization (larger, more prominent)
    if (activeGrip && gripSnapTarget) {
      ctx.save();
      
      // Get color based on snap type
      const snapColors = {
        endpoint: { fill: '#00ff88', stroke: '#00ff88', bg: 'rgba(0,255,136,0.3)' },
        midpoint: { fill: '#ff8800', stroke: '#ff8800', bg: 'rgba(255,136,0,0.3)' },
        perpendicular: { fill: '#00ffff', stroke: '#00ffff', bg: 'rgba(0,255,255,0.3)' },
      };
      const colors = snapColors[gripSnapTarget.type] || snapColors.endpoint;
      
      // Large target circle
      ctx.fillStyle = colors.bg;
      ctx.beginPath();
      ctx.arc(gripSnapTarget.x, gripSnapTarget.y, 22, 0, Math.PI * 2);
      ctx.fill();
      
      // Outer ring
      ctx.strokeStyle = colors.stroke;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(gripSnapTarget.x, gripSnapTarget.y, 22, 0, Math.PI * 2);
      ctx.stroke();
      
      // Crosshairs
      ctx.lineWidth = 2;
      
      // Horizontal line
      ctx.beginPath();
      ctx.moveTo(gripSnapTarget.x - 30, gripSnapTarget.y);
      ctx.lineTo(gripSnapTarget.x - 10, gripSnapTarget.y);
      ctx.moveTo(gripSnapTarget.x + 10, gripSnapTarget.y);
      ctx.lineTo(gripSnapTarget.x + 30, gripSnapTarget.y);
      ctx.stroke();
      
      // Vertical line
      ctx.beginPath();
      ctx.moveTo(gripSnapTarget.x, gripSnapTarget.y - 30);
      ctx.lineTo(gripSnapTarget.x, gripSnapTarget.y - 10);
      ctx.moveTo(gripSnapTarget.x, gripSnapTarget.y + 10);
      ctx.lineTo(gripSnapTarget.x, gripSnapTarget.y + 30);
      ctx.stroke();
      
      // Center target dot
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(gripSnapTarget.x, gripSnapTarget.y, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = colors.fill;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Snap type label with background
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      const labelText = gripSnapTarget.label;
      const labelWidth = ctx.measureText(labelText).width + 8;
      
      // Label background
      ctx.fillStyle = colors.fill;
      ctx.beginPath();
      ctx.roundRect(gripSnapTarget.x - labelWidth/2, gripSnapTarget.y - 48, labelWidth, 18, 4);
      ctx.fill();
      
      // Label text
      ctx.fillStyle = '#000';
      ctx.fillText(labelText, gripSnapTarget.x, gripSnapTarget.y - 32);
      
      // "‚úì SNAP" indicator below
      ctx.fillStyle = colors.fill;
      ctx.font = 'bold 11px sans-serif';
      ctx.textBaseline = 'top';
      ctx.fillText('‚úì SNAP', gripSnapTarget.x, gripSnapTarget.y + 32);
      
      ctx.restore();
    }
    
    // Origin
    ctx.fillStyle = '#00c8ff';
    ctx.beginPath();
    ctx.arc(0, 0, 4, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }, [activeFloor, dimensions, offset, scale, isDrawing, drawStart, drawEnd, tool, wallType, selectedItems, measureStart, measureEnd, plumbingLineStart, plumbingLineType, getPointerPos, showDimensions, dimensionStart, dimensionStyle, formatMeasurement, isDrawingPolyline, polylinePoints, layers, lineStart, lineType, lineWeight, porchType, moveBasePoint, movePreviewPoint, rotateCenter, rotateStartAngle, rotatePreviewAngle, activeGrip, gripSnapTarget, allSnapPoints, wallDragSnap, wallDragStart, wallDrawSnap, isMobile, wallDetailLevel]);
  
  // ============================================================================
  // 3D VIEW
  // ============================================================================
  useEffect(() => {
    if (!show3D) return;
    const canvas = canvas3DRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const { width, height } = { width: 400, height: 300 };

    ctx.fillStyle = '#0a1015';
    ctx.fillRect(0, 0, width, height);
    
    // Apply rotation angles
    const rotX = view3DRotation.x * Math.PI / 180;
    const rotY = view3DRotation.y * Math.PI / 180;
    
    // 3D to 2D projection with rotation
    const project = (x, y, z = 0) => {
      // Apply Y rotation (around vertical axis)
      const cosY = Math.cos(rotY);
      const sinY = Math.sin(rotY);
      const x1 = x * cosY - y * sinY;
      const y1 = x * sinY + y * cosY;
      
      // Apply X rotation (tilt)
      const cosX = Math.cos(rotX);
      const sinX = Math.sin(rotX);
      const y2 = y1 * cosX - z * sinX;
      const z2 = y1 * sinX + z * cosX;
      
      // Apply zoom and pan
      return {
        x: x1 * view3DZoom + width / 2 + view3DPan.x,
        y: y2 * view3DZoom + height / 2 + view3DPan.y
      };
    };
    
    const scaleFactor = 0.15;
    
    // Draw rooms
    activeFloor.rooms.forEach(room => {
      const x1 = room.x * scaleFactor;
      const y1 = room.y * scaleFactor;
      const x2 = (room.x + room.width) * scaleFactor;
      const y2 = (room.y + room.height) * scaleFactor;
      
      ctx.fillStyle = room.color.replace('0.15', '0.3');
      ctx.beginPath();
      const p1 = project(x1, y1);
      const p2 = project(x2, y1);
      const p3 = project(x2, y2);
      const p4 = project(x1, y2);
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.lineTo(p4.x, p4.y);
      ctx.closePath();
      ctx.fill();
    });
    
    // Draw walls with height
    activeFloor.walls.forEach(wall => {
      const x1 = wall.start.x * scaleFactor;
      const y1 = wall.start.y * scaleFactor;
      const x2 = wall.end.x * scaleFactor;
      const y2 = wall.end.y * scaleFactor;
      const wallHeight = ((wall.height || DEFAULT_WALL_HEIGHT) / 12) * 8; // Scale height
      
      ctx.fillStyle = wall.type === 'exterior' ? 'rgba(200,220,240,0.9)' : 'rgba(160,180,200,0.8)';
      ctx.strokeStyle = 'rgba(100,140,180,0.8)';
      ctx.lineWidth = 1;
      
      const wp1 = project(x1, y1, 0);
      const wp2 = project(x2, y2, 0);
      const wp3 = project(x2, y2, wallHeight);
      const wp4 = project(x1, y1, wallHeight);
      
      ctx.beginPath();
      ctx.moveTo(wp1.x, wp1.y);
      ctx.lineTo(wp2.x, wp2.y);
      ctx.lineTo(wp3.x, wp3.y);
      ctx.lineTo(wp4.x, wp4.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    });
    
    // Draw stairs
    (activeFloor.stairs || []).forEach(stair => {
      const x = stair.x * scaleFactor;
      const y = stair.y * scaleFactor;
      const hw = (stair.width / 2) * scaleFactor;
      const hh = (stair.height / 2) * scaleFactor;
      
      // Draw step by step
      const steps = stair.steps || 12;
      const stepHeight = 60 / steps;
      
      for (let i = 0; i < steps; i++) {
        const z = i * stepHeight;
        const yOffset = (i / steps) * hh * 2;
        
        ctx.fillStyle = `rgba(180,160,120,${0.7 + i * 0.02})`;
        const sp1 = project(x - hw, y - hh + yOffset, z);
        const sp2 = project(x + hw, y - hh + yOffset, z);
        const sp3 = project(x + hw, y - hh + yOffset + hh/steps, z);
        const sp4 = project(x - hw, y - hh + yOffset + hh/steps, z);
        ctx.beginPath();
        ctx.moveTo(sp1.x, sp1.y);
        ctx.lineTo(sp2.x, sp2.y);
        ctx.lineTo(sp3.x, sp3.y);
        ctx.lineTo(sp4.x, sp4.y);
        ctx.closePath();
        ctx.fill();
      }
    });
    
    // Draw furniture
    activeFloor.furniture.forEach(furn => {
      const x = furn.x * scaleFactor;
      const y = furn.y * scaleFactor;
      const hw = (furn.width / 2) * scaleFactor;
      const hh = (furn.height / 2) * scaleFactor;
      const fh = 15;
      
      // Base
      ctx.fillStyle = 'rgba(80,100,120,0.9)';
      const fp1 = project(x - hw, y - hh, 0);
      const fp2 = project(x + hw, y - hh, 0);
      const fp3 = project(x + hw, y + hh, 0);
      const fp4 = project(x - hw, y + hh, 0);
      ctx.beginPath();
      ctx.moveTo(fp1.x, fp1.y);
      ctx.lineTo(fp2.x, fp2.y);
      ctx.lineTo(fp3.x, fp3.y);
      ctx.lineTo(fp4.x, fp4.y);
      ctx.closePath();
      ctx.fill();
      
      // Top
      ctx.fillStyle = 'rgba(100,130,160,0.9)';
      const ft1 = project(x - hw, y - hh, fh);
      const ft2 = project(x + hw, y - hh, fh);
      const ft3 = project(x + hw, y + hh, fh);
      const ft4 = project(x - hw, y + hh, fh);
      ctx.beginPath();
      ctx.moveTo(ft1.x, ft1.y);
      ctx.lineTo(ft2.x, ft2.y);
      ctx.lineTo(ft3.x, ft3.y);
      ctx.lineTo(ft4.x, ft4.y);
      ctx.closePath();
      ctx.fill();
      
      // Icon
      const fc = project(x, y, fh + 5);
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(furn.icon, fc.x, fc.y);
    });
    
  }, [show3D, activeFloor, view3DRotation, view3DZoom, view3DPan]);
  
  // ============================================================================
  // FILTERED ITEMS
  // ============================================================================
  const filteredFurniture = useMemo(() => {
    if (furnitureCategory === 'all') return FURNITURE_LIBRARY;
    return FURNITURE_LIBRARY.filter(f => f.category === furnitureCategory);
  }, [furnitureCategory]);
  
  // ============================================================================
  // RENDER
  // ============================================================================
  const ToolButton = ({ name, icon, label, onClick, active }) => (
    <button
      onClick={onClick || (() => setTool(name))}
      style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        gap: '2px',
        padding: '8px 10px',
        background: (active !== undefined ? active : tool === name) ? 'linear-gradient(135deg, #00c8ff 0%, #0088aa 100%)' : 'rgba(255,255,255,0.05)',
        border: (active !== undefined ? active : tool === name) ? 'none' : '1px solid rgba(255,255,255,0.1)',
        borderRadius: '8px',
        color: (active !== undefined ? active : tool === name) ? '#080c10' : '#8899aa',
        cursor: 'pointer',
        transition: 'all 0.15s ease',
        fontWeight: (active !== undefined ? active : tool === name) ? '600' : '400',
        minWidth: '52px',
      }}
    >
      <span style={{ fontSize: '14px' }}>{icon}</span>
      <span style={{ fontSize: '8px', letterSpacing: '0.3px' }}>{label}</span>
    </button>
  );
  
  const ActionButton = ({ icon, label, onClick, danger, active, small }) => (
    <button
      onClick={onClick}
      style={{
        display: 'flex',
        alignItems: 'center',
        gap: '4px',
        padding: small ? '4px 8px' : '6px 10px',
        background: active ? 'rgba(0,200,255,0.2)' : danger ? 'rgba(255,80,80,0.15)' : 'rgba(255,255,255,0.05)',
        border: `1px solid ${active ? 'rgba(0,200,255,0.4)' : danger ? 'rgba(255,80,80,0.3)' : 'rgba(255,255,255,0.1)'}`,
        borderRadius: '6px',
        color: active ? '#00c8ff' : danger ? '#ff6666' : '#8899aa',
        cursor: 'pointer',
        fontSize: small ? '10px' : '11px',
        fontWeight: '500',
        whiteSpace: 'nowrap',
      }}
    >
      <span>{icon}</span>
      <span>{label}</span>
    </button>
  );
  
  const InputField = ({ label, value, onChange, suffix, type = 'text', min, max, step }) => {
    const inputRef = React.useRef(null);
    const focusedRef = React.useRef(false);
    const [localValue, setLocalValue] = React.useState(value);
    const [isFocused, setIsFocused] = React.useState(false);
    const [isReadOnly, setIsReadOnly] = React.useState(true);  // Samsung fix: start readOnly

    // Initialize local value on mount
    React.useEffect(() => {
      setLocalValue(value);
    }, []);

    // Update local value when external value changes, but NEVER when focused
    React.useEffect(() => {
      if (!focusedRef.current) {
        setLocalValue(value);
      }
    }, [value]);

    const handleContainerTouch = (e) => {
      e.stopPropagation();
      // Samsung-specific: remove readOnly on any touch to the container
      setIsReadOnly(false);
    };

    const handleChange = (e) => {
      const newValue = e.target.value;
      setLocalValue(newValue);
      // Don't call onChange immediately - wait for blur
    };

    const handleFocus = (e) => {
      e.preventDefault();
      e.stopPropagation();
      setIsReadOnly(false);  // Ensure readOnly is removed
      focusedRef.current = true;
      setIsFocused(true);

      // Select all text on focus for easier editing
      setTimeout(() => {
        if (inputRef.current) {
          inputRef.current.select();
        }
      }, 50);
    };

    const handleBlur = (e) => {
      e.preventDefault();
      e.stopPropagation();

      // Delay blur to prevent keyboard from closing on Android
      setTimeout(() => {
        focusedRef.current = false;
        setIsFocused(false);
        setIsReadOnly(true);  // Set back to readOnly after blur
        // Call onChange only when user is done editing
        if (localValue !== value) {
          onChange(localValue);
        }
      }, 100);
    };
    
    return (
      <div 
        style={{ marginBottom: '8px' }}
        onTouchStart={handleContainerTouch}
        onTouchMove={handleContainerTouch}
        onTouchEnd={handleContainerTouch}
        onMouseDown={(e) => e.stopPropagation()}
        onPointerDown={(e) => e.stopPropagation()}
        onClick={(e) => e.stopPropagation()}
      >
        <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>{label}</label>
        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
          <input
            ref={inputRef}
            type="text"
            inputMode={type === 'number' ? 'numeric' : 'text'}
            readOnly={isReadOnly}
            value={localValue}
            onChange={handleChange}
            onFocus={handleFocus}
            onBlur={handleBlur}
            onTouchStart={(e) => {
              e.stopPropagation();
              setIsReadOnly(false);
            }}
            onTouchMove={(e) => e.stopPropagation()}
            onTouchEnd={(e) => {
              e.stopPropagation();
            }}
            onMouseDown={(e) => e.stopPropagation()}
            onPointerDown={(e) => e.stopPropagation()}
            onClick={(e) => e.stopPropagation()}
            min={min}
            max={max}
            step={step || (type === 'number' ? 1 : undefined)}
            autoComplete="off"
            autoCorrect="off"
            autoCapitalize="off"
            spellCheck="false"
            style={{
              flex: 1,
              padding: '10px 12px',
              background: isFocused ? 'rgba(0,200,255,0.15)' : 'rgba(255,255,255,0.1)',
              border: isFocused ? '2px solid rgba(0,200,255,0.6)' : '2px solid rgba(0,200,255,0.3)',
              borderRadius: '6px',
              color: '#fff',
              fontSize: '16px', // Prevents zoom on iOS
              width: '100%',
              boxSizing: 'border-box',
              touchAction: 'manipulation',
              WebkitAppearance: 'none',
              MozAppearance: 'textfield',
            }}
          />
          {suffix && <span style={{ color: '#6080a0', fontSize: '11px' }}>{suffix}</span>}
        </div>
      </div>
    );
  };
  
  return (
    <div style={{
      width: '100vw',
      height: '100vh',
      background: '#080c10',
      fontFamily: '"Inter", -apple-system, sans-serif',
      display: 'flex',
      flexDirection: 'column',
      overflow: 'hidden',
      touchAction: 'none',
    }}>
      {/* Header */}
      <div style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: isMobile ? '8px' : '6px 12px',
        background: 'rgba(12,18,24,0.95)',
        borderBottom: '1px solid rgba(0,200,255,0.12)',
        backdropFilter: 'blur(10px)',
        flexWrap: 'wrap',
        gap: '6px',
      }}>
        {/* Logo and floors - always visible */}
        <div style={{ display: 'flex', alignItems: 'center', gap: isMobile ? '8px' : '12px' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <div style={{
              width: isMobile ? '32px' : '28px',
              height: isMobile ? '32px' : '28px',
              background: 'linear-gradient(135deg, #00c8ff 0%, #0066aa 100%)',
              borderRadius: '6px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: isMobile ? '16px' : '14px',
            }}>üè†</div>
            {!isMobile && (
              <div>
                <div style={{ color: '#fff', fontWeight: '600', fontSize: '13px' }}>FloorPlan Pro</div>
                <div style={{ color: '#4a6070', fontSize: '8px' }}>v4.9</div>
              </div>
            )}
          </div>
          
          {!isMobile && (
            <div style={{ display: 'flex', alignItems: 'center', gap: '3px' }}>
              {floors.map(floor => (
                <button
                  key={floor.id}
                  onClick={() => setActiveFloorId(floor.id)}
                  style={{
                    padding: '3px 8px',
                    background: floor.id === activeFloorId ? 'rgba(0,200,255,0.2)' : 'transparent',
                    border: `1px solid ${floor.id === activeFloorId ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                    borderRadius: '4px',
                    color: floor.id === activeFloorId ? '#00c8ff' : '#6080a0',
                    fontSize: '10px',
                    cursor: 'pointer',
                  }}
                >
                  {floor.name}
                </button>
              ))}
              <button onClick={addFloor} style={{ padding: '3px 6px', background: 'transparent', border: '1px dashed rgba(255,255,255,0.2)', borderRadius: '4px', color: '#6080a0', fontSize: '10px', cursor: 'pointer' }}>+</button>
            </div>
          )}
        </div>
        
        {/* Mobile: Hamburger menu button */}
        {isMobile && (
          <button
            onClick={() => setShowMobileMenu(!showMobileMenu)}
            style={{
              padding: '8px 12px',
              background: showMobileMenu ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
              border: '1px solid rgba(255,255,255,0.1)',
              borderRadius: '6px',
              color: '#fff',
              fontSize: '18px',
              cursor: 'pointer',
            }}
          >
            {showMobileMenu ? '‚úï' : '‚ò∞'}
          </button>
        )}
        
        {/* Desktop: Tabbed toolbar */}
        {!isMobile && (
          <>
            {/* Tool Tabs */}
            <div style={{ display: 'flex', gap: '2px', marginRight: '8px' }}>
              {[
                { id: 'draw', label: 'Draw', icon: '‚úèÔ∏è' },
                { id: 'modify', label: 'Modify', icon: 'üîß' },
                { id: 'annotate', label: 'Annotate', icon: 'üìù' },
                { id: 'view', label: 'View', icon: 'üëÅÔ∏è' },
              ].map(tab => (
                <button
                  key={tab.id}
                  onClick={() => setToolTab(tab.id)}
                  style={{
                    padding: '6px 10px',
                    background: toolTab === tab.id ? 'rgba(0,200,255,0.15)' : 'transparent',
                    border: 'none',
                    borderBottom: toolTab === tab.id ? '2px solid #00c8ff' : '2px solid transparent',
                    color: toolTab === tab.id ? '#00c8ff' : '#6080a0',
                    fontSize: '10px',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '4px',
                  }}
                >
                  <span style={{ fontSize: '12px' }}>{tab.icon}</span>
                  {tab.label}
                </button>
              ))}
            </div>

            {/* Tab-specific tools */}
            <div style={{ display: 'flex', gap: '3px', flexWrap: 'wrap', borderLeft: '1px solid rgba(255,255,255,0.1)', paddingLeft: '8px' }}>
              {toolTab === 'draw' && (
                <>
                  <ToolButton name="wall" icon="‚ñ≠" label="WALL" />
                  <ToolButton name="door" icon="üö™" label="DOOR" />
                  <ToolButton name="window" icon="‚äû" label="WINDOW" />
                  <ToolButton name="room" icon="‚¨ú" label="ROOM" />
                  <ToolButton name="roof" icon="üè†" label="ROOF" />
                  <ToolButton name="line" icon="‚ï±" label="LINE" />
                </>
              )}
              {toolTab === 'modify' && (
                <>
                  <ToolButton name="select" icon="‚Üñ" label="SELECT" />
                  <ToolButton name="move" icon="‚ú•" label="MOVE" />
                  <ToolButton name="rotate" icon="‚Üª" label="ROTATE" />
                  <ToolButton name="extend" icon="‚üº" label="EXTEND" />
                  <ToolButton name="trim" icon="‚úÇ" label="TRIM" />
                  <ToolButton name="corner" icon="‚åê" label="CORNER" />
                </>
              )}
              {toolTab === 'annotate' && (
                <>
                  <ToolButton name="text" icon="T" label="TEXT" />
                  <ToolButton name="dimension" icon="‚Üî" label="DIM" />
                  <ToolButton name="measure" icon="üìè" label="MEASURE" />
                </>
              )}
              {toolTab === 'view' && (
                <>
                  <ToolButton name="pan" icon="‚úã" label="PAN" />
                  <ToolButton name="select" icon="‚Üñ" label="SELECT" />
                </>
              )}
            </div>
            
            <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap', alignItems: 'center' }}>
              <ActionButton icon="üìÑ" label="New" onClick={() => setShowNewFileConfirm(true)} small />
              <ActionButton icon="‚Ü©" label="Undo" onClick={undo} small />
              <ActionButton icon="‚Ü™" label="Redo" onClick={redo} small />
              <ActionButton icon="üìã" label="Copy" onClick={copySelected} small />
              <ActionButton icon="üìå" label="Paste" onClick={pasteClipboard} small />
              <ActionButton icon="ü™ë" label="Furniture" onClick={() => setActivePanel(activePanel === 'furniture' ? null : 'furniture')} active={activePanel === 'furniture'} small />
              <ActionButton icon="ü™ú" label="Stairs" onClick={() => setActivePanel(activePanel === 'stairs' ? null : 'stairs')} active={activePanel === 'stairs'} small />
              <ActionButton icon="‚ö°" label="Electrical" onClick={() => setActivePanel(activePanel === 'electrical' ? null : 'electrical')} active={activePanel === 'electrical'} small />
              <ActionButton icon="üîµ" label="Plumbing" onClick={() => setActivePanel(activePanel === 'plumbing' ? null : 'plumbing')} active={activePanel === 'plumbing'} small />
              <ActionButton icon="‚úèÔ∏è" label="Lines" onClick={() => setActivePanel(activePanel === 'lines' ? null : 'lines')} active={activePanel === 'lines'} small />
              <ActionButton icon="‚ñ®" label="Hatch" onClick={() => setActivePanel(activePanel === 'hatch' ? null : 'hatch')} active={activePanel === 'hatch'} small />
              <ActionButton icon="üè†" label="Porch" onClick={() => setActivePanel(activePanel === 'porch' ? null : 'porch')} active={activePanel === 'porch'} small />
              <ActionButton icon="üßä" label="3D" onClick={() => setShow3D(!show3D)} active={show3D} small />
              <ActionButton icon="üìë" label="Layers" onClick={() => setShowLayersPanel(!showLayersPanel)} active={showLayersPanel} small />
              <ActionButton icon="üìã" label="Sheets" onClick={() => setShowSheetsPanel(!showSheetsPanel)} active={showSheetsPanel} small />
              <ActionButton icon="‚öôÔ∏è" label="Settings" onClick={() => setShowSettings(!showSettings)} active={showSettings} small />
              <ActionButton icon="üíæ" label="Save" onClick={saveProject} small />
              <label style={{ display: 'flex', alignItems: 'center', gap: '4px', padding: '4px 8px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '6px', color: '#8899aa', cursor: 'pointer', fontSize: '10px' }}>
                üìÇ Open
                <input type="file" accept=".json" onChange={loadProject} style={{ display: 'none' }} />
              </label>
              <ActionButton icon="üñºÔ∏è" label="PNG" onClick={exportImage} small />
            </div>
          </>
        )}
      </div>
      
      {/* Mobile Menu Overlay */}
      {isMobile && showMobileMenu && (
        <div style={{
          position: 'fixed',
          top: '50px',
          left: 0,
          right: 0,
          bottom: 0,
          background: 'rgba(8,12,16,0.98)',
          zIndex: 300,
          overflowY: 'auto',
          padding: '16px',
        }}>
          {/* Floor selector */}
          <div style={{ marginBottom: '16px' }}>
            <div style={{ color: '#6080a0', fontSize: '11px', marginBottom: '8px' }}>FLOORS</div>
            <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
              {floors.map(floor => (
                <button
                  key={floor.id}
                  onClick={() => { setActiveFloorId(floor.id); }}
                  style={{
                    padding: '10px 16px',
                    background: floor.id === activeFloorId ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                    border: `1px solid ${floor.id === activeFloorId ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                    borderRadius: '8px',
                    color: floor.id === activeFloorId ? '#00c8ff' : '#8899aa',
                    fontSize: '14px',
                    cursor: 'pointer',
                  }}
                >
                  {floor.name}
                </button>
              ))}
              <button onClick={addFloor} style={{ padding: '10px 16px', background: 'transparent', border: '1px dashed rgba(255,255,255,0.2)', borderRadius: '8px', color: '#6080a0', fontSize: '14px', cursor: 'pointer' }}>+ Add</button>
            </div>
          </div>
          
          {/* Tool Tabs for Mobile */}
          <div style={{ marginBottom: '16px' }}>
            <div style={{ display: 'flex', gap: '4px', marginBottom: '12px', overflowX: 'auto' }}>
              {[
                { id: 'draw', label: 'Draw', icon: '‚úèÔ∏è' },
                { id: 'modify', label: 'Modify', icon: 'üîß' },
                { id: 'annotate', label: 'Annotate', icon: 'üìù' },
                { id: 'objects', label: 'Objects', icon: 'ü™ë' },
              ].map(tab => (
                <button
                  key={tab.id}
                  onClick={() => setToolTab(tab.id)}
                  style={{
                    padding: '10px 16px',
                    background: toolTab === tab.id ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                    border: `1px solid ${toolTab === tab.id ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                    borderRadius: '8px',
                    color: toolTab === tab.id ? '#00c8ff' : '#8899aa',
                    fontSize: '12px',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    whiteSpace: 'nowrap',
                  }}
                >
                  <span style={{ fontSize: '16px' }}>{tab.icon}</span>
                  {tab.label}
                </button>
              ))}
            </div>

            {/* Draw Tools */}
            {toolTab === 'draw' && (
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }}>
                {[
                  { name: 'wall', icon: '‚ñ≠', label: 'Wall' },
                  { name: 'door', icon: 'üö™', label: 'Door' },
                  { name: 'window', icon: '‚äû', label: 'Window' },
                  { name: 'room', icon: '‚¨ú', label: 'Room' },
                  { name: 'roof', icon: 'üè†', label: 'Roof' },
                  { name: 'line', icon: '‚ï±', label: 'Line' },
                ].map(t => (
                  <button
                    key={t.name}
                    onClick={() => { setTool(t.name); setShowMobileMenu(false); }}
                    style={{
                      padding: '14px',
                      background: tool === t.name ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                      border: `1px solid ${tool === t.name ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '10px',
                      color: tool === t.name ? '#00c8ff' : '#8899aa',
                      fontSize: '12px',
                      cursor: 'pointer',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: '4px',
                    }}
                  >
                    <span style={{ fontSize: '20px' }}>{t.icon}</span>
                    {t.label}
                  </button>
                ))}
              </div>
            )}

            {/* Modify Tools */}
            {toolTab === 'modify' && (
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }}>
                {[
                  { name: 'select', icon: '‚Üñ', label: 'Select' },
                  { name: 'move', icon: '‚ú•', label: 'Move' },
                  { name: 'rotate', icon: '‚Üª', label: 'Rotate' },
                  { name: 'extend', icon: '‚üº', label: 'Extend' },
                  { name: 'trim', icon: '‚úÇ', label: 'Trim' },
                  { name: 'corner', icon: '‚åê', label: 'Corner' },
                  { name: 'pan', icon: '‚úã', label: 'Pan' },
                ].map(t => (
                  <button
                    key={t.name}
                    onClick={() => { setTool(t.name); setShowMobileMenu(false); }}
                    style={{
                      padding: '14px',
                      background: tool === t.name ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                      border: `1px solid ${tool === t.name ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '10px',
                      color: tool === t.name ? '#00c8ff' : '#8899aa',
                      fontSize: '12px',
                      cursor: 'pointer',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: '4px',
                    }}
                  >
                    <span style={{ fontSize: '20px' }}>{t.icon}</span>
                    {t.label}
                  </button>
                ))}
              </div>
            )}

            {/* Annotate Tools */}
            {toolTab === 'annotate' && (
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }}>
                {[
                  { name: 'text', icon: 'T', label: 'Text' },
                  { name: 'dimension', icon: '‚Üî', label: 'Dimension' },
                  { name: 'measure', icon: 'üìè', label: 'Measure' },
                ].map(t => (
                  <button
                    key={t.name}
                    onClick={() => { setTool(t.name); setShowMobileMenu(false); }}
                    style={{
                      padding: '14px',
                      background: tool === t.name ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                      border: `1px solid ${tool === t.name ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '10px',
                      color: tool === t.name ? '#00c8ff' : '#8899aa',
                      fontSize: '12px',
                      cursor: 'pointer',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: '4px',
                    }}
                  >
                    <span style={{ fontSize: '20px' }}>{t.icon}</span>
                    {t.label}
                  </button>
                ))}
              </div>
            )}

            {/* Objects */}
            {toolTab === 'objects' && (
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '8px' }}>
                {[
                  { panel: 'furniture', icon: 'ü™ë', label: 'Furniture' },
                  { panel: 'stairs', icon: 'ü™ú', label: 'Stairs' },
                  { panel: 'electrical', icon: '‚ö°', label: 'Electrical' },
                  { panel: 'plumbing', icon: 'üîµ', label: 'Plumbing' },
                  { panel: 'hatch', icon: '‚ñ®', label: 'Hatch' },
                  { panel: 'porch', icon: 'üè†', label: 'Porch' },
                ].map(p => (
                  <button
                    key={p.panel}
                    onClick={() => { setActivePanel(p.panel); setShowMobileMenu(false); }}
                    style={{
                      padding: '14px',
                      background: activePanel === p.panel ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                      border: `1px solid ${activePanel === p.panel ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '10px',
                      color: activePanel === p.panel ? '#00c8ff' : '#8899aa',
                      fontSize: '14px',
                      cursor: 'pointer',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '8px',
                    }}
                  >
                    <span style={{ fontSize: '22px' }}>{p.icon}</span>
                    {p.label}
                  </button>
                ))}
              </div>
            )}
          </div>
          
          {/* Actions */}
          <div style={{ marginBottom: '16px' }}>
            <div style={{ color: '#6080a0', fontSize: '11px', marginBottom: '8px' }}>ACTIONS</div>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }}>
              <button onClick={() => { undo(); }} style={{ padding: '12px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: '#8899aa', fontSize: '12px', cursor: 'pointer' }}>‚Ü© Undo</button>
              <button onClick={() => { redo(); }} style={{ padding: '12px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: '#8899aa', fontSize: '12px', cursor: 'pointer' }}>‚Ü™ Redo</button>
              <button onClick={() => { setShow3D(!show3D); setShowMobileMenu(false); }} style={{ padding: '12px', background: show3D ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: show3D ? '#00c8ff' : '#8899aa', fontSize: '12px', cursor: 'pointer' }}>üßä 3D</button>
              <button onClick={() => { setShowLayersPanel(true); setShowMobileMenu(false); }} style={{ padding: '12px', background: showLayersPanel ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: showLayersPanel ? '#00c8ff' : '#8899aa', fontSize: '12px', cursor: 'pointer' }}>üìë Layers</button>
              <button onClick={() => { setShowSheetsPanel(true); setShowMobileMenu(false); }} style={{ padding: '12px', background: showSheetsPanel ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: showSheetsPanel ? '#00c8ff' : '#8899aa', fontSize: '12px', cursor: 'pointer' }}>üìã Sheets</button>
              <button onClick={() => { setShowSettings(true); setShowMobileMenu(false); }} style={{ padding: '12px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: '#8899aa', fontSize: '12px', cursor: 'pointer' }}>‚öôÔ∏è Settings</button>
              <button onClick={() => { saveProject(); setShowMobileMenu(false); }} style={{ padding: '12px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: '#8899aa', fontSize: '12px', cursor: 'pointer' }}>üíæ Save</button>
              <label style={{ padding: '12px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: '#8899aa', fontSize: '12px', cursor: 'pointer', textAlign: 'center' }}>
                üìÇ Open
                <input type="file" accept=".json" onChange={(e) => { loadProject(e); setShowMobileMenu(false); }} style={{ display: 'none' }} />
              </label>
              <button onClick={() => { exportImage(); setShowMobileMenu(false); }} style={{ padding: '12px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '10px', color: '#8899aa', fontSize: '12px', cursor: 'pointer' }}>üñºÔ∏è Export PNG</button>
              <button onClick={() => { setShowNewFileConfirm(true); setShowMobileMenu(false); }} style={{ padding: '12px', background: 'rgba(255,80,80,0.1)', border: '1px solid rgba(255,80,80,0.2)', borderRadius: '10px', color: '#ff8888', fontSize: '12px', cursor: 'pointer' }}>üìÑ New</button>
            </div>
          </div>
        </div>
      )}
      
      {/* Mobile Bottom Toolbar - always visible on mobile */}
      {isMobile && !showMobileMenu && (
        <div style={{
          position: 'fixed',
          bottom: 0,
          left: 0,
          right: 0,
          background: 'rgba(12,18,24,0.98)',
          borderTop: '1px solid rgba(0,200,255,0.15)',
          padding: '8px',
          display: 'flex',
          justifyContent: 'space-around',
          zIndex: 150,
        }}>
          {[
            { name: 'select', icon: '‚Üñ' },
            { name: 'move', icon: '‚ú•' },
            { name: 'rotate', icon: '‚Üª' },
            { name: 'wall', icon: '‚ñ≠' },
            { name: 'door', icon: 'üö™' },
            { name: 'window', icon: '‚äû' },
            { name: 'pan', icon: '‚úã' },
          ].map(t => (
            <button
              key={t.name}
              onClick={() => setTool(t.name)}
              style={{
                padding: '12px 16px',
                background: tool === t.name ? 'rgba(0,200,255,0.2)' : 'transparent',
                border: 'none',
                borderRadius: '10px',
                color: tool === t.name ? '#00c8ff' : '#6080a0',
                fontSize: '22px',
                cursor: 'pointer',
              }}
            >
              {t.icon}
            </button>
          ))}
        </div>
      )}
      
      {/* Mobile floating action buttons - undo/redo/delete (hide when editors are open) */}
      {isMobile && !showMobileMenu && !showWallEditor && !showDoorWindowEditor && !showRoomPanel && !showLayersPanel && !showSettings && !show3D && !showSheetsPanel && selectedItems[0]?.type !== 'furniture' && selectedItems[0]?.type !== 'dimension' && (
        <div style={{
          position: 'fixed',
          top: '60px',
          right: '10px',
          display: 'flex',
          flexDirection: 'column',
          gap: '8px',
          zIndex: 150,
        }}>
          <button
            onClick={undo}
            style={{
              width: '44px',
              height: '44px',
              borderRadius: '22px',
              background: 'rgba(12,18,24,0.95)',
              border: '1px solid rgba(0,200,255,0.3)',
              color: '#00c8ff',
              fontSize: '18px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            ‚Ü©
          </button>
          <button
            onClick={redo}
            style={{
              width: '44px',
              height: '44px',
              borderRadius: '22px',
              background: 'rgba(12,18,24,0.95)',
              border: '1px solid rgba(0,200,255,0.3)',
              color: '#00c8ff',
              fontSize: '18px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            ‚Ü™
          </button>
          {selectedItems.length > 0 && (
            <button
              onClick={deleteSelected}
              style={{
                width: '44px',
                height: '44px',
                borderRadius: '22px',
                background: 'rgba(255,80,80,0.2)',
                border: '1px solid rgba(255,80,80,0.5)',
                color: '#ff6666',
                fontSize: '18px',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
            >
              üóë
            </button>
          )}
        </div>
      )}
      
      {/* Restore editors button - shows when editors are minimized and an item is selected */}
      {editorsMinimized && selectedItems.length > 0 && (
        <button
          onClick={() => setEditorsMinimized(false)}
          style={{
            position: 'fixed',
            top: isMobile ? '60px' : '70px',
            right: isMobile ? '10px' : '16px',
            padding: isMobile ? '10px 14px' : '8px 12px',
            background: 'rgba(0,200,255,0.2)',
            border: '1px solid rgba(0,200,255,0.4)',
            borderRadius: '8px',
            color: '#00c8ff',
            fontSize: isMobile ? '12px' : '11px',
            cursor: 'pointer',
            zIndex: 250,
            display: 'flex',
            alignItems: 'center',
            gap: '6px',
          }}
        >
          <span>üìù</span>
          <span>Show Editor</span>
        </button>
      )}
      
      {/* Secondary toolbar - hide on mobile */}
      {!isMobile && (
      <div style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: '4px 12px',
        background: 'rgba(10,14,18,0.9)',
        borderBottom: '1px solid rgba(0,200,255,0.08)',
        minHeight: '32px',
      }}>
        {tool === 'dimension' && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <span style={{ color: '#6080a0', fontSize: '10px' }}>Style:</span>
            {Object.entries(DIMENSION_STYLES).map(([styleName, config]) => (
              <button
                key={styleName}
                onClick={() => setDimensionStyle(styleName)}
                style={{
                  padding: '3px 8px',
                  background: dimensionStyle === styleName ? 'rgba(0,200,255,0.2)' : 'transparent',
                  border: `1px solid ${dimensionStyle === styleName ? config.color : 'rgba(255,255,255,0.1)'}`,
                  borderRadius: '4px',
                  color: dimensionStyle === styleName ? config.color : '#6080a0',
                  fontSize: '9px',
                  cursor: 'pointer',
                  textTransform: 'capitalize',
                }}
              >
                {styleName}
              </button>
            ))}
            <span style={{ color: '#6080a0', fontSize: '10px', marginLeft: '8px' }}>|</span>
            <button
              onClick={() => setShowDimensions(!showDimensions)}
              style={{
                padding: '3px 8px',
                background: showDimensions ? 'rgba(0,255,170,0.2)' : 'rgba(255,80,80,0.1)',
                border: `1px solid ${showDimensions ? 'rgba(0,255,170,0.4)' : 'rgba(255,80,80,0.3)'}`,
                borderRadius: '4px',
                color: showDimensions ? '#00ffaa' : '#ff6666',
                fontSize: '9px',
                cursor: 'pointer',
              }}
            >
              {showDimensions ? 'üëÅ Show' : 'üö´ Hidden'}
            </button>
            <button
              onClick={autoDimensionWalls}
              style={{
                padding: '3px 8px',
                background: 'rgba(100,200,255,0.1)',
                border: '1px solid rgba(100,200,255,0.3)',
                borderRadius: '4px',
                color: '#66ccff',
                fontSize: '9px',
                cursor: 'pointer',
              }}
            >
              ‚ö° Auto Walls
            </button>
            <button
              onClick={clearAllDimensions}
              style={{
                padding: '3px 8px',
                background: 'rgba(255,80,80,0.1)',
                border: '1px solid rgba(255,80,80,0.3)',
                borderRadius: '4px',
                color: '#ff6666',
                fontSize: '9px',
                cursor: 'pointer',
              }}
            >
              üóë Clear All
            </button>
            {dimensionStart && (
              <span style={{ 
                color: '#00ffaa', 
                fontSize: '10px', 
                marginLeft: '8px',
                padding: '3px 8px',
                background: 'rgba(0,255,170,0.15)',
                borderRadius: '4px',
                animation: 'pulse 1s infinite',
              }}>
                ‚úì Point 1 set ‚Äî Click second point
              </span>
            )}
        </div>
        )}
        
        {tool === 'door' && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' }}>
            <span style={{ color: '#6080a0', fontSize: '10px' }}>Door Type:</span>
            {DOOR_TYPES.slice(0, 6).map(dtype => (
              <button
                key={dtype.id}
                onClick={() => setSelectedDoorType(dtype.id)}
                style={{
                  padding: '3px 6px',
                  background: selectedDoorType === dtype.id ? 'rgba(0,200,255,0.2)' : 'transparent',
                  border: `1px solid ${selectedDoorType === dtype.id ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                  borderRadius: '4px',
                  color: selectedDoorType === dtype.id ? '#00c8ff' : '#6080a0',
                  fontSize: '9px',
                  cursor: 'pointer',
                }}
                title={dtype.description}
              >
                {dtype.icon} {dtype.name}
              </button>
            ))}
            <span style={{ color: '#6080a0', fontSize: '9px' }}>Click on a wall to place</span>
          </div>
        )}
        
        {tool === 'window' && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' }}>
            <span style={{ color: '#6080a0', fontSize: '10px' }}>Window Type:</span>
            {WINDOW_TYPES.slice(0, 6).map(wtype => (
              <button
                key={wtype.id}
                onClick={() => setSelectedWindowType(wtype.id)}
                style={{
                  padding: '3px 6px',
                  background: selectedWindowType === wtype.id ? 'rgba(0,200,255,0.2)' : 'transparent',
                  border: `1px solid ${selectedWindowType === wtype.id ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                  borderRadius: '4px',
                  color: selectedWindowType === wtype.id ? '#00c8ff' : '#6080a0',
                  fontSize: '9px',
                  cursor: 'pointer',
                }}
                title={wtype.description}
              >
                {wtype.icon} {wtype.name}
              </button>
            ))}
            <span style={{ color: '#6080a0', fontSize: '9px' }}>Click on a wall to place</span>
          </div>
        )}
        
        {tool === 'text' && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' }}>
            <span style={{ color: '#6080a0', fontSize: '10px' }}>Text Style:</span>
            {Object.entries(TEXT_STYLES).map(([key, style]) => (
              <button
                key={key}
                onClick={() => setSelectedTextStyle(key)}
                style={{
                  padding: '3px 8px',
                  background: selectedTextStyle === key ? 'rgba(0,200,255,0.2)' : 'transparent',
                  border: `1px solid ${selectedTextStyle === key ? style.color : 'rgba(255,255,255,0.1)'}`,
                  borderRadius: '4px',
                  color: selectedTextStyle === key ? style.color : '#6080a0',
                  fontSize: '9px',
                  cursor: 'pointer',
                }}
              >
                {style.name}
              </button>
            ))}
            <span style={{ color: '#6080a0', fontSize: '9px', marginLeft: '8px' }}>Click anywhere to place text</span>
          </div>
        )}
        
        {tool === 'wall' && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
            <span style={{ color: '#6080a0', fontSize: '10px' }}>Type:</span>
            {Object.entries(WALL_THICKNESS_OPTIONS).map(([type, config]) => (
              <button
                key={type}
                onClick={() => setWallType(type)}
                style={{
                  padding: '3px 8px',
                  background: wallType === type ? 'rgba(0,200,255,0.2)' : 'transparent',
                  border: `1px solid ${wallType === type ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                  borderRadius: '4px',
                  color: wallType === type ? '#00c8ff' : '#6080a0',
                  fontSize: '9px',
                  cursor: 'pointer',
                }}
              >
                {config.label}
              </button>
            ))}
          </div>
        )}

        {tool === 'roof' && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
              <span style={{ color: '#6080a0', fontSize: '10px' }}>Type:</span>
              {Object.entries(ROOF_TYPES).slice(0, 4).map(([type, config]) => (
                <button
                  key={type}
                  onClick={() => setRoofType(type)}
                  style={{
                    padding: '3px 6px',
                    background: roofType === type ? 'rgba(0,200,255,0.2)' : 'transparent',
                    border: `1px solid ${roofType === type ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                    borderRadius: '4px',
                    color: roofType === type ? '#00c8ff' : '#6080a0',
                    fontSize: '9px',
                    cursor: 'pointer',
                  }}
                >
                  {config.label}
                </button>
              ))}
            </div>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
              <span style={{ color: '#6080a0', fontSize: '10px' }}>Pitch:</span>
              <select
                value={roofPitch}
                onChange={(e) => setRoofPitch(e.target.value)}
                style={{
                  padding: '3px 6px',
                  background: '#1a2028',
                  border: '1px solid rgba(255,255,255,0.1)',
                  borderRadius: '4px',
                  color: '#00c8ff',
                  fontSize: '9px',
                  cursor: 'pointer',
                }}
              >
                {Object.entries(ROOF_PITCHES).map(([key, def]) => (
                  <option key={key} value={key}>{def.label}</option>
                ))}
              </select>
            </div>
          </div>
        )}
        
        {tool === 'plumbing-line' && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <span style={{ color: '#ffaa00', fontSize: '10px' }}>Drawing {plumbingLineType} line - Click to set points, Escape to finish</span>
            <button
              onClick={() => { setPlumbingLineStart(null); setPlumbingLineType(null); setTool('select'); }}
              style={{ padding: '3px 8px', background: 'rgba(255,170,0,0.2)', border: '1px solid rgba(255,170,0,0.4)', borderRadius: '4px', color: '#ffaa00', fontSize: '9px', cursor: 'pointer' }}
            >
              Done
            </button>
          </div>
        )}
        
        {tool === 'measure' && measureStart && (
          <button onClick={() => { setMeasureStart(null); setMeasureEnd(null); }} style={{ padding: '3px 8px', background: 'rgba(255,170,0,0.2)', border: '1px solid rgba(255,170,0,0.4)', borderRadius: '4px', color: '#ffaa00', fontSize: '9px', cursor: 'pointer' }}>
            Clear Measurement
          </button>
        )}
        
        {!['wall', 'roof', 'measure', 'plumbing-line'].includes(tool) && <div />}
        
        <div style={{ display: 'flex', alignItems: 'center', gap: '6px', marginLeft: 'auto' }}>
          <button onClick={duplicateFloor} style={{ padding: '3px 8px', background: 'transparent', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#6080a0', fontSize: '9px', cursor: 'pointer' }}>Clone Floor</button>
          {floors.length > 1 && <button onClick={deleteFloor} style={{ padding: '3px 8px', background: 'rgba(255,80,80,0.1)', border: '1px solid rgba(255,80,80,0.3)', borderRadius: '4px', color: '#ff6666', fontSize: '9px', cursor: 'pointer' }}>Delete</button>}
          
          <div style={{ display: 'flex', alignItems: 'center', gap: '3px', marginLeft: '12px' }}>
            <button onClick={() => handleZoom(-0.2)} style={{ width: '24px', height: '24px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#8899aa', cursor: 'pointer', fontSize: '12px' }}>‚àí</button>
            <span style={{ color: '#5588aa', fontSize: '9px', minWidth: '36px', textAlign: 'center' }}>{(scale * 100).toFixed(0)}%</span>
            <button onClick={() => handleZoom(0.2)} style={{ width: '24px', height: '24px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#8899aa', cursor: 'pointer', fontSize: '12px' }}>+</button>
          </div>
          
          {clipboard && (
            <span style={{ color: '#00ffaa', fontSize: '9px', padding: '2px 6px', background: 'rgba(0,255,170,0.1)', borderRadius: '4px' }}>
              üìã {clipboard.items.walls.length + clipboard.items.furniture.length + clipboard.items.rooms.length} items copied
            </span>
          )}
          
          {selectedItems.length > 1 && (
            <span style={{ color: '#00c8ff', fontSize: '9px', padding: '2px 6px', background: 'rgba(0,200,255,0.1)', borderRadius: '4px' }}>
              {selectedItems.length} items selected
            </span>
          )}
          
          {/* Move/Rotate status hints */}
          {tool === 'move' && (
            <span style={{ color: '#00ff88', fontSize: '9px', padding: '2px 6px', background: 'rgba(0,255,136,0.1)', borderRadius: '4px' }}>
              {selectedItems.length === 0 ? '‚ú• Select item to move' :
               !moveBasePoint ? '‚ú• Click base point' : '‚ú• Click destination'}
            </span>
          )}
          
          {tool === 'rotate' && (
            <span style={{ color: '#ff8800', fontSize: '9px', padding: '2px 6px', background: 'rgba(255,136,0,0.1)', borderRadius: '4px' }}>
              {selectedItems.length === 0 ? '‚Üª Select item to rotate' :
               !rotateCenter ? '‚Üª Click center point' : 
               rotateStartAngle === null ? '‚Üª Click reference point' : '‚Üª Click to set angle'}
            </span>
          )}
          
          {selectedItems.length > 0 && (
            <>
              {(selectedItems[0].type === 'furniture' || selectedItems[0].type === 'stairs') && (
                <button onClick={() => rotateItem(selectedItems[0].item.id, selectedItems[0].type)} style={{ padding: '3px 8px', background: 'rgba(0,200,255,0.1)', border: '1px solid rgba(0,200,255,0.3)', borderRadius: '4px', color: '#00c8ff', fontSize: '9px', cursor: 'pointer' }}>‚Üª Rotate</button>
              )}
              <button onClick={deleteSelected} style={{ padding: '3px 8px', background: 'rgba(255,80,80,0.15)', border: '1px solid rgba(255,80,80,0.3)', borderRadius: '4px', color: '#ff6666', fontSize: '9px', cursor: 'pointer' }}>üóë Delete</button>
            </>
          )}
        </div>
      </div>
      )}
      
      {/* Main area */}
      <div style={{ flex: 1, display: 'flex', position: 'relative', paddingBottom: isMobile ? '70px' : 0 }}>
        {/* Side Panel / Bottom Sheet */}
        {activePanel && (
          <div style={{
            position: 'absolute',
            ...(isMobile ? {
              left: 0,
              right: 0,
              bottom: isMobile ? '70px' : 0,
              height: '50%',
              borderRadius: '16px 16px 0 0',
            } : {
              left: '10px',
              top: '10px',
              bottom: '10px',
              width: '200px',
              borderRadius: '10px',
            }),
            background: 'rgba(10,14,18,0.98)',
            border: '1px solid rgba(0,200,255,0.2)',
            display: 'flex',
            flexDirection: 'column',
            overflow: 'hidden',
            zIndex: 100,
            boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
          }}>
            {/* Drag handle for mobile */}
            {isMobile && (
              <div style={{ padding: '8px', display: 'flex', justifyContent: 'center' }}>
                <div style={{ width: '40px', height: '4px', background: 'rgba(255,255,255,0.2)', borderRadius: '2px' }} />
              </div>
            )}
            
            <div style={{ padding: isMobile ? '12px 16px' : '10px', borderBottom: '1px solid rgba(255,255,255,0.1)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <div style={{ color: '#fff', fontSize: isMobile ? '14px' : '11px', fontWeight: '600' }}>
                {activePanel === 'furniture' && 'Furniture Library'}
                {activePanel === 'stairs' && 'Stairs & Ramps'}
                {activePanel === 'electrical' && 'Electrical'}
                {activePanel === 'plumbing' && 'Plumbing'}
                {activePanel === 'lines' && 'Lines & Shapes'}
                {activePanel === 'hatch' && 'Hatch Patterns'}
                {activePanel === 'porch' && 'Porches & Decks'}
              </div>
              <button 
                onClick={() => setActivePanel(null)}
                style={{ background: 'rgba(255,255,255,0.1)', border: 'none', color: '#fff', cursor: 'pointer', fontSize: isMobile ? '20px' : '16px', padding: isMobile ? '8px 12px' : '0 4px', borderRadius: '8px' }}
              >√ó</button>
            </div>
            
            {activePanel === 'furniture' && (
              <div style={{ padding: isMobile ? '8px 16px' : '6px 10px', borderBottom: '1px solid rgba(255,255,255,0.05)' }}>
                <select
                  value={furnitureCategory}
                  onChange={(e) => setFurnitureCategory(e.target.value)}
                  style={{ 
                    width: '100%', 
                    padding: isMobile ? '10px' : '5px', 
                    background: '#1a2028', 
                    border: '1px solid rgba(255,255,255,0.1)', 
                    borderRadius: isMobile ? '8px' : '4px', 
                    color: '#fff', 
                    fontSize: isMobile ? '14px' : '10px',
                    cursor: 'pointer',
                  }}
                >
                  <option value="all" style={{ background: '#1a2028', color: '#fff' }}>All</option>
                  <option value="bedroom" style={{ background: '#1a2028', color: '#fff' }}>Bedroom</option>
                  <option value="living" style={{ background: '#1a2028', color: '#fff' }}>Living</option>
                  <option value="dining" style={{ background: '#1a2028', color: '#fff' }}>Dining</option>
                  <option value="kitchen" style={{ background: '#1a2028', color: '#fff' }}>Kitchen</option>
                  <option value="bathroom" style={{ background: '#1a2028', color: '#fff' }}>Bathroom</option>
                  <option value="office" style={{ background: '#1a2028', color: '#fff' }}>Office</option>
                  <option value="utility" style={{ background: '#1a2028', color: '#fff' }}>Utility</option>
                </select>
              </div>
            )}
            
            <div style={{ flex: 1, overflowY: 'auto', padding: isMobile ? '8px 16px' : '6px' }}>
              {/* Mobile: Grid layout, Desktop: List layout */}
              <div style={isMobile ? { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' } : {}}>
                {activePanel === 'furniture' && filteredFurniture.map(item => (
                  <button 
                    key={item.id} 
                    onClick={() => { addFurniture(item); if (isMobile) setActivePanel(null); }} 
                    style={{ 
                      width: '100%', 
                      display: 'flex', 
                      flexDirection: isMobile ? 'column' : 'row',
                      alignItems: 'center', 
                      gap: isMobile ? '4px' : '8px', 
                      padding: isMobile ? '12px 8px' : '8px', 
                      marginBottom: isMobile ? 0 : '3px', 
                      background: 'rgba(255,255,255,0.03)', 
                      border: '1px solid rgba(255,255,255,0.08)', 
                      borderRadius: isMobile ? '10px' : '5px', 
                      color: '#c0d0e0', 
                      cursor: 'pointer', 
                      textAlign: isMobile ? 'center' : 'left' 
                    }}
                  >
                    <span style={{ fontSize: isMobile ? '24px' : '18px' }}>{item.icon}</span>
                    <div>
                      <div style={{ fontSize: isMobile ? '11px' : '10px', fontWeight: '500' }}>{item.name}</div>
                      {!isMobile && <div style={{ fontSize: '8px', color: '#6080a0' }}>{item.width}"√ó{item.height}"</div>}
                    </div>
                  </button>
                ))}
                
                {activePanel === 'stairs' && STAIRS_LIBRARY.map(item => (
                  <button 
                    key={item.id} 
                    onClick={() => { addStairs(item); if (isMobile) setActivePanel(null); }} 
                    style={{ 
                      width: '100%', 
                      display: 'flex', 
                      flexDirection: isMobile ? 'column' : 'row',
                      alignItems: 'center', 
                      gap: isMobile ? '4px' : '8px', 
                      padding: isMobile ? '12px 8px' : '8px', 
                      marginBottom: isMobile ? 0 : '3px', 
                      background: 'rgba(255,255,255,0.03)', 
                      border: '1px solid rgba(255,255,255,0.08)', 
                      borderRadius: isMobile ? '10px' : '5px', 
                      color: '#c0d0e0', 
                      cursor: 'pointer', 
                      textAlign: isMobile ? 'center' : 'left' 
                    }}
                  >
                    <span style={{ fontSize: isMobile ? '24px' : '18px' }}>{item.icon}</span>
                    <div>
                      <div style={{ fontSize: isMobile ? '11px' : '10px', fontWeight: '500' }}>{item.name}</div>
                      {!isMobile && <div style={{ fontSize: '8px', color: '#6080a0' }}>{item.width}"√ó{item.height}"</div>}
                    </div>
                  </button>
                ))}
                
                {activePanel === 'electrical' && ELECTRICAL_LIBRARY.map(item => (
                  <button 
                    key={item.id} 
                    onClick={() => { addElectrical(item); if (isMobile) setActivePanel(null); }} 
                    style={{ 
                      width: '100%', 
                      display: 'flex', 
                      flexDirection: isMobile ? 'column' : 'row',
                      alignItems: 'center', 
                      gap: isMobile ? '4px' : '8px', 
                      padding: isMobile ? '12px 8px' : '8px', 
                      marginBottom: isMobile ? 0 : '3px', 
                      background: 'rgba(255,255,255,0.03)', 
                      border: '1px solid rgba(255,255,255,0.08)', 
                      borderRadius: isMobile ? '10px' : '5px', 
                      color: '#c0d0e0', 
                      cursor: 'pointer', 
                      textAlign: isMobile ? 'center' : 'left' 
                    }}
                  >
                    <span style={{ fontSize: isMobile ? '24px' : '16px' }}>{item.icon}</span>
                    <div>
                      <div style={{ fontSize: isMobile ? '11px' : '10px', fontWeight: '500' }}>{item.name}</div>
                      {!isMobile && <div style={{ fontSize: '8px', color: '#6080a0' }}>{item.category}</div>}
                    </div>
                  </button>
                ))}
                
                {activePanel === 'plumbing' && PLUMBING_LIBRARY.map(item => (
                  <button 
                    key={item.id} 
                    onClick={() => { addPlumbing(item); if (isMobile) setActivePanel(null); }} 
                    style={{ 
                      width: '100%', 
                      display: 'flex', 
                      flexDirection: isMobile ? 'column' : 'row',
                      alignItems: 'center', 
                      gap: isMobile ? '4px' : '8px', 
                      padding: isMobile ? '12px 8px' : '8px', 
                      marginBottom: isMobile ? 0 : '3px', 
                      background: item.lineType ? 'rgba(100,150,255,0.1)' : 'rgba(255,255,255,0.03)', 
                      border: '1px solid rgba(255,255,255,0.08)', 
                      borderRadius: isMobile ? '10px' : '5px', 
                      color: '#c0d0e0', 
                      cursor: 'pointer', 
                      textAlign: isMobile ? 'center' : 'left' 
                    }}
                  >
                    <span style={{ fontSize: isMobile ? '24px' : '16px' }}>{item.icon}</span>
                    <div>
                      <div style={{ fontSize: isMobile ? '11px' : '10px', fontWeight: '500' }}>{item.name}</div>
                      {!isMobile && <div style={{ fontSize: '8px', color: '#6080a0' }}>{item.lineType ? 'Click to draw line' : 'Fixture'}</div>}
                    </div>
                  </button>
                ))}
                
                {/* Lines Panel */}
                {activePanel === 'lines' && (
                  <div style={{ padding: '8px' }}>
                    <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '8px' }}>LINE TYPE</div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px', marginBottom: '12px' }}>
                      {Object.entries(LINE_TYPES).map(([key, lt]) => (
                        <button
                          key={key}
                          onClick={() => { setLineType(key); setTool('line'); }}
                          style={{
                            padding: '8px',
                            background: lineType === key ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.03)',
                            border: `1px solid ${lineType === key ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.08)'}`,
                            borderRadius: '6px',
                            color: lineType === key ? '#00c8ff' : '#aaa',
                            fontSize: '10px',
                            cursor: 'pointer',
                          }}
                        >
                          {lt.name}
                        </button>
                      ))}
                    </div>
                    
                    <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '8px' }}>LINE WEIGHT</div>
                    <div style={{ display: 'flex', gap: '4px', marginBottom: '12px' }}>
                      {[1, 2, 3, 4].map(w => (
                        <button
                          key={w}
                          onClick={() => setLineWeight(w)}
                          style={{
                            flex: 1,
                            padding: '8px',
                            background: lineWeight === w ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.03)',
                            border: `1px solid ${lineWeight === w ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.08)'}`,
                            borderRadius: '6px',
                            color: lineWeight === w ? '#00c8ff' : '#aaa',
                            fontSize: '10px',
                            cursor: 'pointer',
                          }}
                        >
                          {w}px
                        </button>
                      ))}
                    </div>
                    
                    <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '8px' }}>DRAWING TOOLS</div>
                    <button
                      onClick={() => setTool('line')}
                      style={{
                        width: '100%',
                        padding: '10px',
                        marginBottom: '6px',
                        background: tool === 'line' ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.03)',
                        border: `1px solid ${tool === 'line' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.08)'}`,
                        borderRadius: '6px',
                        color: tool === 'line' ? '#00c8ff' : '#aaa',
                        fontSize: '11px',
                        cursor: 'pointer',
                        textAlign: 'left',
                      }}
                    >
                      ‚úèÔ∏è Draw Line
                    </button>
                    <button
                      onClick={() => { setTool('polyline'); setPolylinePoints([]); setIsDrawingPolyline(false); }}
                      style={{
                        width: '100%',
                        padding: '10px',
                        marginBottom: '6px',
                        background: tool === 'polyline' ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.03)',
                        border: `1px solid ${tool === 'polyline' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.08)'}`,
                        borderRadius: '6px',
                        color: tool === 'polyline' ? '#00c8ff' : '#aaa',
                        fontSize: '11px',
                        cursor: 'pointer',
                        textAlign: 'left',
                      }}
                    >
                      „Ä∞Ô∏è Polyline (click points)
                    </button>
                    
                    {isDrawingPolyline && (tool === 'polyline' || tool === 'freehand') && (
                      <button
                        onClick={() => {
                          if (polylinePoints.length >= 2) {
                            const newPoly = {
                              id: generateId(),
                              points: [...polylinePoints],
                              lineType: lineType,
                              lineWeight: lineWeight,
                              closed: false,
                              color: '#aaaaaa',
                            };
                            updateActiveFloor(f => ({
                              ...f,
                              polylines: [...(f.polylines || []), newPoly]
                            }));
                          }
                          setPolylinePoints([]);
                          setIsDrawingPolyline(false);
                        }}
                        style={{
                          width: '100%',
                          padding: '10px',
                          background: 'rgba(0,255,170,0.2)',
                          border: '1px solid rgba(0,255,170,0.4)',
                          borderRadius: '6px',
                          color: '#00ffaa',
                          fontSize: '11px',
                          cursor: 'pointer',
                        }}
                      >
                        ‚úì Finish Polyline ({polylinePoints.length} pts)
                      </button>
                    )}
                  </div>
                )}
                
                {/* Hatch Panel */}
                {activePanel === 'hatch' && (
                  <div style={{ padding: '8px' }}>
                    <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '8px' }}>SELECT PATTERN</div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px', marginBottom: '12px' }}>
                      {Object.entries(HATCH_PATTERNS).map(([key, pattern]) => (
                        <button
                          key={key}
                          onClick={() => { setHatchPattern(key); setTool('hatch'); }}
                          style={{
                            padding: '10px 8px',
                            background: hatchPattern === key ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.03)',
                            border: `1px solid ${hatchPattern === key ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.08)'}`,
                            borderRadius: '6px',
                            color: hatchPattern === key ? '#00c8ff' : '#aaa',
                            fontSize: '10px',
                            cursor: 'pointer',
                            textAlign: 'left',
                          }}
                        >
                          <div style={{ width: '20px', height: '20px', background: pattern.color, borderRadius: '3px', marginBottom: '4px', opacity: 0.7 }} />
                          {pattern.name}
                        </button>
                      ))}
                    </div>
                    
                    <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '8px' }}>PATTERN SCALE</div>
                    <div style={{ display: 'flex', gap: '4px', marginBottom: '12px' }}>
                      {[0.5, 1, 1.5, 2].map(s => (
                        <button
                          key={s}
                          onClick={() => setHatchScale(s)}
                          style={{
                            flex: 1,
                            padding: '8px',
                            background: hatchScale === s ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.03)',
                            border: `1px solid ${hatchScale === s ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.08)'}`,
                            borderRadius: '6px',
                            color: hatchScale === s ? '#00c8ff' : '#aaa',
                            fontSize: '10px',
                            cursor: 'pointer',
                          }}
                        >
                          {s}√ó
                        </button>
                      ))}
                    </div>
                    
                    <button
                      onClick={() => { setTool('hatch'); setPolylinePoints([]); setIsDrawingPolyline(false); }}
                      style={{
                        width: '100%',
                        padding: '12px',
                        background: tool === 'hatch' ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                        border: `1px solid ${tool === 'hatch' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '6px',
                        color: tool === 'hatch' ? '#00c8ff' : '#aaa',
                        fontSize: '11px',
                        cursor: 'pointer',
                      }}
                    >
                      ‚ñ® Draw Hatch Area
                    </button>
                    
                    {isDrawingPolyline && tool === 'hatch' && (
                      <div style={{ marginTop: '8px', padding: '8px', background: 'rgba(0,200,255,0.1)', borderRadius: '6px' }}>
                        <div style={{ color: '#00c8ff', fontSize: '10px' }}>
                          Drawing hatch boundary: {polylinePoints.length} points
                        </div>
                        <div style={{ color: '#6080a0', fontSize: '9px', marginTop: '4px' }}>
                          Click to add points. Click first point (green) to close and create hatch.
                        </div>
                      </div>
                    )}
                  </div>
                )}
                
                {/* Porch Panel */}
                {activePanel === 'porch' && (
                  <div style={{ padding: '8px' }}>
                    <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '8px' }}>PORCH TYPE</div>
                    {Object.entries(PORCH_TYPES).map(([key, porch]) => (
                      <button
                        key={key}
                        onClick={() => { setPorchType(key); setTool('porch'); }}
                        style={{
                          width: '100%',
                          padding: '10px',
                          marginBottom: '6px',
                          background: porchType === key && tool === 'porch' ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.03)',
                          border: `1px solid ${porchType === key && tool === 'porch' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.08)'}`,
                          borderRadius: '6px',
                          color: porchType === key && tool === 'porch' ? '#00c8ff' : '#aaa',
                          fontSize: '11px',
                          cursor: 'pointer',
                          textAlign: 'left',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '10px',
                        }}
                      >
                        <div style={{
                          width: '24px',
                          height: '24px',
                          background: porch.color,
                          borderRadius: '4px',
                          border: '1px solid rgba(139,119,101,0.5)',
                        }} />
                        <div>
                          <div>{porch.name}</div>
                          <div style={{ fontSize: '9px', color: '#6080a0' }}>
                            {porch.hasRoof ? 'üè† Roof' : ''} 
                            {porch.hasScreens ? ' ü™ü Screened' : ''}
                            {porch.hasGlass ? ' ‚ú® Glass' : ''}
                            {!porch.hasRoof && !porch.hasScreens ? '‚òÄÔ∏è Open' : ''}
                          </div>
                        </div>
                      </button>
                    ))}
                    
                    <div style={{ marginTop: '12px', padding: '8px', background: 'rgba(139,119,101,0.1)', borderRadius: '6px' }}>
                      <div style={{ color: '#886644', fontSize: '10px' }}>
                        üí° Click and drag to draw porch area
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        )}
        
        {/* Canvas */}
        <div ref={containerRef} style={{ flex: 1, position: 'relative' }}>
          <canvas
            ref={canvasRef}
            width={dimensions.width}
            height={dimensions.height}
            onMouseDown={handlePointerDown}
            onMouseMove={handlePointerMove}
            onMouseUp={handlePointerUp}
            onMouseLeave={handlePointerUp}
            onTouchStart={handlePointerDown}
            onTouchMove={handlePointerMove}
            onTouchEnd={handlePointerUp}
            onWheel={handleWheel}
            style={{ 
              cursor: tool === 'pan' ? 'grab' : tool === 'select' ? 'default' : 'crosshair',
              touchAction: 'none',
              userSelect: 'none',
              WebkitUserSelect: 'none',
              WebkitTouchCallout: 'none',
            }}
          />
          
          {/* Wall Editor Panel */}
          {showWallEditor && selectedWall && !editorsMinimized && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '180px' : '200px',
              zIndex: 250,
              maxHeight: isMobile ? '60vh' : 'auto',
              overflowY: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>Edit Wall</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button onClick={() => setEditorsMinimized(true)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px', padding: '4px' }} title="Minimize">‚àí</button>
                  <button onClick={() => setShowWallEditor(false)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '18px', padding: '4px' }}>√ó</button>
                </div>
              </div>
              
              <MeasurementInput
                label="Length"
                value={parseFloat(selectedWall.lengthFeet)}
                onChange={(val) => updateWall(selectedWall.id, { length: val })}
                units={units}
                formatMeasurement={formatMeasurement}
              />
              
              <MeasurementInput
                label="Height"
                value={parseFloat(selectedWall.heightFeet)}
                onChange={(val) => updateWall(selectedWall.id, { height: feetToInches(val) })}
                units={units}
                formatMeasurement={formatMeasurement}
              />
              
              <div style={{ marginBottom: '8px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Wall Type</label>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px' }}>
                  {Object.entries(WALL_THICKNESS_OPTIONS).map(([type, config]) => (
                    <button
                      key={type}
                      onClick={() => updateWall(selectedWall.id, { type, height: config.defaultHeight })}
                      style={{
                        padding: '6px',
                        background: selectedWall.type === type ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${selectedWall.type === type ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: selectedWall.type === type ? '#00c8ff' : '#8899aa',
                        fontSize: '9px',
                        cursor: 'pointer',
                      }}
                    >
                      {config.label}
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{ marginTop: '12px', padding: '8px', background: 'rgba(0,200,255,0.05)', borderRadius: '4px' }}>
                <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '4px' }}>Quick Info</div>
                <div style={{ color: '#00c8ff', fontSize: '10px' }}>
                  {formatMeasurement(selectedWall.lengthFeet)} L √ó {formatMeasurement(selectedWall.heightFeet)} H
                </div>
                <div style={{ color: '#6080a0', fontSize: '9px' }}>
                  Thickness: {WALL_THICKNESS_OPTIONS[selectedWall.type]?.thickness || 8}px
                </div>
              </div>
              
              <button
                onClick={() => {
                  updateActiveFloor(f => ({
                    ...f,
                    walls: f.walls.filter(w => w.id !== selectedWall.id)
                  }));
                  setSelectedWall(null);
                  setShowWallEditor(false);
                }}
                style={{
                  width: '100%',
                  marginTop: '12px',
                  padding: '10px',
                  background: 'rgba(255,80,80,0.15)',
                  border: '1px solid rgba(255,80,80,0.4)',
                  borderRadius: '6px',
                  color: '#ff6666',
                  fontSize: '11px',
                  fontWeight: '500',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '6px',
                }}
              >
                üóëÔ∏è Delete Wall
              </button>
              
              <div style={{ marginTop: '10px', fontSize: '9px', color: '#6080a0', lineHeight: '1.4' }}>
                üí° Drag to move wall<br/>
                ‚áß Shift+click to multi-select<br/>
                üìã Ctrl+C/V to copy/paste
              </div>
            </div>
          )}
          
          {/* Dimension Editor Panel */}
          {selectedItems[0]?.type === 'dimension' && !editorsMinimized && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '180px' : '200px',
              zIndex: 250,
              maxHeight: isMobile ? '50vh' : 'auto',
              overflowY: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>Edit Dimension</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button onClick={() => setEditorsMinimized(true)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px', padding: '4px' }} title="Minimize">‚àí</button>
                  <button onClick={() => setSelectedItems([])} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px' }}>√ó</button>
                </div>
              </div>
              
              <InputField
                label="Custom Label (leave empty for auto)"
                value={selectedItems[0].item.label || ''}
                onChange={(val) => updateActiveFloor(f => ({
                  ...f,
                  dimensions: f.dimensions.map(d => 
                    d.id === selectedItems[0].item.id ? { ...d, label: val } : d
                  )
                }))}
              />
              
              <InputField
                label="Offset Distance"
                value={selectedItems[0].item.offset}
                onChange={(val) => updateActiveFloor(f => ({
                  ...f,
                  dimensions: f.dimensions.map(d => 
                    d.id === selectedItems[0].item.id ? { ...d, offset: parseInt(val) || 25 } : d
                  )
                }))}
                type="number"
              />
              
              <div style={{ marginBottom: '8px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Style</label>
                <div style={{ display: 'flex', gap: '4px' }}>
                  {Object.entries(DIMENSION_STYLES).map(([styleName, config]) => (
                    <button
                      key={styleName}
                      onClick={() => updateActiveFloor(f => ({
                        ...f,
                        dimensions: f.dimensions.map(d => 
                          d.id === selectedItems[0].item.id ? { ...d, style: styleName } : d
                        )
                      }))}
                      style={{
                        flex: 1,
                        padding: '6px',
                        background: selectedItems[0].item.style === styleName ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${selectedItems[0].item.style === styleName ? config.color : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: selectedItems[0].item.style === styleName ? config.color : '#8899aa',
                        fontSize: '9px',
                        cursor: 'pointer',
                        textTransform: 'capitalize',
                      }}
                    >
                      {styleName}
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{ marginTop: '12px', padding: '8px', background: 'rgba(0,200,255,0.05)', borderRadius: '4px' }}>
                <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '4px' }}>Measured Length</div>
                <div style={{ color: '#00c8ff', fontSize: '14px', fontWeight: '600' }}>
                  {formatMeasurement(pixelsToFeet(distance(selectedItems[0].item.start, selectedItems[0].item.end)))}
                </div>
              </div>
            </div>
          )}
          
          {/* Door Editor Panel */}
          {showDoorWindowEditor && selectedItems[0]?.type === 'door' && !editorsMinimized && (
            <div
              key={`door-editor-${selectedItems[0].item.id}`}
              onTouchStart={(e) => e.stopPropagation()}
              onTouchMove={(e) => e.stopPropagation()}
              onTouchEnd={(e) => e.stopPropagation()}
              onPointerDown={(e) => e.stopPropagation()}
              style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '190px' : '220px',
              maxHeight: isMobile ? '55vh' : '80vh',
              overflowY: 'auto',
              zIndex: 250,
              touchAction: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>üö™ Edit Door</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button onClick={() => setEditorsMinimized(true)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px', padding: '4px' }} title="Minimize">‚àí</button>
                  <button onClick={() => { setShowDoorWindowEditor(false); setSelectedItems([]); }} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '18px', padding: '4px' }}>√ó</button>
                </div>
              </div>
              
              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Door Type</label>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px' }}>
                  {DOOR_TYPES.map(dtype => (
                    <button
                      key={dtype.id}
                      onClick={() => updateDoor(selectedItems[0].item.id, { type: dtype.id, width: dtype.defaultWidth * (GRID_SIZE / 6) })}
                      style={{
                        padding: '6px 4px',
                        background: selectedItems[0].item.type === dtype.id ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${selectedItems[0].item.type === dtype.id ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: selectedItems[0].item.type === dtype.id ? '#00c8ff' : '#8899aa',
                        fontSize: '9px',
                        cursor: 'pointer',
                      }}
                    >
                      {dtype.icon} {dtype.name}
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{ marginBottom: '8px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Width (inches)</label>
                <input
                  type="text"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  value={selectedItems[0].item.width ? Math.round(selectedItems[0].item.width / (GRID_SIZE / 6)) : 36}
                  onChange={(e) => {
                    const val = e.target.value;
                    if (val === '' || /^\d+$/.test(val)) {
                      updateDoor(selectedItems[0].item.id, { width: (parseInt(val) || 36) * (GRID_SIZE / 6) });
                    }
                  }}
                  style={{
                    width: '100%',
                    padding: '10px 12px',
                    background: 'rgba(255,255,255,0.1)',
                    border: '2px solid rgba(0,200,255,0.3)',
                    borderRadius: '6px',
                    color: '#fff',
                    fontSize: '16px',
                    boxSizing: 'border-box',
                  }}
                />
              </div>
              
              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Swing Direction</label>
                <div style={{ display: 'flex', gap: '4px' }}>
                  {['left', 'right', 'both'].map(swing => (
                    <button
                      key={swing}
                      onClick={() => updateDoor(selectedItems[0].item.id, { swing })}
                      style={{
                        flex: 1,
                        padding: '6px',
                        background: selectedItems[0].item.swing === swing ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${selectedItems[0].item.swing === swing ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: selectedItems[0].item.swing === swing ? '#00c8ff' : '#8899aa',
                        fontSize: '9px',
                        cursor: 'pointer',
                        textTransform: 'capitalize',
                      }}
                    >
                      {swing === 'left' ? '‚Üê Left' : swing === 'right' ? 'Right ‚Üí' : '‚Üî Both'}
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Open Direction</label>
                <div style={{ display: 'flex', gap: '4px' }}>
                  {['inward', 'outward'].map(dir => (
                    <button
                      key={dir}
                      onClick={() => updateDoor(selectedItems[0].item.id, { openDirection: dir })}
                      style={{
                        flex: 1,
                        padding: '6px',
                        background: (selectedItems[0].item.openDirection || 'inward') === dir ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${(selectedItems[0].item.openDirection || 'inward') === dir ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: (selectedItems[0].item.openDirection || 'inward') === dir ? '#00c8ff' : '#8899aa',
                        fontSize: '9px',
                        cursor: 'pointer',
                        textTransform: 'capitalize',
                      }}
                    >
                      {dir === 'inward' ? '‚Üì Inward' : '‚Üë Outward'}
                    </button>
                  ))}
                </div>
              </div>
              
              <button
                onClick={() => {
                  const currentSwing = selectedItems[0].item.swing || 'left';
                  const newSwing = currentSwing === 'left' ? 'right' : currentSwing === 'right' ? 'left' : 'both';
                  updateDoor(selectedItems[0].item.id, { swing: newSwing });
                }}
                style={{
                  width: '100%',
                  padding: '8px',
                  background: 'rgba(0,200,255,0.1)',
                  border: '1px solid rgba(0,200,255,0.3)',
                  borderRadius: '4px',
                  color: '#00c8ff',
                  fontSize: '10px',
                  cursor: 'pointer',
                  marginBottom: '10px',
                }}
              >
                üîÑ Flip Door
              </button>
              
              <div style={{ marginTop: '12px', padding: '8px', background: 'rgba(0,200,255,0.05)', borderRadius: '4px' }}>
                <div style={{ color: '#00c8ff', fontSize: '11px' }}>
                  {formatMeasurement(((selectedItems[0].item.width || 72) / (GRID_SIZE / 6) / 12).toFixed(1))} wide
                </div>
                <div style={{ color: '#6080a0', fontSize: '9px', marginTop: '2px' }}>
                  {DOOR_TYPES.find(d => d.id === selectedItems[0].item.type)?.description || 'Standard door'}
                </div>
              </div>
              
              <div style={{ marginTop: '10px', fontSize: '9px', color: '#6080a0' }}>
                üí° Drag the door along the wall to reposition
              </div>
              
              {/* Delete Button */}
              <button
                onClick={() => {
                  updateActiveFloor(f => ({ ...f, doors: f.doors.filter(d => d.id !== selectedItems[0].item.id) }));
                  setSelectedItems([]);
                  setShowDoorWindowEditor(false);
                }}
                style={{
                  width: '100%',
                  padding: '10px',
                  marginTop: '12px',
                  background: 'rgba(255,80,80,0.15)',
                  border: '1px solid rgba(255,80,80,0.4)',
                  borderRadius: '6px',
                  color: '#ff6666',
                  fontSize: '11px',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '6px',
                }}
              >
                üóë Delete Door
              </button>
              
              {/* Linked Dimensions Section - Door */}
              {linkedDimensions.length > 0 && (
                <div style={{ marginTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '12px' }}>
                  <div style={{ color: '#6080a0', fontSize: '10px', marginBottom: '4px' }}>
                    üîó LINKED DIMENSIONS ({linkedDimensions.length})
                  </div>
                  <div style={{ color: '#4a5568', fontSize: '8px', marginBottom: '8px' }}>
                    Edit length to move door position
                  </div>
                  {linkedDimensions.map((dim) => {
                    const dimStart = resolveLinkPoint(dim.startLink, dim.start);
                    const dimEnd = resolveLinkPoint(dim.endLink, dim.end);
                    const length = distance(dimStart, dimEnd);
                    const lengthFeet = pixelsToFeet(length);
                    
                    return (
                      <div key={dim.id} style={{
                        background: 'rgba(0,200,255,0.08)',
                        border: '1px solid rgba(0,200,255,0.2)',
                        borderRadius: '6px',
                        padding: '10px',
                        marginBottom: '8px',
                      }}
                      onTouchStart={(e) => e.stopPropagation()}
                      onTouchMove={(e) => e.stopPropagation()}
                      onTouchEnd={(e) => e.stopPropagation()}
                      onPointerDown={(e) => e.stopPropagation()}
                      >
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }}>
                          <span style={{ color: '#6080a0', fontSize: '9px' }}>üìè Distance:</span>
                          <button
                            onClick={() => deleteLinkedDimension(dim.id)}
                            style={{ background: 'none', border: 'none', color: '#ff6666', cursor: 'pointer', fontSize: '12px', padding: '2px 6px' }}
                            title="Delete dimension"
                          >√ó</button>
                        </div>
                        
                        <input
                          type="text"
                          inputMode="decimal"
                          defaultValue={formatMeasurement(lengthFeet)}
                          key={`${dim.id}-${Math.round(lengthFeet * 100)}`}
                          onBlur={(e) => {
                            const parsed = parseFeetInches(e.target.value);
                            if (parsed !== null && parsed > 0) {
                              updateLinkedItemByDimension(dim, parsed);
                            }
                          }}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              const parsed = parseFeetInches(e.target.value);
                              if (parsed !== null && parsed > 0) {
                                updateLinkedItemByDimension(dim, parsed);
                              }
                              e.target.blur();
                            }
                          }}
                          onTouchStart={(e) => e.stopPropagation()}
                          onTouchMove={(e) => e.stopPropagation()}
                          onTouchEnd={(e) => e.stopPropagation()}
                          onMouseDown={(e) => e.stopPropagation()}
                          onPointerDown={(e) => e.stopPropagation()}
                          onClick={(e) => { e.stopPropagation(); e.target.focus(); }}
                          autoComplete="off"
                          autoCorrect="off"
                          style={{
                            width: '100%',
                            padding: '10px 12px',
                            background: 'rgba(0,0,0,0.3)',
                            border: '2px solid rgba(0,200,255,0.4)',
                            borderRadius: '4px',
                            color: '#00c8ff',
                            fontSize: '16px',
                            fontWeight: '600',
                            fontFamily: '"SF Mono", monospace',
                            textAlign: 'center',
                            marginBottom: '6px',
                            touchAction: 'manipulation',
                            WebkitAppearance: 'none',
                          }}
                        />
                        
                        <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                          <span style={{ color: '#6080a0', fontSize: '8px' }}>Offset:</span>
                          <input
                            type="range"
                            min="-100"
                            max="100"
                            value={dim.offset || 0}
                            onChange={(e) => updateLinkedDimension(dim.id, parseInt(e.target.value))}
                            style={{ flex: 1, accentColor: '#00c8ff' }}
                          />
                          <span style={{ color: '#8899aa', fontSize: '8px', width: '30px' }}>
                            {dim.offset || 0}
                          </span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          )}
          
          {/* Window Editor Panel */}
          {showDoorWindowEditor && selectedItems[0]?.type === 'window' && !editorsMinimized && (
            <div
              key={`window-editor-${selectedItems[0].item.id}`}
              onTouchStart={(e) => e.stopPropagation()}
              onTouchMove={(e) => e.stopPropagation()}
              onTouchEnd={(e) => e.stopPropagation()}
              onPointerDown={(e) => e.stopPropagation()}
              style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '190px' : '220px',
              maxHeight: isMobile ? '55vh' : '80vh',
              overflowY: 'auto',
              zIndex: 250,
              touchAction: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>ü™ü Edit Window</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button onClick={() => setEditorsMinimized(true)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px', padding: '4px' }} title="Minimize">‚àí</button>
                  <button onClick={() => { setShowDoorWindowEditor(false); setSelectedItems([]); }} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '18px', padding: '4px' }}>√ó</button>
                </div>
              </div>
              
              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Window Type</label>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px' }}>
                  {WINDOW_TYPES.map(wtype => (
                    <button
                      key={wtype.id}
                      onClick={() => updateWindow(selectedItems[0].item.id, { type: wtype.id, width: wtype.defaultWidth * (GRID_SIZE / 6), height: wtype.defaultHeight * (GRID_SIZE / 6) })}
                      style={{
                        padding: '6px 4px',
                        background: selectedItems[0].item.type === wtype.id ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${selectedItems[0].item.type === wtype.id ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: selectedItems[0].item.type === wtype.id ? '#00c8ff' : '#8899aa',
                        fontSize: '8px',
                        cursor: 'pointer',
                      }}
                    >
                      {wtype.icon} {wtype.name}
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{ marginBottom: '8px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Width (inches)</label>
                <input
                  type="text"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  value={selectedItems[0].item.width ? Math.round(selectedItems[0].item.width / (GRID_SIZE / 6)) : 48}
                  onChange={(e) => {
                    const val = e.target.value;
                    if (val === '' || /^\d+$/.test(val)) {
                      updateWindow(selectedItems[0].item.id, { width: (parseInt(val) || 48) * (GRID_SIZE / 6) });
                    }
                  }}
                  style={{
                    width: '100%',
                    padding: '10px 12px',
                    background: 'rgba(255,255,255,0.1)',
                    border: '2px solid rgba(0,200,255,0.3)',
                    borderRadius: '6px',
                    color: '#fff',
                    fontSize: '16px',
                    boxSizing: 'border-box',
                  }}
                />
              </div>

              <div style={{ marginBottom: '8px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Height (inches)</label>
                <input
                  type="text"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  value={selectedItems[0].item.height ? Math.round(selectedItems[0].item.height / (GRID_SIZE / 6)) : 48}
                  onChange={(e) => {
                    const val = e.target.value;
                    if (val === '' || /^\d+$/.test(val)) {
                      updateWindow(selectedItems[0].item.id, { height: (parseInt(val) || 48) * (GRID_SIZE / 6) });
                    }
                  }}
                  style={{
                    width: '100%',
                    padding: '10px 12px',
                    background: 'rgba(255,255,255,0.1)',
                    border: '2px solid rgba(0,200,255,0.3)',
                    borderRadius: '6px',
                    color: '#fff',
                    fontSize: '16px',
                    boxSizing: 'border-box',
                  }}
                />
              </div>
              
              <InputField
                label="Sill Height from Floor (inches)"
                value={selectedItems[0].item.sillHeight || 36}
                onChange={(val) => updateWindow(selectedItems[0].item.id, { sillHeight: parseInt(val) || 36 })}
                type="number"
                min={0}
                step={1}
              />
              
              <div style={{ marginTop: '12px', padding: '8px', background: 'rgba(0,200,255,0.05)', borderRadius: '4px' }}>
                <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '4px' }}>Window Info</div>
                <div style={{ color: '#00c8ff', fontSize: '11px' }}>
                  {formatMeasurement(((selectedItems[0].item.width || 96) / (GRID_SIZE / 6) / 12).toFixed(1))} W √ó {formatMeasurement(((selectedItems[0].item.height || 96) / (GRID_SIZE / 6) / 12).toFixed(1))} H
                </div>
                <div style={{ color: '#6080a0', fontSize: '9px', marginTop: '2px' }}>
                  Sill at {formatMeasurement(((selectedItems[0].item.sillHeight || 36) / 12).toFixed(1))} from floor
                </div>
                <div style={{ color: '#6080a0', fontSize: '9px', marginTop: '2px' }}>
                  {WINDOW_TYPES.find(w => w.id === selectedItems[0].item.type)?.description || 'Standard window'}
                </div>
              </div>
              
              <div style={{ marginTop: '10px', fontSize: '9px', color: '#6080a0' }}>
                üí° Drag the window along the wall to reposition
              </div>
              
              {/* Delete Button */}
              <button
                onClick={() => {
                  updateActiveFloor(f => ({ ...f, windows: f.windows.filter(w => w.id !== selectedItems[0].item.id) }));
                  setSelectedItems([]);
                  setShowDoorWindowEditor(false);
                }}
                style={{
                  width: '100%',
                  padding: '10px',
                  marginTop: '12px',
                  background: 'rgba(255,80,80,0.15)',
                  border: '1px solid rgba(255,80,80,0.4)',
                  borderRadius: '6px',
                  color: '#ff6666',
                  fontSize: '11px',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '6px',
                }}
              >
                üóë Delete Window
              </button>
              
              {/* Linked Dimensions Section - Window */}
              {linkedDimensions.length > 0 && (
                <div style={{ marginTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '12px' }}>
                  <div style={{ color: '#6080a0', fontSize: '10px', marginBottom: '4px' }}>
                    üîó LINKED DIMENSIONS ({linkedDimensions.length})
                  </div>
                  <div style={{ color: '#4a5568', fontSize: '8px', marginBottom: '8px' }}>
                    Edit length to move window position
                  </div>
                  {linkedDimensions.map((dim) => {
                    const dimStart = resolveLinkPoint(dim.startLink, dim.start);
                    const dimEnd = resolveLinkPoint(dim.endLink, dim.end);
                    const length = distance(dimStart, dimEnd);
                    const lengthFeet = pixelsToFeet(length);
                    
                    return (
                      <div key={dim.id} style={{
                        background: 'rgba(0,200,255,0.08)',
                        border: '1px solid rgba(0,200,255,0.2)',
                        borderRadius: '6px',
                        padding: '10px',
                        marginBottom: '8px',
                      }}
                      onTouchStart={(e) => e.stopPropagation()}
                      onTouchMove={(e) => e.stopPropagation()}
                      onTouchEnd={(e) => e.stopPropagation()}
                      onPointerDown={(e) => e.stopPropagation()}
                      >
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }}>
                          <span style={{ color: '#6080a0', fontSize: '9px' }}>üìè Distance:</span>
                          <button
                            onClick={() => deleteLinkedDimension(dim.id)}
                            style={{ background: 'none', border: 'none', color: '#ff6666', cursor: 'pointer', fontSize: '12px', padding: '2px 6px' }}
                            title="Delete dimension"
                          >√ó</button>
                        </div>
                        
                        <input
                          type="text"
                          inputMode="decimal"
                          defaultValue={formatMeasurement(lengthFeet)}
                          key={`${dim.id}-${Math.round(lengthFeet * 100)}`}
                          onBlur={(e) => {
                            const parsed = parseFeetInches(e.target.value);
                            if (parsed !== null && parsed > 0) {
                              updateLinkedItemByDimension(dim, parsed);
                            }
                          }}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              const parsed = parseFeetInches(e.target.value);
                              if (parsed !== null && parsed > 0) {
                                updateLinkedItemByDimension(dim, parsed);
                              }
                              e.target.blur();
                            }
                          }}
                          onTouchStart={(e) => e.stopPropagation()}
                          onTouchMove={(e) => e.stopPropagation()}
                          onTouchEnd={(e) => e.stopPropagation()}
                          onMouseDown={(e) => e.stopPropagation()}
                          onPointerDown={(e) => e.stopPropagation()}
                          onClick={(e) => { e.stopPropagation(); e.target.focus(); }}
                          autoComplete="off"
                          autoCorrect="off"
                          style={{
                            width: '100%',
                            padding: '10px 12px',
                            background: 'rgba(0,0,0,0.3)',
                            border: '2px solid rgba(0,200,255,0.4)',
                            borderRadius: '4px',
                            color: '#00c8ff',
                            fontSize: '16px',
                            fontWeight: '600',
                            fontFamily: '"SF Mono", monospace',
                            textAlign: 'center',
                            marginBottom: '6px',
                            touchAction: 'manipulation',
                            WebkitAppearance: 'none',
                          }}
                        />
                        
                        <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                          <span style={{ color: '#6080a0', fontSize: '8px' }}>Offset:</span>
                          <input
                            type="range"
                            min="-100"
                            max="100"
                            value={dim.offset || 0}
                            onChange={(e) => updateLinkedDimension(dim.id, parseInt(e.target.value))}
                            style={{ flex: 1, accentColor: '#00c8ff' }}
                          />
                          <span style={{ color: '#8899aa', fontSize: '8px', width: '30px' }}>
                            {dim.offset || 0}
                          </span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          )}
          
          {/* Furniture Editor Panel */}
          {selectedItems[0]?.type === 'furniture' && !editorsMinimized && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '170px' : '190px',
              zIndex: 250,
              maxHeight: isMobile ? '50vh' : '70vh',
              overflowY: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>ü™ë Edit Furniture</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button onClick={() => setEditorsMinimized(true)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px', padding: '4px' }} title="Minimize">‚àí</button>
                  <button onClick={() => setSelectedItems([])} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '18px', padding: '4px' }}>√ó</button>
                </div>
              </div>
              
              <div style={{ color: '#8899aa', fontSize: '11px', marginBottom: '10px' }}>
                {FURNITURE_LIBRARY.find(f => f.id === selectedItems[0].item.templateId)?.name || 'Furniture'}
              </div>
              
              <MeasurementInput
                label="Width"
                value={pixelsToFeet(selectedItems[0].item.width)}
                onChange={(val) => {
                  const newWidth = feetToPixels(val);
                  updateActiveFloor(f => ({
                    ...f,
                    furniture: f.furniture.map(furn =>
                      furn.id === selectedItems[0].item.id ? { ...furn, width: newWidth } : furn
                    )
                  }));
                }}
                units={units}
                formatMeasurement={formatMeasurement}
              />
              
              <MeasurementInput
                label="Depth"
                value={pixelsToFeet(selectedItems[0].item.height)}
                onChange={(val) => {
                  const newHeight = feetToPixels(val);
                  updateActiveFloor(f => ({
                    ...f,
                    furniture: f.furniture.map(furn =>
                      furn.id === selectedItems[0].item.id ? { ...furn, height: newHeight } : furn
                    )
                  }));
                }}
                units={units}
                formatMeasurement={formatMeasurement}
              />
              
              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Rotation</label>
                <div style={{ display: 'flex', gap: '4px' }}>
                  {[0, 90, 180, 270].map(angle => (
                    <button
                      key={angle}
                      onClick={() => {
                        updateActiveFloor(f => ({
                          ...f,
                          furniture: f.furniture.map(furn =>
                            furn.id === selectedItems[0].item.id ? { ...furn, rotation: angle } : furn
                          )
                        }));
                      }}
                      style={{
                        flex: 1,
                        padding: '6px 4px',
                        background: (selectedItems[0].item.rotation || 0) === angle ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${(selectedItems[0].item.rotation || 0) === angle ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: (selectedItems[0].item.rotation || 0) === angle ? '#00c8ff' : '#8899aa',
                        fontSize: '10px',
                        cursor: 'pointer',
                      }}
                    >
                      {angle}¬∞
                    </button>
                  ))}
                </div>
              </div>
              
              <button
                onClick={deleteSelected}
                style={{
                  width: '100%',
                  padding: '8px',
                  background: 'rgba(255,80,80,0.15)',
                  border: '1px solid rgba(255,80,80,0.3)',
                  borderRadius: '6px',
                  color: '#ff6666',
                  fontSize: '11px',
                  cursor: 'pointer',
                  marginTop: '8px',
                }}
              >
                üóë Delete
              </button>
              
              <div style={{ marginTop: '10px', fontSize: '9px', color: '#6080a0' }}>
                üí° Drag to move
              </div>
            </div>
          )}
          
          {/* 3D View */}
          {show3D && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : (showWallEditor ? '230px' : '16px'),
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              overflow: 'hidden',
              zIndex: 250,
            }}>
              <div style={{ padding: '6px 10px', borderBottom: '1px solid rgba(0,200,255,0.1)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <span style={{ color: '#fff', fontSize: '10px', fontWeight: '500' }}>3D Preview</span>
                <button onClick={() => setShow3D(false)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '12px' }}>√ó</button>
              </div>
              <canvas 
                ref={canvas3DRef} 
                width={isMobile ? 280 : 400} 
                height={isMobile ? 210 : 300}
                onMouseDown={(e) => {
                  setIs3DDragging(true);
                  setDragStart3D({ x: e.clientX, y: e.clientY });
                }}
                onMouseMove={(e) => {
                  if (is3DDragging) {
                    const dx = e.clientX - dragStart3D.x;
                    const dy = e.clientY - dragStart3D.y;
                    if (e.shiftKey) {
                      // Pan
                      setView3DPan(p => ({ x: p.x + dx, y: p.y + dy }));
                    } else {
                      // Rotate
                      setView3DRotation(r => ({
                        x: Math.max(-60, Math.min(60, r.x + dy * 0.5)),
                        y: r.y + dx * 0.5
                      }));
                    }
                    setDragStart3D({ x: e.clientX, y: e.clientY });
                  }
                }}
                onMouseUp={() => setIs3DDragging(false)}
                onMouseLeave={() => setIs3DDragging(false)}
                onWheel={(e) => {
                  e.preventDefault();
                  const delta = e.deltaY > 0 ? 0.9 : 1.1;
                  setView3DZoom(z => Math.max(0.3, Math.min(3, z * delta)));
                }}
                style={{ cursor: is3DDragging ? 'grabbing' : 'grab' }}
              />
              <div style={{ padding: '6px 10px', borderTop: '1px solid rgba(0,200,255,0.1)', display: 'flex', gap: '4px', alignItems: 'center', justifyContent: 'space-between' }}>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button
                    onClick={() => setView3DZoom(z => Math.min(3, z * 1.2))}
                    style={{ padding: '2px 6px', background: 'rgba(0,200,255,0.1)', border: '1px solid rgba(0,200,255,0.2)', borderRadius: '3px', color: '#00c8ff', fontSize: '10px', cursor: 'pointer' }}
                  >+</button>
                  <button
                    onClick={() => setView3DZoom(z => Math.max(0.3, z * 0.8))}
                    style={{ padding: '2px 6px', background: 'rgba(0,200,255,0.1)', border: '1px solid rgba(0,200,255,0.2)', borderRadius: '3px', color: '#00c8ff', fontSize: '10px', cursor: 'pointer' }}
                  >‚àí</button>
                  <button
                    onClick={() => { setView3DRotation({ x: 30, y: 45 }); setView3DZoom(1); setView3DPan({ x: 0, y: 0 }); }}
                    style={{ padding: '2px 6px', background: 'rgba(0,200,255,0.1)', border: '1px solid rgba(0,200,255,0.2)', borderRadius: '3px', color: '#00c8ff', fontSize: '10px', cursor: 'pointer' }}
                  >Reset</button>
                </div>
                <span style={{ color: '#6080a0', fontSize: '8px' }}>Drag to rotate ‚Ä¢ Shift+drag to pan ‚Ä¢ Scroll to zoom</span>
              </div>
            </div>
          )}
          
          {/* Settings Panel */}
          {showSettings && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '200px' : '200px',
              zIndex: 250,
              maxHeight: isMobile ? '70vh' : 'auto',
              overflowY: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>‚öôÔ∏è Settings</span>
                <button onClick={() => setShowSettings(false)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px' }}>√ó</button>
              </div>
              
              <div style={{ marginBottom: '12px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Measurement Units</label>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button
                    onClick={() => setUnits('decimal')}
                    style={{
                      flex: 1,
                      padding: '6px',
                      background: units === 'decimal' ? 'rgba(0,200,255,0.2)' : 'transparent',
                      border: `1px solid ${units === 'decimal' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '4px',
                      color: units === 'decimal' ? '#00c8ff' : '#8899aa',
                      fontSize: '10px',
                      cursor: 'pointer',
                    }}
                  >
                    Decimal (3.5')
                  </button>
                  <button
                    onClick={() => setUnits('feetInches')}
                    style={{
                      flex: 1,
                      padding: '6px',
                      background: units === 'feetInches' ? 'rgba(0,200,255,0.2)' : 'transparent',
                      border: `1px solid ${units === 'feetInches' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '4px',
                      color: units === 'feetInches' ? '#00c8ff' : '#8899aa',
                      fontSize: '10px',
                      cursor: 'pointer',
                    }}
                  >
                    Ft-In (3'-6")
                  </button>
                </div>
              </div>
              
              <div style={{ borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '10px', marginTop: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '6px' }}>Grid Snap Size</label>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '4px' }}>
                  {Object.entries(GRID_OPTIONS).map(([key, config]) => (
                    <button
                      key={key}
                      onClick={() => setGridSize(key)}
                      style={{
                        padding: '6px',
                        background: gridSize === key ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${gridSize === key ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: gridSize === key ? '#00c8ff' : '#8899aa',
                        fontSize: '10px',
                        cursor: 'pointer',
                      }}
                    >
                      {config.label}
                    </button>
                  ))}
                </div>
                <div style={{ color: '#6080a0', fontSize: '8px', marginTop: '6px' }}>
                  Use smaller grid for precise fractional inches
                </div>
              </div>
              
              <div style={{ borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '10px', marginTop: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '6px' }}>Angle Snap</label>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '4px' }}>
                  {[['90', '90¬∞'], ['45', '45¬∞'], ['15', '15¬∞'], ['off', 'Free']].map(([key, label]) => (
                    <button
                      key={key}
                      onClick={() => setAngleSnap(key)}
                      style={{
                        padding: '6px',
                        background: angleSnap === key ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${angleSnap === key ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: angleSnap === key ? '#00c8ff' : '#8899aa',
                        fontSize: '9px',
                        cursor: 'pointer',
                      }}
                    >
                      {label}
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{ borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '10px', marginTop: '10px' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' }}>
                  <input
                    type="checkbox"
                    checked={showGrips}
                    onChange={(e) => setShowGrips(e.target.checked)}
                    style={{ accentColor: '#00c8ff' }}
                  />
                  <label style={{ color: '#6080a0', fontSize: '10px' }}>Show Wall Grips</label>
                </div>
                <div style={{ color: '#6080a0', fontSize: '9px' }}>Scale: {(scale * 100).toFixed(0)}%</div>
              </div>
              
              <div style={{ borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '10px', marginTop: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '6px' }}>Wall Detail Level</label>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px' }}>
                  {Object.entries(WALL_DETAIL_LEVELS).map(([key, config]) => (
                    <button
                      key={key}
                      onClick={() => setWallDetailLevel(key)}
                      style={{
                        padding: '6px 4px',
                        background: wallDetailLevel === key ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${wallDetailLevel === key ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: wallDetailLevel === key ? '#00c8ff' : '#8899aa',
                        fontSize: '9px',
                        cursor: 'pointer',
                      }}
                    >
                      {config.label}
                    </button>
                  ))}
                </div>
                <div style={{ color: '#6080a0', fontSize: '8px', marginTop: '6px' }}>
                  {WALL_DETAIL_LEVELS[wallDetailLevel]?.description}
                </div>
                <div style={{ marginTop: '8px', padding: '6px', background: 'rgba(0,200,255,0.05)', borderRadius: '4px' }}>
                  <div style={{ color: '#6080a0', fontSize: '8px', marginBottom: '4px' }}>Wall Construction:</div>
                  <div style={{ fontSize: '7px', color: '#8899aa', lineHeight: '1.4' }}>
                    {wallDetailLevel === 'detailed' && (
                      <>
                        <div>‚Ä¢ <span style={{color:'#8B7355'}}>‚ñ†</span> Exterior: Siding ‚Üí Sheathing ‚Üí Insulation ‚Üí Drywall</div>
                        <div>‚Ä¢ <span style={{color:'#E8E4DF'}}>‚ñ†</span> Interior: Drywall ‚Üí Studs ‚Üí Drywall</div>
                        <div>‚Ä¢ <span style={{color:'#DEB887'}}>‚ñ†</span> Studs shown at 16" O.C.</div>
                      </>
                    )}
                    {wallDetailLevel === 'standard' && (
                      <>
                        <div>‚Ä¢ Color-coded layer bands</div>
                        <div>‚Ä¢ Layer separators visible</div>
                      </>
                    )}
                    {wallDetailLevel === 'simple' && (
                      <>
                        <div>‚Ä¢ Solid wall fill</div>
                        <div>‚Ä¢ Best performance</div>
                      </>
                    )}
                  </div>
                </div>
              </div>

              <div style={{ borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '10px', marginTop: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '6px' }}>Render Mode</label>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '4px' }}>
                  <button
                    onClick={() => setRenderMode('linework')}
                    style={{
                      padding: '6px 4px',
                      background: renderMode === 'linework' ? 'rgba(0,200,255,0.2)' : 'transparent',
                      border: `1px solid ${renderMode === 'linework' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '4px',
                      color: renderMode === 'linework' ? '#00c8ff' : '#8899aa',
                      fontSize: '9px',
                      cursor: 'pointer',
                    }}
                  >
                    Line Work
                  </button>
                  <button
                    onClick={() => setRenderMode('realistic')}
                    style={{
                      padding: '6px 4px',
                      background: renderMode === 'realistic' ? 'rgba(0,200,255,0.2)' : 'transparent',
                      border: `1px solid ${renderMode === 'realistic' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '4px',
                      color: renderMode === 'realistic' ? '#00c8ff' : '#8899aa',
                      fontSize: '9px',
                      cursor: 'pointer',
                    }}
                  >
                    Realistic
                  </button>
                </div>
                <div style={{ color: '#6080a0', fontSize: '8px', marginTop: '6px' }}>
                  {renderMode === 'linework' ? 'Clean CAD-style line drawings' : 'Textured walls with materials'}
                </div>
              </div>
            </div>
          )}

          {/* Layers Panel */}
          {showLayersPanel && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '230px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '200px' : '220px',
              maxHeight: isMobile ? '60vh' : '400px',
              overflowY: 'auto',
              zIndex: 250,
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>üìë Layers</span>
                <button onClick={() => setShowLayersPanel(false)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px' }}>√ó</button>
              </div>
              
              {Object.entries(layers).map(([key, layer]) => (
                <div key={key} style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  padding: '8px',
                  marginBottom: '4px',
                  background: 'rgba(255,255,255,0.03)',
                  borderRadius: '6px',
                  border: '1px solid rgba(255,255,255,0.05)',
                }}>
                  {/* Visibility toggle */}
                  <button
                    onClick={() => toggleLayerVisibility(key)}
                    style={{
                      width: '24px',
                      height: '24px',
                      background: layer.visible ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                      border: 'none',
                      borderRadius: '4px',
                      color: layer.visible ? '#00c8ff' : '#4a5568',
                      fontSize: '12px',
                      cursor: 'pointer',
                    }}
                  >
                    {layer.visible ? 'üëÅ' : 'üö´'}
                  </button>
                  
                  {/* Lock toggle */}
                  <button
                    onClick={() => toggleLayerLock(key)}
                    style={{
                      width: '24px',
                      height: '24px',
                      background: layer.locked ? 'rgba(255,100,100,0.2)' : 'rgba(255,255,255,0.05)',
                      border: 'none',
                      borderRadius: '4px',
                      color: layer.locked ? '#ff6666' : '#4a5568',
                      fontSize: '12px',
                      cursor: 'pointer',
                    }}
                  >
                    {layer.locked ? 'üîí' : 'üîì'}
                  </button>
                  
                  {/* Color indicator */}
                  <div style={{
                    width: '12px',
                    height: '12px',
                    background: layer.color,
                    borderRadius: '2px',
                    border: '1px solid rgba(255,255,255,0.2)',
                  }} />
                  
                  {/* Layer name */}
                  <span style={{ color: layer.visible ? '#c0d0e0' : '#4a5568', fontSize: '11px', flex: 1 }}>
                    {layer.name}
                  </span>
                </div>
              ))}
              
              <div style={{ marginTop: '12px', padding: '8px', background: 'rgba(0,200,255,0.05)', borderRadius: '6px' }}>
                <div style={{ color: '#6080a0', fontSize: '9px' }}>
                  üëÅ = Show/Hide layer<br/>
                  üîí = Lock/Unlock layer
                </div>
              </div>
            </div>
          )}
          
          {/* Sheets Panel */}
          {showSheetsPanel && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '230px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? 'calc(100% - 20px)' : '320px',
              maxHeight: isMobile ? '70vh' : '85vh',
              overflowY: 'auto',
              zIndex: 250,
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>üìã Sheets & Paper Space</span>
                <button onClick={() => setShowSheetsPanel(false)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px' }}>√ó</button>
              </div>
              
              {/* Mode Toggle */}
              <div style={{ display: 'flex', gap: '4px', marginBottom: '12px' }}>
                <button
                  onClick={() => setViewMode('model')}
                  style={{
                    flex: 1,
                    padding: '8px',
                    background: viewMode === 'model' ? 'rgba(0,200,255,0.2)' : 'transparent',
                    border: `1px solid ${viewMode === 'model' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                    borderRadius: '4px',
                    color: viewMode === 'model' ? '#00c8ff' : '#6080a0',
                    fontSize: '10px',
                    cursor: 'pointer',
                    fontWeight: viewMode === 'model' ? '600' : '400',
                  }}
                >
                  üèóÔ∏è Model
                </button>
                <button
                  onClick={() => {
                    if (sheets.length === 0) {
                      createSheet();
                    }
                    setViewMode('paper');
                  }}
                  style={{
                    flex: 1,
                    padding: '8px',
                    background: viewMode === 'paper' ? 'rgba(0,200,255,0.2)' : 'transparent',
                    border: `1px solid ${viewMode === 'paper' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                    borderRadius: '4px',
                    color: viewMode === 'paper' ? '#00c8ff' : '#6080a0',
                    fontSize: '10px',
                    cursor: 'pointer',
                    fontWeight: viewMode === 'paper' ? '600' : '400',
                  }}
                >
                  üìÑ Paper
                </button>
                <button
                  onClick={() => setViewMode('elevations')}
                  style={{
                    flex: 1,
                    padding: '8px',
                    background: viewMode === 'elevations' ? 'rgba(0,200,255,0.2)' : 'transparent',
                    border: `1px solid ${viewMode === 'elevations' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                    borderRadius: '4px',
                    color: viewMode === 'elevations' ? '#00c8ff' : '#6080a0',
                    fontSize: '10px',
                    cursor: 'pointer',
                    fontWeight: viewMode === 'elevations' ? '600' : '400',
                  }}
                >
                  üè† Elevations
                </button>
              </div>
              
              {/* Project Info */}
              <div style={{ marginBottom: '12px', padding: '10px', background: 'rgba(255,255,255,0.03)', borderRadius: '6px' }}>
                <div style={{ color: '#6080a0', fontSize: '9px', marginBottom: '6px' }}>PROJECT INFO (for title blocks)</div>
                <input
                  type="text"
                  placeholder="Project Name"
                  value={projectInfo.projectName}
                  onChange={(e) => setProjectInfo({ ...projectInfo, projectName: e.target.value })}
                  style={{ width: '100%', marginBottom: '4px', padding: '6px', background: 'rgba(0,0,0,0.2)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#fff', fontSize: '10px' }}
                />
                <input
                  type="text"
                  placeholder="Client Name"
                  value={projectInfo.clientName}
                  onChange={(e) => setProjectInfo({ ...projectInfo, clientName: e.target.value })}
                  style={{ width: '100%', marginBottom: '4px', padding: '6px', background: 'rgba(0,0,0,0.2)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#fff', fontSize: '10px' }}
                />
                <input
                  type="text"
                  placeholder="Address"
                  value={projectInfo.address}
                  onChange={(e) => setProjectInfo({ ...projectInfo, address: e.target.value })}
                  style={{ width: '100%', marginBottom: '4px', padding: '6px', background: 'rgba(0,0,0,0.2)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#fff', fontSize: '10px' }}
                />
                <div style={{ display: 'flex', gap: '4px' }}>
                  <input
                    type="text"
                    placeholder="Drawn By"
                    value={projectInfo.drawnBy}
                    onChange={(e) => setProjectInfo({ ...projectInfo, drawnBy: e.target.value })}
                    style={{ flex: 1, padding: '6px', background: 'rgba(0,0,0,0.2)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#fff', fontSize: '10px' }}
                  />
                  <input
                    type="text"
                    placeholder="Date"
                    value={projectInfo.date}
                    onChange={(e) => setProjectInfo({ ...projectInfo, date: e.target.value })}
                    style={{ flex: 1, padding: '6px', background: 'rgba(0,0,0,0.2)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#fff', fontSize: '10px' }}
                  />
                </div>
              </div>
              
              <button
                onClick={createSheet}
                style={{
                  width: '100%',
                  padding: '10px',
                  background: 'rgba(0,200,255,0.1)',
                  border: '1px dashed rgba(0,200,255,0.4)',
                  borderRadius: '6px',
                  color: '#00c8ff',
                  fontSize: '11px',
                  cursor: 'pointer',
                  marginBottom: '12px',
                }}
              >
                + Create New Sheet
              </button>
              
              {sheets.length === 0 ? (
                <div style={{ color: '#6080a0', fontSize: '11px', textAlign: 'center', padding: '20px' }}>
                  No sheets created yet.<br/>
                  Create a sheet for print layouts with title blocks.
                </div>
              ) : (
                sheets.map(sheet => (
                  <div key={sheet.id} style={{
                    padding: '10px',
                    marginBottom: '8px',
                    background: activeSheetId === sheet.id ? 'rgba(0,200,255,0.1)' : 'rgba(255,255,255,0.03)',
                    border: `1px solid ${activeSheetId === sheet.id ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.05)'}`,
                    borderRadius: '6px',
                  }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }}>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                        <input
                          type="text"
                          value={sheet.sheetNumber || 'A01'}
                          onChange={(e) => setSheets(sheets.map(s => s.id === sheet.id ? { ...s, sheetNumber: e.target.value } : s))}
                          style={{ width: '40px', background: 'rgba(0,200,255,0.1)', border: '1px solid rgba(0,200,255,0.3)', borderRadius: '3px', color: '#00c8ff', fontSize: '10px', fontWeight: '600', textAlign: 'center', padding: '2px' }}
                        />
                        <input
                          type="text"
                          value={sheet.sheetTitle || 'Floor Plan'}
                          onChange={(e) => setSheets(sheets.map(s => s.id === sheet.id ? { ...s, sheetTitle: e.target.value } : s))}
                          style={{ flex: 1, background: 'transparent', border: 'none', color: '#fff', fontSize: '11px' }}
                        />
                      </div>
                      <button
                        onClick={() => {
                          setSheets(sheets.filter(s => s.id !== sheet.id));
                          if (activeSheetId === sheet.id) setActiveSheetId(sheets[0]?.id || null);
                        }}
                        style={{ background: 'none', border: 'none', color: '#ff6666', cursor: 'pointer', fontSize: '12px' }}
                      >√ó</button>
                    </div>
                    
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px', marginBottom: '6px' }}>
                      <select
                        value={sheet.size}
                        onChange={(e) => setSheets(sheets.map(s => s.id === sheet.id ? { ...s, size: e.target.value } : s))}
                        style={{ padding: '4px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#fff', fontSize: '9px' }}
                      >
                        <option value="letter">Letter</option>
                        <option value="legal">Legal</option>
                        <option value="tabloid">Tabloid</option>
                        <option value="arch-d">Arch D (24√ó36)</option>
                      </select>
                      <select
                        value={sheet.scale}
                        onChange={(e) => setSheets(sheets.map(s => s.id === sheet.id ? { ...s, scale: e.target.value } : s))}
                        style={{ padding: '4px', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '4px', color: '#fff', fontSize: '9px' }}
                      >
                        <option value="1/8&quot; = 1'">1/8" = 1'</option>
                        <option value="1/4&quot; = 1'">1/4" = 1'</option>
                        <option value="3/8&quot; = 1'">3/8" = 1'</option>
                        <option value="1/2&quot; = 1'">1/2" = 1'</option>
                      </select>
                    </div>
                    
                    <div style={{ display: 'flex', gap: '4px' }}>
                      <button
                        onClick={() => {
                          setActiveSheetId(sheet.id);
                          setViewMode('paper');
                        }}
                        style={{
                          flex: 1,
                          padding: '6px',
                          background: activeSheetId === sheet.id && viewMode === 'paper' ? 'rgba(0,255,170,0.2)' : 'rgba(0,200,255,0.1)',
                          border: '1px solid rgba(0,200,255,0.3)',
                          borderRadius: '4px',
                          color: '#00c8ff',
                          fontSize: '9px',
                          cursor: 'pointer',
                        }}
                      >
                        üìÑ Edit Sheet
                      </button>
                      <button
                        onClick={() => {
                          // Print/Export sheet
                          setActiveSheetId(sheet.id);
                          setViewMode('paper');
                          setTimeout(() => window.print(), 100);
                        }}
                        style={{
                          padding: '6px 10px',
                          background: 'rgba(0,200,255,0.2)',
                          border: '1px solid rgba(0,200,255,0.4)',
                          borderRadius: '4px',
                          color: '#00c8ff',
                          fontSize: '9px',
                          cursor: 'pointer',
                        }}
                      >
                        üñ®Ô∏è
                      </button>
                    </div>
                  </div>
                ))
              )}
            </div>
          )}
          
          {/* Paper Space View */}
          {viewMode === 'paper' && activeSheet && (
            <div style={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: '#505050',
              zIndex: 500,
              display: 'flex',
              flexDirection: 'column',
            }}>
              {/* Paper Space Toolbar */}
              <div style={{
                background: 'rgba(8,12,16,0.98)',
                borderBottom: '1px solid rgba(0,200,255,0.2)',
                padding: isMobile ? '6px 10px' : '8px 16px',
                display: 'flex',
                flexDirection: isMobile ? 'column' : 'row',
                alignItems: isMobile ? 'stretch' : 'center',
                gap: isMobile ? '8px' : '12px',
                flexShrink: 0,
              }}>
                {/* Top row */}
                <div style={{ display: 'flex', alignItems: 'center', gap: isMobile ? '6px' : '12px' }}>
                  <button
                    onClick={() => setViewMode('model')}
                    style={{
                      padding: isMobile ? '6px 8px' : '6px 12px',
                      background: 'rgba(0,200,255,0.1)',
                      border: '1px solid rgba(0,200,255,0.3)',
                      borderRadius: '4px',
                      color: '#00c8ff',
                      fontSize: isMobile ? '10px' : '11px',
                      cursor: 'pointer',
                    }}
                  >
                    ‚Üê Back
                  </button>

                  {!isMobile && (
                    <>
                      <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>
                        üìÑ {activeSheet.sheetNumber} - {activeSheet.sheetTitle}
                      </span>

                      <span style={{ color: '#6080a0', fontSize: '10px' }}>
                        {PAPER_SIZES[activeSheet.size]?.name || activeSheet.size} | Scale: {activeSheet.scale}
                      </span>
                    </>
                  )}
                  {isMobile && (
                    <span style={{ color: '#fff', fontSize: '10px', fontWeight: '500' }}>
                      üìÑ {activeSheet.sheetNumber}
                    </span>
                  )}

                  {!isMobile && <div style={{ flex: 1 }} />}

                  {/* Desktop zoom controls inline */}
                  {!isMobile && (
                    <>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <button
                          onClick={() => setPaperZoom(z => Math.max(0.1, z - 0.1))}
                          style={{
                            padding: '6px 12px',
                            background: 'rgba(255,255,255,0.15)',
                            border: '1px solid rgba(255,255,255,0.3)',
                            borderRadius: '6px',
                            color: '#fff',
                            cursor: 'pointer',
                            fontSize: '14px',
                            fontWeight: 'bold',
                          }}
                        >‚àí</button>
                        <span style={{ color: '#fff', fontSize: '11px', minWidth: '50px', textAlign: 'center' }}>
                          {Math.round(paperZoom * 100)}%
                        </span>
                        <button
                          onClick={() => setPaperZoom(z => Math.min(2, z + 0.1))}
                          style={{
                            padding: '6px 12px',
                            background: 'rgba(255,255,255,0.15)',
                            border: '1px solid rgba(255,255,255,0.3)',
                            borderRadius: '6px',
                            color: '#fff',
                            cursor: 'pointer',
                            fontSize: '14px',
                            fontWeight: 'bold',
                          }}
                        >+</button>
                        <button
                          onClick={() => {
                            setPaperZoom(0.4);
                            setPaperPan({ x: 0, y: 0 });
                          }}
                          style={{
                            padding: '6px 10px',
                            background: 'rgba(0,200,255,0.2)',
                            border: '1px solid rgba(0,200,255,0.4)',
                            borderRadius: '6px',
                            color: '#00c8ff',
                            cursor: 'pointer',
                            fontSize: '10px',
                            fontWeight: '600',
                          }}
                        >Fit</button>
                      </div>

                      <button
                        onClick={() => window.print()}
                        style={{
                          padding: '6px 12px',
                          background: 'rgba(0,200,255,0.2)',
                          border: '1px solid rgba(0,200,255,0.4)',
                          borderRadius: '4px',
                          color: '#00c8ff',
                          fontSize: '11px',
                          cursor: 'pointer',
                        }}
                      >
                        üñ®Ô∏è Print
                      </button>
                    </>
                  )}
                </div>

                {/* Mobile zoom controls - separate row */}
                {isMobile && (
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}>
                    <button
                      onClick={() => setPaperZoom(z => Math.max(0.1, z - 0.1))}
                      style={{
                        padding: '10px 16px',
                        background: 'rgba(255,255,255,0.15)',
                        border: '1px solid rgba(255,255,255,0.3)',
                        borderRadius: '6px',
                        color: '#fff',
                        cursor: 'pointer',
                        fontSize: '20px',
                        fontWeight: 'bold',
                        minWidth: '48px',
                      }}
                    >‚àí</button>
                    <span style={{ color: '#fff', fontSize: '14px', minWidth: '60px', textAlign: 'center', fontWeight: '500' }}>
                      {Math.round(paperZoom * 100)}%
                    </span>
                    <button
                      onClick={() => setPaperZoom(z => Math.min(2, z + 0.1))}
                      style={{
                        padding: '10px 16px',
                        background: 'rgba(255,255,255,0.15)',
                        border: '1px solid rgba(255,255,255,0.3)',
                        borderRadius: '6px',
                        color: '#fff',
                        cursor: 'pointer',
                        fontSize: '20px',
                        fontWeight: 'bold',
                        minWidth: '48px',
                      }}
                    >+</button>
                    <button
                      onClick={() => {
                        setPaperZoom(0.25);
                        setPaperPan({ x: 0, y: 0 });
                      }}
                      style={{
                        padding: '10px 14px',
                        background: 'rgba(0,200,255,0.2)',
                        border: '1px solid rgba(0,200,255,0.4)',
                        borderRadius: '6px',
                        color: '#00c8ff',
                        cursor: 'pointer',
                        fontSize: '12px',
                        fontWeight: '600',
                      }}
                    >Fit</button>
                    <button
                      onClick={() => window.print()}
                      style={{
                        padding: '10px 14px',
                        background: 'rgba(0,200,255,0.2)',
                        border: '1px solid rgba(0,200,255,0.4)',
                        borderRadius: '6px',
                        color: '#00c8ff',
                        cursor: 'pointer',
                        fontSize: '12px',
                        fontWeight: '600',
                      }}
                    >üñ®Ô∏è</button>
                  </div>
                )}
              </div>

              {/* Paper Preview Area - with pan/zoom */}
              <div
                style={{
                  flex: 1,
                  overflow: 'hidden',
                  position: 'relative',
                  touchAction: 'none',
                  cursor: isPaperPanning ? 'grabbing' : 'grab',
                }}
                onPointerDown={(e) => {
                  e.currentTarget.setPointerCapture(e.pointerId);
                  setIsPaperPanning(true);
                  setPaperPanStart({ x: e.clientX - paperPan.x, y: e.clientY - paperPan.y });
                }}
                onPointerMove={(e) => {
                  if (isPaperPanning && paperPanStart) {
                    setPaperPan({
                      x: e.clientX - paperPanStart.x,
                      y: e.clientY - paperPanStart.y,
                    });
                  }
                }}
                onPointerUp={(e) => {
                  e.currentTarget.releasePointerCapture(e.pointerId);
                  setIsPaperPanning(false);
                  setPaperPanStart(null);
                }}
                onPointerCancel={(e) => {
                  setIsPaperPanning(false);
                  setPaperPanStart(null);
                }}
                onWheel={(e) => {
                  e.preventDefault();
                  const delta = e.deltaY > 0 ? -0.05 : 0.05;
                  setPaperZoom(z => Math.max(0.1, Math.min(2, z + delta)));
                }}
              >
                <div style={{
                  position: 'absolute',
                  left: '50%',
                  top: '50%',
                  transform: `translate(calc(-50% + ${paperPan.x}px), calc(-50% + ${paperPan.y}px)) scale(${paperZoom})`,
                  transformOrigin: 'center center',
                }}>
                  {/* Paper Sheet Container */}
                  <div
                    id="print-sheet"
                    style={{
                      width: activeSheet.orientation === 'landscape'
                        ? PAPER_SIZES[activeSheet.size]?.width || 1056
                        : PAPER_SIZES[activeSheet.size]?.height || 816,
                      height: activeSheet.orientation === 'landscape'
                        ? PAPER_SIZES[activeSheet.size]?.height || 816
                        : PAPER_SIZES[activeSheet.size]?.width || 1056,
                      background: '#fff',
                      boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                      position: 'relative',
                      flexShrink: 0,
                    }}
                  >
                    {/* Drawing Canvas */}
                    <canvas
                      ref={paperCanvasRef}
                      width={(activeSheet.orientation === 'landscape'
                        ? PAPER_SIZES[activeSheet.size]?.width || 1056
                        : PAPER_SIZES[activeSheet.size]?.height || 816)}
                      height={(activeSheet.orientation === 'landscape'
                        ? PAPER_SIZES[activeSheet.size]?.height || 816
                        : PAPER_SIZES[activeSheet.size]?.width || 1056)}
                      style={{
                        width: '100%',
                        height: '100%',
                      }}
                    />
                  </div>
                </div>

                {/* Mobile hint */}
                {isMobile && (
                  <div style={{
                    position: 'absolute',
                    bottom: '10px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    background: 'rgba(0,0,0,0.7)',
                    padding: '6px 12px',
                    borderRadius: '20px',
                    color: '#8899aa',
                    fontSize: '10px',
                  }}>
                    Drag to pan ‚Ä¢ Use +/- to zoom
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Elevations View */}
          {viewMode === 'elevations' && (
            <div style={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: '#080c10',
              zIndex: 500,
              display: 'flex',
              flexDirection: 'column',
            }}>
              {/* Elevations Toolbar */}
              <div style={{
                background: 'rgba(8,12,16,0.98)',
                borderBottom: '1px solid rgba(0,200,255,0.2)',
                padding: isMobile ? '6px 10px' : '8px 16px',
                display: 'flex',
                flexDirection: isMobile ? 'column' : 'row',
                alignItems: isMobile ? 'stretch' : 'center',
                gap: isMobile ? '8px' : '12px',
                flexShrink: 0,
              }}>
                {/* Top row on mobile: Back + Direction + Spacer */}
                <div style={{ display: 'flex', alignItems: 'center', gap: isMobile ? '6px' : '12px' }}>
                  <button
                    onClick={() => setViewMode('model')}
                    style={{
                      padding: isMobile ? '6px 8px' : '6px 12px',
                      background: 'rgba(0,200,255,0.1)',
                      border: '1px solid rgba(0,200,255,0.3)',
                      borderRadius: '4px',
                      color: '#00c8ff',
                      fontSize: isMobile ? '10px' : '11px',
                      cursor: 'pointer',
                    }}
                  >
                    ‚Üê Back
                  </button>

                  {!isMobile && (
                    <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>
                      üè† Elevation Views
                    </span>
                  )}

                  {/* Elevation Direction Controls */}
                  <div style={{ display: 'flex', gap: '3px' }}>
                    {['north', 'south', 'east', 'west'].map(dir => (
                      <button
                        key={dir}
                        onClick={() => setActiveElevation(dir)}
                        style={{
                          padding: isMobile ? '6px 8px' : '6px 12px',
                          background: activeElevation === dir ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                          border: `1px solid ${activeElevation === dir ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                          borderRadius: '4px',
                          color: activeElevation === dir ? '#00c8ff' : '#6080a0',
                          fontSize: isMobile ? '9px' : '10px',
                          cursor: 'pointer',
                          fontWeight: activeElevation === dir ? '600' : '400',
                          textTransform: 'uppercase',
                        }}
                      >
                        {dir.charAt(0)}
                      </button>
                    ))}
                  </div>

                  {!isMobile && <div style={{ flex: 1 }} />}

                  {/* Desktop zoom controls inline */}
                  {!isMobile && (
                    <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                      <button
                        onClick={() => setElevationZoom(z => Math.max(0.2, z - 0.15))}
                        style={{
                          padding: '6px 12px',
                          background: 'rgba(255,255,255,0.15)',
                          border: '1px solid rgba(255,255,255,0.3)',
                          borderRadius: '6px',
                          color: '#fff',
                          cursor: 'pointer',
                          fontSize: '14px',
                          fontWeight: 'bold',
                        }}
                      >‚àí</button>
                      <span style={{ color: '#fff', fontSize: '11px', minWidth: '50px', textAlign: 'center' }}>
                        {Math.round(elevationZoom * 100)}%
                      </span>
                      <button
                        onClick={() => setElevationZoom(z => Math.min(3, z + 0.15))}
                        style={{
                          padding: '6px 12px',
                          background: 'rgba(255,255,255,0.15)',
                          border: '1px solid rgba(255,255,255,0.3)',
                          borderRadius: '6px',
                          color: '#fff',
                          cursor: 'pointer',
                          fontSize: '14px',
                          fontWeight: 'bold',
                        }}
                      >+</button>
                      <button
                        onClick={() => {
                          setElevationZoom(0.6);
                          setElevationPan({ x: 0, y: 0 });
                        }}
                        style={{
                          padding: '6px 10px',
                          background: 'rgba(0,200,255,0.2)',
                          border: '1px solid rgba(0,200,255,0.4)',
                          borderRadius: '6px',
                          color: '#00c8ff',
                          cursor: 'pointer',
                          fontSize: '10px',
                          fontWeight: '600',
                        }}
                      >Fit</button>
                    </div>
                  )}
                </div>

                {/* Mobile zoom controls - separate row */}
                {isMobile && (
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}>
                    <button
                      onClick={() => setElevationZoom(z => Math.max(0.2, z - 0.15))}
                      style={{
                        padding: '10px 16px',
                        background: 'rgba(255,255,255,0.15)',
                        border: '1px solid rgba(255,255,255,0.3)',
                        borderRadius: '6px',
                        color: '#fff',
                        cursor: 'pointer',
                        fontSize: '20px',
                        fontWeight: 'bold',
                        minWidth: '48px',
                      }}
                    >‚àí</button>
                    <span style={{ color: '#fff', fontSize: '14px', minWidth: '60px', textAlign: 'center', fontWeight: '500' }}>
                      {Math.round(elevationZoom * 100)}%
                    </span>
                    <button
                      onClick={() => setElevationZoom(z => Math.min(3, z + 0.15))}
                      style={{
                        padding: '10px 16px',
                        background: 'rgba(255,255,255,0.15)',
                        border: '1px solid rgba(255,255,255,0.3)',
                        borderRadius: '6px',
                        color: '#fff',
                        cursor: 'pointer',
                        fontSize: '20px',
                        fontWeight: 'bold',
                        minWidth: '48px',
                      }}
                    >+</button>
                    <button
                      onClick={() => {
                        setElevationZoom(0.35);
                        setElevationPan({ x: 0, y: 0 });
                      }}
                      style={{
                        padding: '10px 14px',
                        background: 'rgba(0,200,255,0.2)',
                        border: '1px solid rgba(0,200,255,0.4)',
                        borderRadius: '6px',
                        color: '#00c8ff',
                        cursor: 'pointer',
                        fontSize: '12px',
                        fontWeight: '600',
                      }}
                    >Fit</button>
                  </div>
                )}
              </div>

              {/* Elevation Canvas - with pan/zoom */}
              <div
                ref={(el) => {
                  // Store ref for pinch zoom
                  if (el) el.elevationContainer = true;
                }}
                style={{
                  flex: 1,
                  overflow: 'hidden',
                  position: 'relative',
                  touchAction: 'none',
                  cursor: isElevationPanning ? 'grabbing' : 'grab',
                }}
                onPointerDown={(e) => {
                  e.currentTarget.setPointerCapture(e.pointerId);
                  setIsElevationPanning(true);
                  setElevationPanStart({ x: e.clientX - elevationPan.x, y: e.clientY - elevationPan.y });
                }}
                onPointerMove={(e) => {
                  if (isElevationPanning && elevationPanStart) {
                    setElevationPan({
                      x: e.clientX - elevationPanStart.x,
                      y: e.clientY - elevationPanStart.y,
                    });
                  }
                }}
                onPointerUp={(e) => {
                  e.currentTarget.releasePointerCapture(e.pointerId);
                  setIsElevationPanning(false);
                  setElevationPanStart(null);
                }}
                onPointerCancel={(e) => {
                  setIsElevationPanning(false);
                  setElevationPanStart(null);
                }}
                onWheel={(e) => {
                  e.preventDefault();
                  const delta = e.deltaY > 0 ? -0.1 : 0.1;
                  setElevationZoom(z => Math.max(0.2, Math.min(3, z + delta)));
                }}
              >
                <div style={{
                  position: 'absolute',
                  left: '50%',
                  top: '50%',
                  transform: `translate(calc(-50% + ${elevationPan.x}px), calc(-50% + ${elevationPan.y}px)) scale(${elevationZoom})`,
                  transformOrigin: 'center center',
                }}>
                  <canvas
                    ref={elevationCanvasRef}
                    width={1200}
                    height={800}
                    style={{
                      background: '#f5f5f0',
                      boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                    }}
                  />
                </div>
              </div>

              {/* Mobile hint */}
              {isMobile && (
                <div style={{
                  position: 'absolute',
                  bottom: '10px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  background: 'rgba(0,0,0,0.7)',
                  padding: '6px 12px',
                  borderRadius: '20px',
                  color: '#8899aa',
                  fontSize: '10px',
                }}>
                  Drag to pan ‚Ä¢ Use +/- to zoom
                </div>
              )}
            </div>
          )}

          {/* New File Confirmation Modal */}
          {showNewFileConfirm && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0,0,0,0.7)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1001,
              padding: isMobile ? '20px' : 0,
            }}>
              <div style={{
                background: 'rgba(8,12,16,0.98)',
                border: '1px solid rgba(0,200,255,0.3)',
                borderRadius: '12px',
                padding: isMobile ? '20px' : '24px',
                width: isMobile ? '100%' : '320px',
                maxWidth: '320px',
                boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
              }}>
                <div style={{ color: '#fff', fontSize: '16px', fontWeight: '500', marginBottom: '12px' }}>
                  üìÑ Create New File?
                </div>
                <div style={{ color: '#8899aa', fontSize: '13px', marginBottom: '20px', lineHeight: '1.5' }}>
                  All unsaved changes will be lost. Are you sure you want to start a new project?
                </div>
                <div style={{ display: 'flex', gap: '10px' }}>
                  <button
                    onClick={() => setShowNewFileConfirm(false)}
                    style={{
                      flex: 1,
                      padding: '12px',
                      background: 'rgba(255,255,255,0.05)',
                      border: '1px solid rgba(255,255,255,0.1)',
                      borderRadius: '8px',
                      color: '#8899aa',
                      fontSize: '13px',
                      cursor: 'pointer',
                    }}
                  >
                    Cancel
                  </button>
                  <button
                    onClick={() => {
                      const newFloorId = generateId();
                      setFloors([{
                        id: newFloorId,
                        name: 'Floor 1',
                        walls: [],
                        doors: [],
                        windows: [],
                        furniture: [],
                        rooms: [],
                        stairs: [],
                        electrical: [],
                        plumbing: [],
                        plumbingLines: [],
                        dimensions: [],
                        texts: [],
                      }]);
                      setActiveFloorId(newFloorId);
                      setSelectedItems([]);
                      setHistory([]);
                      setHistoryIndex(-1);
                      setOffset({ x: 0, y: 0 });
                      setScale(1);
                      setShowNewFileConfirm(false);
                    }}
                    style={{
                      flex: 1,
                      padding: '12px',
                      background: 'linear-gradient(135deg, #ff6666 0%, #cc4444 100%)',
                      border: 'none',
                      borderRadius: '8px',
                      color: '#fff',
                      fontSize: '13px',
                      fontWeight: '500',
                      cursor: 'pointer',
                    }}
                  >
                    New File
                  </button>
                </div>
              </div>
            </div>
          )}
          
          {/* Text Input Modal */}
          {showTextInput && pendingTextPos && (
            <div style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.3)',
              borderRadius: '12px',
              padding: '20px',
              width: '300px',
              zIndex: 1000,
              boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                <span style={{ color: '#fff', fontSize: '14px', fontWeight: '500' }}>üìù Add Text</span>
                <button 
                  onClick={() => { setShowTextInput(false); setPendingTextPos(null); }}
                  style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '18px' }}
                >√ó</button>
              </div>
              
              <div style={{ marginBottom: '12px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Text Content</label>
                <input
                  type="text"
                  value={textInput}
                  onChange={(e) => setTextInput(e.target.value)}
                  placeholder="Enter text..."
                  autoFocus
                  style={{
                    width: '100%',
                    padding: '10px',
                    background: 'rgba(255,255,255,0.05)',
                    border: '1px solid rgba(255,255,255,0.1)',
                    borderRadius: '6px',
                    color: '#fff',
                    fontSize: '14px',
                    outline: 'none',
                  }}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && textInput.trim()) {
                      addText(textInput.trim(), pendingTextPos);
                      setTextInput('');
                      setShowTextInput(false);
                      setPendingTextPos(null);
                    } else if (e.key === 'Escape') {
                      setShowTextInput(false);
                      setPendingTextPos(null);
                    }
                  }}
                />
              </div>
              
              <div style={{ marginBottom: '12px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Style</label>
                <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
                  {Object.entries(TEXT_STYLES).map(([key, style]) => (
                    <button
                      key={key}
                      onClick={() => setSelectedTextStyle(key)}
                      style={{
                        padding: '6px 10px',
                        background: selectedTextStyle === key ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${selectedTextStyle === key ? style.color : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: selectedTextStyle === key ? style.color : '#6080a0',
                        fontSize: '10px',
                        cursor: 'pointer',
                      }}
                    >
                      {style.name}
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{ display: 'flex', gap: '8px' }}>
                <button
                  onClick={() => { setShowTextInput(false); setPendingTextPos(null); }}
                  style={{
                    flex: 1,
                    padding: '10px',
                    background: 'rgba(255,255,255,0.05)',
                    border: '1px solid rgba(255,255,255,0.1)',
                    borderRadius: '6px',
                    color: '#8899aa',
                    fontSize: '12px',
                    cursor: 'pointer',
                  }}
                >
                  Cancel
                </button>
                <button
                  onClick={() => {
                    if (textInput.trim()) {
                      addText(textInput.trim(), pendingTextPos);
                      setTextInput('');
                      setShowTextInput(false);
                      setPendingTextPos(null);
                    }
                  }}
                  style={{
                    flex: 1,
                    padding: '10px',
                    background: 'linear-gradient(135deg, #00c8ff 0%, #0088aa 100%)',
                    border: 'none',
                    borderRadius: '6px',
                    color: '#fff',
                    fontSize: '12px',
                    fontWeight: '500',
                    cursor: 'pointer',
                  }}
                >
                  Add Text
                </button>
              </div>
            </div>
          )}
          
          {/* Text Editor Panel */}
          {selectedItems[0]?.type === 'text' && !editorsMinimized && (
            <div 
              onTouchStart={(e) => e.stopPropagation()}
              onTouchMove={(e) => e.stopPropagation()}
              onTouchEnd={(e) => e.stopPropagation()}
              onPointerDown={(e) => e.stopPropagation()}
              style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '200px' : '220px',
              maxHeight: isMobile ? '55vh' : '80vh',
              overflowY: 'auto',
              zIndex: 250,
              touchAction: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                <span style={{ color: '#fff', fontSize: '12px', fontWeight: '500' }}>üìù Edit Text</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button onClick={() => setEditorsMinimized(true)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px', padding: '4px' }} title="Minimize">‚àí</button>
                  <button onClick={() => setSelectedItems([])} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '18px', padding: '4px' }}>√ó</button>
                </div>
              </div>
              
              <InputField
                label="Text Content"
                value={selectedItems[0].item.content || ''}
                onChange={(val) => updateText(selectedItems[0].item.id, { content: val })}
              />
              
              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Style</label>
                <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
                  {Object.entries(TEXT_STYLES).map(([key, style]) => (
                    <button
                      key={key}
                      onClick={() => updateText(selectedItems[0].item.id, { 
                        style: key, 
                        fontSize: style.fontSize,
                        color: style.color 
                      })}
                      style={{
                        padding: '4px 8px',
                        background: selectedItems[0].item.style === key ? 'rgba(0,200,255,0.2)' : 'transparent',
                        border: `1px solid ${selectedItems[0].item.style === key ? style.color : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: selectedItems[0].item.style === key ? style.color : '#6080a0',
                        fontSize: '9px',
                        cursor: 'pointer',
                      }}
                    >
                      {style.name}
                    </button>
                  ))}
                </div>
              </div>
              
              <InputField
                label="Font Size"
                value={selectedItems[0].item.fontSize || 14}
                onChange={(val) => updateText(selectedItems[0].item.id, { fontSize: parseInt(val) || 14 })}
                type="number"
              />
              
              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Color</label>
                <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
                  {['#ffffff', '#00c8ff', '#00ffaa', '#ffaa00', '#ff6666', '#aa88ff'].map(color => (
                    <button
                      key={color}
                      onClick={() => updateText(selectedItems[0].item.id, { color })}
                      style={{
                        width: '24px',
                        height: '24px',
                        background: color,
                        border: selectedItems[0].item.color === color ? '2px solid #fff' : '1px solid rgba(255,255,255,0.2)',
                        borderRadius: '4px',
                        cursor: 'pointer',
                      }}
                    />
                  ))}
                </div>
              </div>
              
              <InputField
                label="Rotation (degrees)"
                value={selectedItems[0].item.rotation || 0}
                onChange={(val) => updateText(selectedItems[0].item.id, { rotation: parseInt(val) || 0 })}
                type="number"
              />
              
              <button
                onClick={() => {
                  const textId = selectedItems[0].item.id;
                  updateActiveFloor(f => ({
                    ...f,
                    texts: f.texts.filter(t => t.id !== textId)
                  }));
                  setSelectedItems([]);
                }}
                style={{
                  width: '100%',
                  marginTop: '10px',
                  padding: '10px',
                  background: 'rgba(255,80,80,0.15)',
                  border: '1px solid rgba(255,80,80,0.4)',
                  borderRadius: '6px',
                  color: '#ff6666',
                  fontSize: '11px',
                  fontWeight: '500',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '6px',
                }}
              >
                üóëÔ∏è Delete Text
              </button>
              
              <div style={{ marginTop: '10px', fontSize: '9px', color: '#6080a0' }}>
                üí° Drag to move ‚Ä¢ Delete key to remove
              </div>
            </div>
          )}
          {showRoomPanel && selectedItems[0]?.type === 'room' && !editorsMinimized && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '170px' : '180px',
              zIndex: 250,
              maxHeight: isMobile ? '50vh' : 'auto',
              overflowY: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                <span style={{ color: '#fff', fontSize: '11px', fontWeight: '500' }}>Edit Room</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button onClick={() => setEditorsMinimized(true)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px', padding: '4px' }} title="Minimize">‚àí</button>
                  <button onClick={() => setShowRoomPanel(false)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer' }}>√ó</button>
                </div>
              </div>
              
              <InputField
                label="Room Name"
                value={selectedItems[0].item.name}
                onChange={(val) => updateRoom(selectedItems[0].item.id, { name: val })}
              />
              
              <div>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Type</label>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '3px' }}>
                  {ROOM_PRESETS.map(preset => (
                    <button
                      key={preset.name}
                      onClick={() => updateRoom(selectedItems[0].item.id, { name: preset.name, color: preset.color })}
                      style={{
                        padding: '5px',
                        background: preset.color,
                        border: selectedItems[0].item.name === preset.name ? '2px solid #00c8ff' : '1px solid rgba(255,255,255,0.1)',
                        borderRadius: '4px',
                        color: '#fff',
                        fontSize: '8px',
                        cursor: 'pointer',
                      }}
                    >
                      {preset.name}
                    </button>
                  ))}
                </div>
              </div>
            </div>
          )}
          {showRoofPanel && selectedItems[0]?.type === 'roof' && !editorsMinimized && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              top: isMobile ? '60px' : '16px',
              right: isMobile ? '10px' : '16px',
              background: 'rgba(8,12,16,0.98)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '10px',
              padding: isMobile ? '12px' : '14px',
              width: isMobile ? '180px' : '200px',
              zIndex: 250,
              maxHeight: isMobile ? '60vh' : 'auto',
              overflowY: 'auto',
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                <span style={{ color: '#fff', fontSize: '11px', fontWeight: '500' }}>Edit Roof</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button onClick={() => setEditorsMinimized(true)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer', fontSize: '14px', padding: '4px' }} title="Minimize">‚àí</button>
                  <button onClick={() => setShowRoofPanel(false)} style={{ background: 'none', border: 'none', color: '#6080a0', cursor: 'pointer' }}>√ó</button>
                </div>
              </div>

              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Roof Type</label>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '3px' }}>
                  {Object.entries(ROOF_TYPES).map(([key, def]) => (
                    <button
                      key={key}
                      onClick={() => {
                        updateActiveFloor(f => ({
                          ...f,
                          roofs: f.roofs.map(r => r.id === selectedItems[0].item.id ? { ...r, type: key } : r)
                        }));
                        setSelectedItems([{ type: 'roof', item: { ...selectedItems[0].item, type: key } }]);
                      }}
                      style={{
                        padding: '6px 4px',
                        background: selectedItems[0].item.type === key ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                        border: `1px solid ${selectedItems[0].item.type === key ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: '4px',
                        color: selectedItems[0].item.type === key ? '#00c8ff' : '#8899aa',
                        fontSize: '9px',
                        cursor: 'pointer',
                      }}
                    >
                      {def.label}
                    </button>
                  ))}
                </div>
              </div>

              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Pitch</label>
                <select
                  value={selectedItems[0].item.pitch || '6:12'}
                  onChange={(e) => {
                    updateActiveFloor(f => ({
                      ...f,
                      roofs: f.roofs.map(r => r.id === selectedItems[0].item.id ? { ...r, pitch: e.target.value } : r)
                    }));
                    setSelectedItems([{ type: 'roof', item: { ...selectedItems[0].item, pitch: e.target.value } }]);
                  }}
                  style={{
                    width: '100%',
                    padding: '6px',
                    background: '#1a2028',
                    border: '1px solid rgba(255,255,255,0.1)',
                    borderRadius: '4px',
                    color: '#fff',
                    fontSize: '10px',
                  }}
                >
                  {Object.entries(ROOF_PITCHES).map(([key, def]) => (
                    <option key={key} value={key}>{def.label}</option>
                  ))}
                </select>
              </div>

              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Overhang (inches)</label>
                <input
                  type="number"
                  value={selectedItems[0].item.overhang || 12}
                  onChange={(e) => {
                    const val = parseInt(e.target.value) || 12;
                    updateActiveFloor(f => ({
                      ...f,
                      roofs: f.roofs.map(r => r.id === selectedItems[0].item.id ? { ...r, overhang: val } : r)
                    }));
                    setSelectedItems([{ type: 'roof', item: { ...selectedItems[0].item, overhang: val } }]);
                  }}
                  style={{
                    width: '100%',
                    padding: '6px',
                    background: '#1a2028',
                    border: '1px solid rgba(255,255,255,0.1)',
                    borderRadius: '4px',
                    color: '#fff',
                    fontSize: '10px',
                  }}
                />
              </div>

              <div style={{ marginBottom: '10px' }}>
                <label style={{ color: '#6080a0', fontSize: '10px', display: 'block', marginBottom: '4px' }}>Ridge Direction</label>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button
                    onClick={() => {
                      updateActiveFloor(f => ({
                        ...f,
                        roofs: f.roofs.map(r => r.id === selectedItems[0].item.id ? { ...r, ridgeDirection: 'horizontal' } : r)
                      }));
                      setSelectedItems([{ type: 'roof', item: { ...selectedItems[0].item, ridgeDirection: 'horizontal' } }]);
                    }}
                    style={{
                      flex: 1,
                      padding: '6px',
                      background: selectedItems[0].item.ridgeDirection === 'horizontal' ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                      border: `1px solid ${selectedItems[0].item.ridgeDirection === 'horizontal' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '4px',
                      color: selectedItems[0].item.ridgeDirection === 'horizontal' ? '#00c8ff' : '#8899aa',
                      fontSize: '9px',
                      cursor: 'pointer',
                    }}
                  >
                    E-W
                  </button>
                  <button
                    onClick={() => {
                      updateActiveFloor(f => ({
                        ...f,
                        roofs: f.roofs.map(r => r.id === selectedItems[0].item.id ? { ...r, ridgeDirection: 'vertical' } : r)
                      }));
                      setSelectedItems([{ type: 'roof', item: { ...selectedItems[0].item, ridgeDirection: 'vertical' } }]);
                    }}
                    style={{
                      flex: 1,
                      padding: '6px',
                      background: selectedItems[0].item.ridgeDirection === 'vertical' ? 'rgba(0,200,255,0.2)' : 'rgba(255,255,255,0.05)',
                      border: `1px solid ${selectedItems[0].item.ridgeDirection === 'vertical' ? 'rgba(0,200,255,0.4)' : 'rgba(255,255,255,0.1)'}`,
                      borderRadius: '4px',
                      color: selectedItems[0].item.ridgeDirection === 'vertical' ? '#00c8ff' : '#8899aa',
                      fontSize: '9px',
                      cursor: 'pointer',
                    }}
                  >
                    N-S
                  </button>
                </div>
              </div>

              <div style={{ fontSize: '9px', color: '#6080a0', marginTop: '10px' }}>
                Footprint: {formatMeasurement(pixelsToFeet(selectedItems[0].item.width))} √ó {formatMeasurement(pixelsToFeet(selectedItems[0].item.height))}
              </div>

              <button
                onClick={() => {
                  updateActiveFloor(f => ({
                    ...f,
                    roofs: f.roofs.filter(r => r.id !== selectedItems[0].item.id)
                  }));
                  setSelectedItems([]);
                  setShowRoofPanel(false);
                }}
                style={{
                  width: '100%',
                  marginTop: '10px',
                  padding: '8px',
                  background: 'rgba(255,80,80,0.1)',
                  border: '1px solid rgba(255,80,80,0.3)',
                  borderRadius: '6px',
                  color: '#ff8888',
                  fontSize: '10px',
                  cursor: 'pointer',
                }}
              >
                Delete Roof
              </button>
            </div>
          )}

          {/* Stats - hide on mobile when menu is open */}
          {viewMode === 'model' && !(isMobile && showMobileMenu) && (
            <div style={{
              position: isMobile ? 'fixed' : 'absolute',
              bottom: isMobile ? '70px' : '12px',
              left: '12px',
              background: 'rgba(8,12,16,0.95)',
              border: '1px solid rgba(0,200,255,0.2)',
              borderRadius: '8px',
              padding: isMobile ? '8px 12px' : '10px 14px',
              backdropFilter: 'blur(10px)',
              zIndex: 500,
            }}>
              <div style={{ color: '#4a6070', fontSize: '8px', letterSpacing: '0.5px', marginBottom: '4px' }}>STATS</div>
              <div style={{ display: 'flex', gap: isMobile ? '8px' : '12px', flexWrap: 'wrap' }}>
                {[
                  { label: 'Walls', value: stats.walls },
                  { label: 'Doors', value: stats.doors },
                  { label: 'Windows', value: stats.windows },
                  { label: 'Furn', value: stats.furniture },
                  { label: 'Dims', value: stats.dimensions },
                  { label: 'Sq.Ft', value: stats.area },
                ].map(stat => (
                  <div key={stat.label}>
                    <div style={{ color: '#00c8ff', fontSize: isMobile ? '12px' : '14px', fontWeight: '600' }}>{stat.value}</div>
                    <div style={{ color: '#4a6070', fontSize: '8px' }}>{stat.label}</div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

// Render the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<FloorPlanPro />);
  </script>
</body>
</html>
